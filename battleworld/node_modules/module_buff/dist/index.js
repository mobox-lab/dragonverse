'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
* @Author       : MengYao.Zhao
* @Date         : 2022/04/13 10:51:51
* @Description  :  buff用到的一些通用数据,枚举, 通用函数...
*/
/**
 * 转换数组到Vector
 * @param pos number[3]
 * @param defaultValue  不存在时默认分量值
 * @returns
 */
function convertArrayToVector(pos, defaultValue = 0) {
    return pos == null ? new mw.Vector(defaultValue) : new mw.Vector(pos[0] == null ? defaultValue : pos[0], pos[1] == null ? defaultValue : pos[1], pos[2] == null ? defaultValue : pos[2]);
}
/**
 * 转换数组到Rotation,不存在则默认到标准朝向
 * @param rot number[3]
 * @returns
 */
function convertArrayToRotation(rot) {
    return rot == null ? mw.Rotation.zero : new mw.Rotation(rot[0] == null ? 0 : rot[0], rot[1] == null ? 0 : rot[1], rot[2] == null ? 0 : rot[2]);
}
/**
 * Buff的生成规则
 */
exports.EBuffSpawnRule = void 0;
(function (EBuffSpawnRule) {
    /**
     * 后端做逻辑，通知前端做表现
     */
    EBuffSpawnRule[EBuffSpawnRule["Client"] = 0] = "Client";
    /**
     * 后端做逻辑，后端做双端表现，前端不参与
     */
    EBuffSpawnRule[EBuffSpawnRule["Server"] = 1] = "Server";
    /**
     * 仅有后端逻辑，无任何表现，前端不参与
     */
    EBuffSpawnRule[EBuffSpawnRule["OnlyLogic"] = 2] = "OnlyLogic";
})(exports.EBuffSpawnRule || (exports.EBuffSpawnRule = {}));
/**
 * buff宿主类型
 */
exports.EBuffHostType = void 0;
(function (EBuffHostType) {
    /**
     * 表示无宿主，放在世界位置的
     */
    EBuffHostType[EBuffHostType["None"] = 0] = "None";
    /**
     * 技能对象，也就是玩家
     */
    EBuffHostType[EBuffHostType["Player"] = 1] = "Player";
    /**
     * 物体上
     */
    EBuffHostType[EBuffHostType["GameObject"] = 2] = "GameObject";
})(exports.EBuffHostType || (exports.EBuffHostType = {}));
/**
 * buff效果类型
 */
exports.EBuffEffectType = void 0;
(function (EBuffEffectType) {
    /**
     * 无效的
     */
    EBuffEffectType[EBuffEffectType["None"] = 0] = "None";
    /**
     * 基础属性有变化
     */
    EBuffEffectType[EBuffEffectType["PropertyChange"] = 1] = "PropertyChange";
    /**
     * 生成一些新buff
     */
    EBuffEffectType[EBuffEffectType["SpawnNewBuff"] = 2] = "SpawnNewBuff";
    /**
     * 调用释放技能
     */
    EBuffEffectType[EBuffEffectType["CallSkill"] = 3] = "CallSkill";
    /**
     * 切换自身的模型
     */
    EBuffEffectType[EBuffEffectType["ChangeModel"] = 4] = "ChangeModel";
    /**
     * 晕眩
     */
    EBuffEffectType[EBuffEffectType["Stun"] = 5] = "Stun";
})(exports.EBuffEffectType || (exports.EBuffEffectType = {}));
/**
 * buff的叠加方式
 */
exports.EBuffOverlayType = void 0;
(function (EBuffOverlayType) {
    /**
     * 独占的，表示宿主身上只能有一个
     */
    EBuffOverlayType[EBuffOverlayType["Only"] = 0] = "Only";
    /**
     * 可叠加的，允许多个同id的buff存在
     */
    EBuffOverlayType[EBuffOverlayType["Overlap"] = 1] = "Overlap";
    /**
     * 没有该类型的buff就是新的，有就在旧buff上追加时间
     */
    EBuffOverlayType[EBuffOverlayType["AddTime"] = 2] = "AddTime";
    /**
     * 没有该类型的buff就是全新的，有就是旧buff上刷新时间
     */
    EBuffOverlayType[EBuffOverlayType["RefreshTime"] = 3] = "RefreshTime";
})(exports.EBuffOverlayType || (exports.EBuffOverlayType = {}));
/**
 * buff的生命周期类型
 */
exports.EBuffLifecycleType = void 0;
(function (EBuffLifecycleType) {
    /**
     * 永远存在的
     */
    EBuffLifecycleType[EBuffLifecycleType["Forever"] = 0] = "Forever";
    /**
     * 受时间限制
     */
    EBuffLifecycleType[EBuffLifecycleType["LimitByTime"] = 1] = "LimitByTime";
    /**
     * 受触发次数限制
     */
    EBuffLifecycleType[EBuffLifecycleType["LimitByTriggerCount"] = 2] = "LimitByTriggerCount";
})(exports.EBuffLifecycleType || (exports.EBuffLifecycleType = {}));
/**
 * buff参数的数值代表的类型
 */
exports.EBuffParamType = void 0;
(function (EBuffParamType) {
    /**
     * 值类型
     */
    EBuffParamType[EBuffParamType["Value"] = 0] = "Value";
    /**
     * 百分比类型
     */
    EBuffParamType[EBuffParamType["Percent"] = 1] = "Percent";
})(exports.EBuffParamType || (exports.EBuffParamType = {}));
/**
 * buff影响的基础属性类型
 */
exports.EBuffPropertyType = void 0;
(function (EBuffPropertyType) {
    /**
     * 无效的
     */
    EBuffPropertyType[EBuffPropertyType["None"] = 0] = "None";
    /**
     * 攻击力
     */
    EBuffPropertyType[EBuffPropertyType["Atk"] = 1] = "Atk";
    /**
     * 防御力
     */
    EBuffPropertyType[EBuffPropertyType["Def"] = 2] = "Def";
    /**
     * 当前血量
     */
    EBuffPropertyType[EBuffPropertyType["Hp"] = 3] = "Hp";
    /**
     * 最大血量
     */
    EBuffPropertyType[EBuffPropertyType["HpMax"] = 4] = "HpMax";
    /**
     * 移动速度
     */
    EBuffPropertyType[EBuffPropertyType["Speed"] = 5] = "Speed";
    /**
     * 攻击间隔 s
     */
    EBuffPropertyType[EBuffPropertyType["AtkInterval"] = 6] = "AtkInterval";
    /**
     * 暴击率 小数
     */
    EBuffPropertyType[EBuffPropertyType["CriticalRate"] = 7] = "CriticalRate";
    /**
     * 命中率 小数
     */
    EBuffPropertyType[EBuffPropertyType["HitRate"] = 8] = "HitRate";
    /**
     * 闪避率 小数
     */
    EBuffPropertyType[EBuffPropertyType["DodgeRate"] = 9] = "DodgeRate";
})(exports.EBuffPropertyType || (exports.EBuffPropertyType = {}));
/**
 * 子buff的生成时机
 */
exports.EBuffTriggerOpportunity = void 0;
(function (EBuffTriggerOpportunity) {
    /**
     * 无效的
     */
    EBuffTriggerOpportunity[EBuffTriggerOpportunity["None"] = 0] = "None";
    /**
     * 在初始化完成后执行时
     */
    EBuffTriggerOpportunity[EBuffTriggerOpportunity["OnExecute"] = 1] = "OnExecute";
    /**
     * 在每次效果触发时触发
     */
    EBuffTriggerOpportunity[EBuffTriggerOpportunity["OnTrigger"] = 2] = "OnTrigger";
})(exports.EBuffTriggerOpportunity || (exports.EBuffTriggerOpportunity = {}));
/**
 * 定义buff用的rpc函数名
 */
exports.buffRpcFun = void 0;
(function (buffRpcFun) {
    /**
     * 在玩家 身上生成buff的网络通信函数名
     */
    buffRpcFun.net_SpawnBuffInPlayer = "net_SpawnBuffInPlayer";
    /**
     * 在物体身上生成buff的网络通信函数名
     */
    buffRpcFun.net_SpawnBuffInObject = "net_SpawnBuffInObject";
    /**
     * 在世界位置生成buff的网络通信函数名
     */
    buffRpcFun.net_SpawnBuffInPlace = "net_SpawnBuffInPlace";
    /**
    * 移除一个buff的网络通信函数名
    */
    buffRpcFun.net_DestroyBuff = "net_DestroyBuff";
    /**
    *  移除一批buff的网络通信函数名
    */
    buffRpcFun.net_DestroyBuffs = "net_DestroyBuffs";
})(exports.buffRpcFun || (exports.buffRpcFun = {}));

/**
* @Author       : MengYao.Zhao
* @Date         : 2022/04/13 10:52:21
* @Description  : 主要缓存对Buff的增删改查，还有对Buff的特效的生成管理
*/
class BuffManager {
    /**
     * 所有静态buff，外部初始化进来的
     */
    staticBuffs;
    /**
     * 是否完成了初始化
     */
    isInit = false;
    /**
     * 所有宿主身上的buff，字典，方便查询 key= SkillBaseActor.guid/GameObject.guid
     */
    hostBuffsDic;
    /**
     * 缓存buff的宿主对象 mw.Player | mw.GameObject ,key= SkillBaseActor.guid/GameObject.guid
     */
    hostsDic;
    /**
     * 所有buff 包含宿主buff和世界位置buff,用于查询，key为buff的动态id
     */
    buffsDic;
    /**
     * 所有buff，包含宿主buff和世界位置buff,可以用于遍历，有时序
     */
    buffsList;
    /**
     * 当buff开始创建时 参数1代表创建buff要使用的的数据结构，参数2表示该buff的宿主对象类型，生成特效时有用, 当设置manualPlayEffect=true时会在buff创建时调用
     */
    _onBuffEffectPreCreate = null;
    get onBuffEffectPreCreate() {
        return this._onBuffEffectPreCreate;
    }
    /**
     * 当全新的成功创建了后的回调
     */
    _onBuffCreated = null;
    get onBuffCreated() {
        return this._onBuffCreated;
    }
    /**
     * 当buff开始销毁前的回调
     */
    _onBuffPreDestroy = null;
    get onBuffPreDestroy() {
        return this._onBuffPreDestroy;
    }
    /**
     * 是否手动的播放buff特效，如果为false，将使用Odin的特效管理器进行特效播放， 如果为true  注册回调onBuffEffectPreCreate，手动在模块外管理自己的特效
     */
    manualPlayEffect = false;
    /**
     * 初始化
     * @param staticBuffData  静态buff数据,传入GameConfig.Buff.getAllElement()即可
     */
    init(staticBuffData) {
        this.staticBuffs = new Map();
        staticBuffData.forEach((buffData, _) => {
            this.staticBuffs.set(buffData.id, buffData);
        });
        this.hostBuffsDic = new Map();
        this.buffsDic = new Map();
        this.hostsDic = new Map();
        this.buffsList = [];
        this._onBuffEffectPreCreate = new mw.Action2();
        this._onBuffCreated = new mw.Action1();
        this._onBuffPreDestroy = new mw.Action1();
    }
    /**
     * 销毁 ,想把BuffManager 彻底清除
     * 注意如果调用之后，要再次使用BuffManager  需要再调用init方法再做初始化 ,且之前如果有的监听情况需要重新去监听,否则可以考虑 调用 clearBuffs();
     */
    destroy() {
        this.hostBuffsDic = null;
        this.buffsDic = null;
        this.hostsDic = null;
        if (this.buffsList) {
            this.buffsList.forEach((buff) => {
                buff.destroy();
            });
            this.buffsList = null;
        }
        this._onBuffEffectPreCreate.clear();
        this._onBuffEffectPreCreate = null;
        this._onBuffCreated.clear();
        this._onBuffCreated = null;
        this._onBuffPreDestroy.clear();
        this._onBuffPreDestroy = null;
        this.isInit = false;
    }
    /**
     * 从静态表里根据buff的静态id,查询静态数据
     * @param configId
     */
    findStaticBuffById(configId) {
        return this.staticBuffs.get(configId);
    }
    /**
     * 给玩家身上添加buff特效
     * @param buff 特效归属的buff
     * @param playerId SkillBaseActor.guid
     * @param slotIndex  玩家对象上的的插槽
     * @param relativePos  相对位置
     * @param relativeRot  相对朝向
     * @param scale  缩放
     */
    playBuffEffectInPlayer(buff, playerId, slotIndex, relativePos, relativeRot, scale) {
        let playerTarget = Number(playerId);
        let playerHost = this.getHost(playerId);
        if (playerHost) {
            playerTarget = playerHost;
        }
        buff.playEffectInPlayer(playerTarget, slotIndex, relativePos, relativeRot, scale);
    }
    /**
      * 给物体身上添加buff特效
      * @param buff 特效归属的buff
      * @param objGuid mw.GameObject.guid
      * @param relativePos  相对位置
      * @param relativeRot  相对朝向
      * @param scale  缩放
      */
    playBuffEffectInGameObject(buff, objGuid, relativePos, relativeRot, scale) {
        let objTarget = objGuid;
        let objHost = this.getHost(objGuid);
        if (objHost) {
            objTarget = objHost;
        }
        buff.playEffectInGameObject(objTarget, relativePos, relativeRot, scale);
    }
    /**
     * 寻找缓存的宿主对象
     * @param hostGuid SkillBaseActor.guid/GameObject.guid
     * @returns mw.Player | mw.GameObject
     */
    getHost(hostGuid) {
        let result = null;
        try {
            result = this.hostsDic.get(hostGuid);
            if (!result)
                return null;
            let pos;
            if (result instanceof Player)
                result.character.worldTransform.position; //临时取赋一下值，如果该玩家或者物体在外部已经被销毁了，那么从异常处，清理掉缓存
            else
                result.worldTransform.position = pos;
            return result;
        }
        catch (error) {
            if (this.hostsDic.has(hostGuid))
                this.hostsDic.delete(hostGuid);
            if (this.hostBuffsDic.has(hostGuid)) {
                this.removeBuffs(this.hostBuffsDic.get(hostGuid));
            }
            return null;
        }
    }
    /**
     * 当buff已经成功绑定了特效时
     * @param buff
     */
    onBuffAttachEffect(buff) {
        if (!this.hostsDic)
            return;
        //缓存一下buff的宿主，方便后期使用
        let host = this.getHost(buff.hostGuid);
        if (!host) {
            //新建立一个映射
            this.hostsDic.set(buff.hostGuid, buff.host);
        }
        let hostContainer = this.hostBuffsDic.get(buff.hostGuid);
        if (!hostContainer) {
            //新建立一个缓存容器
            hostContainer = [];
            this.hostBuffsDic.set(buff.hostGuid, hostContainer);
        }
        if (!hostContainer.includes(buff)) {
            hostContainer.push(buff);
        }
    }
    /**
     * 当一个全新的buff被创建成功后
     * @param buff
     */
    onBuffCreateSuccess(buff) {
        //监听buff的特效绑定成功了
        const func = (buff) => {
            this.onBuffAttachEffect(buff);
            buff.onAttachedEffect.remove(func, this);
        };
        buff.onAttachedEffect.add(func, this);
    }
    /**
     * 销毁一批buff
     * @param buffs
     */
    removeBuffs(buffs) {
        buffs.forEach((buff) => {
            this.removeBuff(buff);
        });
    }
    /**
     * 销毁一个buff
     * @param buff
     */
    removeBuff(buff) {
        let buffIndex = this.buffsList.indexOf(buff);
        if (buffIndex > -1) {
            this.buffsList.splice(buffIndex, 1);
        }
        if (buff.hostGuid) {
            let hostContainer = this.hostBuffsDic.get(buff.hostGuid);
            if (hostContainer) {
                buffIndex = hostContainer.indexOf(buff);
                if (buffIndex > -1) {
                    hostContainer.splice(buffIndex, 1);
                }
                if (hostContainer.length == 0)
                    this.hostBuffsDic.delete(buff.hostGuid);
            }
            this.onBuffPreRemove(buff);
        }
        if (this._onBuffPreDestroy) {
            this._onBuffPreDestroy.call(buff);
        }
        buff.destroy();
        this.buffsDic.delete(buff.id);
    }
    /**
     * 清理所有buff
     */
    clearBuffs() {
        if (this.buffsList) {
            this.removeBuffs(this.buffsList);
        }
    }
    /**
     * 当buff需要移除前
     * @param buff
     */
    onBuffPreRemove(buff) {
    }
    /**
     * 获取当前所有buff
     * @returns buff对象列表
     */
    getBuffs() {
        return this.buffsList;
    }
    /**
     * 通过buff的动态id查询buff对象
     * @param buffId
     * @returns buff对象
     */
    findBuff(buffId) {
        if (this.buffsDic)
            return this.buffsDic.get(buffId);
        return null;
    }
    /**
     * 通过宿主guid获得宿主身上的buff列表
     * @param hostId   SkillBaseActor.guid/mw.GameObject.guid
     * @returns buff对象列表
     */
    findBuffByHostId(hostId) {
        if (this.hostBuffsDic) {
            return this.hostBuffsDic.get(hostId);
        }
        return null;
    }
    /**
     * 通过buff的静态id，和宿主的guid来查找宿主身上某种类型的所有buff，如果宿主guid不存在，则会找寻所有可能的该类型的buff
     * @param configId buff静态id
     * @param hostId buff的宿主 guid
     */
    findBuffByConfigId(configId, hostId = null) {
        if (hostId) {
            if (this.hostBuffsDic) {
                let hostContainer = this.hostBuffsDic.get(hostId);
                if (hostContainer) {
                    let reuslt = [];
                    hostContainer.forEach((buff) => {
                        if (buff.configId == configId) {
                            reuslt.push(buff);
                        }
                    });
                    return reuslt;
                }
            }
        }
        else {
            if (this.buffsList) {
                let reuslt = [];
                this.buffsList.forEach((buff) => {
                    if (buff.configId == configId) {
                        reuslt.push(buff);
                    }
                });
                return reuslt;
            }
        }
        return [];
    }
    /**
     * 通过buff的效果类型，和宿主的guid来查找宿主身上某种buff效果的的所有buff
     * @param hostId buff的宿主 guid
     * @param effectType buff的宿主 guid
     */
    findBuffByEffectType(hostId, effectType) {
        if (hostId) {
            if (this.hostBuffsDic) {
                let hostContainer = this.hostBuffsDic.get(hostId);
                if (hostContainer) {
                    let reuslt = [];
                    hostContainer.forEach((buff) => {
                        if (buff.buffEffectType == effectType) {
                            reuslt.push(buff);
                        }
                    });
                    return reuslt;
                }
            }
        }
        return [];
    }
    /**
     * 遍历buff
     * @param callBack
     */
    forEach(callBack) {
        if (!this.buffsList)
            return;
        this.buffsList.forEach((value) => {
            callBack(value);
        });
    }
    /**在一个角色的挂点上播放特效 */
    static rpcPlayEffectOnPlayer(source, target, slotType, loopCount, offset, rotation, scale) {
        return EffectService.playOnGameObject(source, target instanceof mw.Player ? target.character : target, {
            slotType: slotType,
            loopCount: loopCount,
            position: offset,
            rotation: rotation,
            scale: scale
        });
    }
    /**在一个GameObject上播放特效 */
    static rpcPlayEffectOnGameObject(source, target, loopCount, offset, rotation, scale) {
        return EffectService.playOnGameObject(source, target, {
            loopCount: loopCount,
            position: offset,
            rotation: rotation,
            scale: scale
        });
    }
    /**在指定位置播放特效 */
    static rpcPlayEffectAtLocation(source, location, loopCount, rotation, scale) {
        return EffectService.playAtPosition(source, location, {
            loopCount: loopCount,
            rotation: rotation,
            scale: scale,
        });
    }
}

/*
 * @Author: xicun.kang xicun.kang@appshahe.com
 * @Date: 2023-07-18 15:40:10
 * @LastEditors: xicun.kang xicun.kang@appshahe.com
 * @LastEditTime: 2023-08-06 18:40:48
 * @FilePath: \commonmodule_buff\JavaScripts\module\buff\BuffBase.ts
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 */
/**
 * buff模块内部使用buff数据结构，字段类型和包含于excel导表工具导出的数据类型
 */
class BuffData {
    /**id*/
    id;
    /**名称*/
    name;
    /**buff描述*/
    description;
    /**图标*/
    icon;
    /**Buff的效果类型*/
    buffEffectType;
    /**buff的叠加方式*/
    overlayType;
    /**buff的生命周期类型*/
    lifecycleType;
    /**持续时间(单位s)*/
    duration;
    /**触发次数*/
    triggerCount;
    /**触发间隔(单位s)*/
    triggerInterval;
    /**动作的guid*/
    actionGuid;
    /**buff生成时产生的特效Guid*/
    effectGuid;
    /**是否循环。0-不循环，1-循环*/
    loop;
    /**buff生成时特效延迟多久出现(单位s)*/
    effectDelayTime;
    /**特效挂载人物身上的插槽索引*/
    effectSlotIndex;
    /**特效挂载于人物插槽|物体时的相对位置*/
    relativePos;
    /**特效挂载于人物插槽|物体时的相对朝向*/
    relativeRot;
    /**特效缩放*/
    scale;
    /**影响的属性类型*/
    affectPropertyType;
    /**子buff的生效时机*/
    buffTriggerOpportunity;
    /**会生成的通用子buff*/
    subBuffs;
    /**调用新的技能的生效时机*/
    skillTriggerOpportunity;
    /**会调用新的技能*/
    skillId;
    /**参数Param1是值类型还是百分比类型*/
    param1_Model;
    /**参数1*/
    param1;
    /**参数Param2是值类型还是百分比类型*/
    param2_Model;
    /**参数2*/
    param2;
    /**参数Param3是值类型还是百分比类型*/
    param3_Model;
    /**参数3*/
    param3;
    /**备注: 记录一些参数值在不同buff下代表的意义*/
    ps;
}
class BuffBase {
    /**
     * 动态唯一id
     */
    _id = 0;
    get id() {
        return this._id;
    }
    /**
     * 是否已经死亡了，如果已经死亡将被Buff管理器销毁
     */
    _dead = false;
    get dead() {
        return this._dead;
    }
    /**
     * 是否已经死亡了，用于回收
     */
    destroyFlag = false;
    /**
     * 宿主guid，SkillBaseActor.guid/GameObject.guid , 如果不存在表示该buff位于世界位置上
     */
    _hostGuid = null;
    get hostGuid() {
        return this._hostGuid;
    }
    set hostGuid(value) {
        this._hostGuid = value;
    }
    /**
     * 宿主的类型
     */
    _hostType = exports.EBuffHostType.None;
    get hostType() {
        return this._hostType;
    }
    set hostType(value) {
        this._hostType = value;
    }
    /**
     * 特效的宿主对象,mw.Player | mw.GameObject，不存在表示该特效生成在世界位置上
     */
    _host = null;
    get host() {
        return this._host;
    }
    /**
     * 对应的buff特效id,在生成之后由Odin的mw.EffectService播放之后给出
     * 该id可以使用mw.EffectService去查找到特效，如果有时需要在部位去调整这个特效的一些情况，可以查找出来自由处理
     */
    _buffEffectId = null;
    get buffEffectId() {
        return this._buffEffectId;
    }
    /**
     * 当有宿主存在且完成特效绑定时
     */
    _onAttachedEffect = null;
    get onAttachedEffect() {
        return this._onAttachedEffect;
    }
    /**
     * 静态buff表
     */
    _staticConfig;
    get staticConfig() {
        return this._staticConfig;
    }
    //#region  静态表转化字段，方便使用和维护
    /**
     * 静态buff表里的id
     */
    _configId = 0;
    get configId() {
        return this._configId;
    }
    /**
     * buff的名字
     */
    _name = "";
    get name() {
        return this._name;
    }
    /**
     * buff的描述
     */
    _desc = "";
    get desc() {
        return this._desc;
    }
    /**
     * buff的图标
     */
    _icon;
    get icon() {
        return this._icon;
    }
    /**
     * buff的效果类型
     */
    _buffEffectType;
    get buffEffectType() {
        return this._buffEffectType;
    }
    /**
     * buff的叠加方式
     */
    _buffOverlayType;
    get buffOverlayType() {
        return this._buffOverlayType;
    }
    /**
     * buff的生命周期
     */
    _buffLifecycleType;
    get buffLifecycleType() {
        return this._buffLifecycleType;
    }
    /**
     * buff的有限时间，在EBuffLifecycleType==1时使用
     */
    _duration;
    get duration() {
        return this._duration;
    }
    /**
     * buff的触发次数,在EBuffLifecycleType==2时使用
     */
    _triggerCount;
    get triggerCount() {
        return this._triggerCount;
    }
    /**
     * buff的触发次数的间隔,在EBuffLifecycleType==2时使用
     */
    _triggerInterval;
    get triggerInterval() {
        return this._triggerInterval;
    }
    /**
     * buff生成时需要产生的玩家动作guid
     */
    _occurredActionGuid;
    get occurredActionGuid() {
        return this._occurredActionGuid;
    }
    /**
     * buff生成时的特效资源guid
     */
    _effectGuid;
    get effectGuid() {
        return this._effectGuid;
    }
    /**
     * 特效是否循环，0-不循环，1，循环
     */
    _effectLoop;
    get effectLoop() {
        return this._effectLoop;
    }
    /**
     * buff生成时的特效资源延迟出现的时间
     */
    _effectDelayShow;
    get effectDelayShow() {
        return this._effectDelayShow;
    }
    /**
    * buff生成时的特效资源挂载到人物身上的插槽索引
    */
    _mountSlotIndex; //.CharacterSocketType;
    get mountSlotIndex() {
        return this._mountSlotIndex;
    }
    /**
    * buff生成时的特效资源挂载到人物身上某个插槽的相对位置
    */
    _relativePos;
    get relativePos() {
        return this._relativePos;
    }
    /**
    * buff生成时的特效资源挂载到人物身上某个插槽的相对朝向
    */
    _relativeRot;
    get relativeRot() {
        return this._relativeRot;
    }
    /**
    * buff生成时的特效资源挂载到人物身上某个插槽的缩放
    */
    _scale;
    get scale() {
        return this._scale;
    }
    /**
    * buff是属性变化时的变化类型
    */
    _affectPropertyType;
    get affectPropertyType() {
        return this._affectPropertyType;
    }
    /**
    * 子buff的施加时机
    */
    _subBuffTriggerOpportunity;
    get subBuffTriggerOpportunity() {
        return this._subBuffTriggerOpportunity;
    }
    /**
    * buff可能生成的子buff id列表
    */
    _subBuffIds;
    get subBuffIds() {
        return this._subBuffIds;
    }
    /**
    * 技能的调用时机
    */
    _skillTriggerOpportunity;
    get skillTriggerOpportunity() {
        return this._skillTriggerOpportunity;
    }
    /**
    * buff可能调用的新技能id
    */
    _skillId;
    get skillId() {
        return this._skillId;
    }
    /**
    * buff参数1的值的类型
    */
    _param1_modle;
    get param1_modle() {
        return this._param1_modle;
    }
    /**
    * buff参数1的值
    */
    _param1;
    get param1() {
        return this._param1;
    }
    /**
    * buff参数2的值的类型
    */
    _param2_modle;
    get param2_modle() {
        return this._param2_modle;
    }
    /**
    * buff参数2的值
    */
    _param2;
    get param2() {
        return this._param2;
    }
    /**
    * buff参数3的值的类型
    */
    _param3_modle;
    get param3_modle() {
        return this._param3_modle;
    }
    /**
    * buff参数3的值
    */
    _param3;
    get param3() {
        return this._param3;
    }
    //#endregion
    /**
     * 构造buff基类数据
     * @param _id 全局id
     * @param staticConfig buff静态表
     */
    constructor(_id, staticConfig) {
        this._id = _id;
        this._configId = staticConfig.id;
        this._onAttachedEffect = new mw.Action1();
        this._staticConfig = staticConfig;
        this.convertstaticConfig();
    }
    /**
     * 把静态表buff里的一些东西转化到buff对象里，方便操作
     */
    convertstaticConfig() {
        if (!this._staticConfig) {
            console.error("生成buff出错了,该buff的配置不存在，请检查配置表，configId: " + this._configId);
            return;
        }
        this._name = this._staticConfig.name;
        this._desc = this._staticConfig.description;
        this._icon = this._staticConfig.icon.toString();
        this._buffEffectType = this._staticConfig.buffEffectType;
        this._buffOverlayType = this._staticConfig.overlayType;
        this._buffLifecycleType = this._staticConfig.lifecycleType;
        this._duration = this._staticConfig.duration;
        this._triggerCount = this._staticConfig.triggerCount;
        this._triggerInterval = this._staticConfig.triggerInterval;
        this._effectGuid = this._staticConfig.effectGuid.toString();
        this._effectLoop = this._staticConfig.loop;
        this._effectDelayShow = this._staticConfig.effectDelayTime;
        this._mountSlotIndex = this._staticConfig.effectSlotIndex;
        this._relativePos = convertArrayToVector(this._staticConfig.relativePos);
        this._relativeRot = convertArrayToRotation(this._staticConfig.relativeRot);
        this._scale = convertArrayToVector(this._staticConfig.scale, 1);
        this._affectPropertyType = this._staticConfig.affectPropertyType;
        this._subBuffTriggerOpportunity = this._staticConfig.buffTriggerOpportunity;
        this._subBuffIds = [];
        if (this._staticConfig.subBuffs) {
            this._staticConfig.subBuffs.forEach((buffId) => {
                this._subBuffIds.push(buffId);
            });
        }
        this._skillTriggerOpportunity = this._staticConfig.skillTriggerOpportunity;
        this._skillId = this._staticConfig.skillId;
        this._param1_modle = this._staticConfig.param1_Model;
        this._param1 = this._staticConfig.param1;
        this._param2_modle = this._staticConfig.param2_Model;
        this._param2 = this._staticConfig.param2;
        this._param3_modle = this._staticConfig.param3_Model;
        this._param3 = this._staticConfig.param3;
    }
    /**
     * 构造完成之后，可能需要一些初始化行为
     */
    init() {
    }
    /**
     * 获得buff的打印信息
     */
    dump() {
        let info = "-----------------Buff 信息-----------------\n";
        info += "动态id: " + this._id + "\n";
        info += "静态id: " + this._configId + "\n";
        info += "宿主guid: " + this._hostGuid + "\n";
        info + "宿主类型: " + this._hostType + "\n";
        info += "名称: " + this._name + "\n";
        info += "描述: " + this._desc + "\n";
        info += "图标: " + this._icon + "\n";
        info += "效果类型: " + this._buffEffectType + "\n";
        info += "叠加方式: " + this._buffOverlayType + "\n";
        info += "生命周期类型: " + this._buffLifecycleType + "\n";
        info += "持续时间: " + this._duration + "\n";
        info += "触发次数: " + this._triggerCount + "\n";
        info += "触发间隔: " + this._triggerInterval + "\n";
        info += "特效资源guid: " + this._effectGuid + "\n";
        info += "特效延迟出现的时间: " + this._effectDelayShow + "\n";
        info += "特效挂载的插槽索引: " + this._mountSlotIndex + "\n";
        info += "特效挂载的相对位置: " + this._relativePos.toString() + "\n";
        info += "特效挂载的相对朝向: " + this._relativeRot.toString() + "\n";
        info += "特效挂载的缩放: " + this._scale.toString() + "\n";
        info += "影响的属性类型: " + this._affectPropertyType + "\n";
        info += "子buff列表: " + this._subBuffIds.toString() + "\n";
        info += "可能换起的技能id: " + this._skillId + "\n";
        info += "参数1的类型: " + this.param1_modle + "\n";
        info += "参数1的值: " + this.param1 + "\n";
        info += "参数2的类型: " + this.param2_modle + "\n";
        info += "参数2的值: " + this.param2 + "\n";
        info += "参数3的类型: " + this.param3_modle + "\n";
        info += "参数3的值: " + this.param3 + "\n";
        info += "---------------------------------------------------";
        return info;
    }
    /**
     * 帧驱动
     * @param dt  s
     */
    onUpdate(dt) {
    }
    /**
     * 销毁，清理
     */
    destroy() {
        if (this.destroyFlag)
            return;
        this.destroyFlag = true;
        if (this._buffEffectId) {
            mw.EffectService.stop(this._buffEffectId);
            this._buffEffectId = null;
        }
        this._host = null;
        if (this._onAttachedEffect) {
            this._onAttachedEffect.clear();
            this._onAttachedEffect = null;
        }
    }
    /**
     * 使用Odin的mw.EffectService在玩家身上绑定一个buff特效,出现时间会收buff配置中的延迟影响
     * @param playerTarget 玩家id 或者玩家对象
     * @param slotIndex 玩家绑定的插槽位置索引
     * @param relativePos 绑定的相对位置
     * @param relativeRot  绑定的相对朝向
     * @param scale 缩放
     */
    playEffectInPlayer(playerTarget, slotIndex, relativePos, relativeRot, scale) {
        if (!Number(this.effectGuid)) {
            return;
        }
        let playEffect = (player) => {
            if (this.dead)
                return;
            this._host = player;
            this._hostGuid = player.playerId.toString();
            this._buffEffectId = BuffManager.rpcPlayEffectOnPlayer(this.effectGuid, player, slotIndex, this._effectLoop == 0 ? 1 : 0, relativePos, relativeRot, scale);
            if (this._onAttachedEffect)
                this._onAttachedEffect.call(this);
        };
        let delayPlayEffect = () => {
            if (playerTarget instanceof mw.Player) {
                playEffect(playerTarget);
            }
            else {
                playEffect(Player.localPlayer);
            }
        };
        if (this._effectDelayShow > 0) {
            //延迟一会
            mw.TimeUtil.delaySecond(this._effectDelayShow).then(() => {
                if (this.dead)
                    return;
                delayPlayEffect();
            });
        }
        else {
            delayPlayEffect();
        }
    }
    /**
     * 使用Odin的mw.EffectService在物体身上绑定一个buff特效,出现时间会受buff配置中的延迟影响
     * @param objTarget 物体的guid  或者 该物体的对象
     * @param relativePos 绑定的相对位置
     * @param relativeRot  绑定的相对朝向
     * @param scale 缩放
     */
    playEffectInGameObject(objTarget, relativePos, relativeRot, scale) {
        if (!Number(this.effectGuid)) {
            return;
        }
        let playEffect = (obj) => {
            if (this.dead)
                return;
            this._host = obj;
            this._hostGuid = obj.gameObjectId;
            this._buffEffectId = BuffManager.rpcPlayEffectOnGameObject(this.effectGuid, obj, this._effectLoop == 0 ? 1 : 0, relativePos, relativeRot, scale);
            if (this._onAttachedEffect)
                this._onAttachedEffect.call(this);
        };
        let delayPlayEffect = () => {
            if (objTarget instanceof mw.GameObject) {
                playEffect(objTarget);
            }
            else {
                mw.GameObject.asyncFindGameObjectById(objTarget).then((obj) => {
                    playEffect(obj);
                });
            }
        };
        if (this._effectDelayShow > 0) {
            mw.TimeUtil.delaySecond(this._effectDelayShow).then(() => {
                if (this.dead)
                    return;
                delayPlayEffect();
            });
        }
        else {
            delayPlayEffect();
        }
    }
    /**
     * 使用Odin的mw.EffectService在世界位置上旋转buff特效,出现时间会收buff配置中的延迟影响
     * @param worldPos 位置
     * @param worldRot  朝向
     * @param scale 缩放
     */
    playEffectInPlace(worldPos, worldRot, scale) {
        if (!Number(this.effectGuid)) {
            return;
        }
        let delayPlayEffect = () => {
            this._buffEffectId = BuffManager.rpcPlayEffectAtLocation(this.effectGuid, worldPos, this._effectLoop == 0 ? 1 : 0, worldRot, scale);
        };
        if (this._effectDelayShow > 0) {
            mw.TimeUtil.delaySecond(this._effectDelayShow).then(() => {
                if (this.dead)
                    return;
                delayPlayEffect();
            });
        }
        else {
            delayPlayEffect();
        }
    }
}

/**
* @Author       : MengYao.Zhao
* @Date         : 2022/04/13 10:55:21
* @Description  :  客户端 Buff数据 ，仅用于表现，展示特效等
*/
class BuffC extends BuffBase {
    /**
     * 构造客户端端buff类数据
     * @param _id 全局id
     * @param staticConfig buff静态表
     */
    constructor(_id, staticConfig) {
        super(_id, staticConfig);
    }
    /**
     * 构造完成之后，可能需要一些初始化行为
     * @param
     */
    init() {
        super.init();
    }
    /**
     * 销毁，清理
     */
    destroy() {
        super.destroy();
    }
}

/**
* @Author       : MengYao.Zhao
* @Date         : 2022/04/13 10:58:55
* @Description  : 客户端管理 BuffC, 对应着服务端BuffS ,仅处理其表现生成，销毁
*/
class BuffManagerC extends BuffManager {
    static _instance = null;
    /**
     * 单例实例
     */
    static get instance() {
        if (!BuffManagerC._instance) {
            BuffManagerC._instance = new BuffManagerC();
        }
        return BuffManagerC._instance;
    }
    /**
     * 是否手动的创建buff表现类，如果为false，将使用默认的BuffC基类做为buff表现,且不会抛出onBuffPreCreate， 如果为true,注册回调onBuffPreCreate，该事件会在开始生成buff表现类时抛出，外部可手动调用生成buff函数，可以传递自己的派生Buff类
     */
    manualCreateBuff = false;
    /**
     * 当客户端Buff表现类开始创建时  manualCreateBuff=true时
     */
    _onBuffPreCreate = null;
    get onBuffPreCreate() {
        return this._onBuffPreCreate;
    }
    /**
     * 初始化， 客户端使用BuffManagerC其它功能前需要调用本方法
     * @param staticBuffData  静态buff数据,传入GameConfig.Buff.getAllElement()即可
     * @param _manualPlayEffect 是否手动的播放buff特效，如果为false，将使用Odin的特效管理器进行特效播放，
     *                            如果为true  注册回调_onBuffEffectPreCreate，手动在外部管理自己的特效
     * @param _manualCreateBuff  是否手动的创建buff表现类，如果为false，将使用默认的BuffC基类做为buff表现,且不会抛出onBuffPreCreate，
     *                           如果为true,注册回调onBuffPreCreate，该事件会在开始生成buff表现类时抛出，外部可手动调用生成buff函数，可以传递自己的派生Buff类
     */
    init(staticBuffData, _manualPlayEffect = false, _manualCreateBuff = false) {
        if (mw.SystemUtil.isClient()) {
            super.init(staticBuffData);
            this.manualPlayEffect = _manualPlayEffect;
            this.manualCreateBuff = _manualCreateBuff;
            this._onBuffPreCreate = new mw.Action2();
            //注册一些网络事件
            const net = mwext["GameInitializer"]["getService"]("NetManager");
            net.registerFun(this.net_SpawnBuffInPlayer, this);
            net.registerFun(this.net_SpawnBuffInObject, this);
            net.registerFun(this.net_SpawnBuffInPlace, this);
            net.registerFun(this.net_DestroyBuff, this);
            net.registerFun(this.net_DestroyBuffs, this);
            this.isInit = true;
        }
    }
    /**
     * 销毁
     * 注意如果调用之后，要再次使用BuffManagerC 需要调用 init方法再做初始化
     */
    destroy() {
        super.destroy();
        this._onBuffPreCreate.clear();
        this._onBuffPreCreate = null;
        const net = mwext["GameInitializer"]["getService"]("NetManager");
        //清理一些网络事件
        net.unRegisterFun(this.net_SpawnBuffInPlayer);
        net.unRegisterObj(this.net_SpawnBuffInPlace);
        net.unRegisterObj(this.net_DestroyBuff);
        net.unRegisterObj(this.net_DestroyBuffs);
        this.isInit = false;
        BuffManagerC._instance = null;
    }
    /**
     * 通过buff表现的动态id销毁一个buff表现,前端自主的销毁一些，不等后端通知
     * @param buffId  buff动态id
     */
    removeBuffById(buffId) {
        if (!this.isInit)
            return;
        if (!this.buffsDic.has(buffId))
            return;
        let buff = this.buffsDic.get(buffId);
        super.removeBuff(buff);
    }
    /**
     * 通过buff 动态id销毁一些buff表现,前端自主的销毁一些，不等后端通知
     * @param buffIds  buff动态id
     */
    removeBuffsById(buffIds) {
        if (!this.isInit)
            return;
        buffIds.forEach((buffId) => {
            if (this.buffsDic.has(buffId)) {
                let buff = this.buffsDic.get(buffId);
                super.removeBuff(buff);
            }
        });
    }
    /**
     *  前端自主的销毁一个buff表现，不等后端通知
     * @param buff  BuffC
     */
    removeBuff(buff) {
        if (!this.isInit)
            return;
        if (!this.buffsDic.has(buff.id))
            return;
        super.removeBuff(buff);
    }
    /**
     *  前端自主的销毁一些buff表现，不等后端通知
     * @param buffs  BuffC[]
     */
    removeBuffs(buffs) {
        if (!this.isInit)
            return;
        buffs.forEach((buff) => {
            if (this.buffsDic.has(buff.id)) {
                super.removeBuff(buff);
            }
        });
    }
    /**生成一个buff表现对象
     * @param id buff动态id，由后端分配的
     * @param configId buff静态id
     * @param buffClass buff表现类，默认为BuffC
     * @param args buff表现类的额外想使用的参数
     */
    createBuff(id, configId, buffClass, args = null) {
        if (this.buffsDic.has(id)) {
            console.error("无法重复创建buff表现，buff id： " + id);
            return null;
        }
        let archtypeBuff = this.findStaticBuffById(configId);
        if (!archtypeBuff) {
            console.log("createBuff error,archtypeBuff==null,configId: " + configId);
            return null;
        }
        let buffView = new buffClass(id, archtypeBuff, args);
        this.buffsDic.set(id, buffView);
        buffView.init();
        this.onBuffCreateSuccess(buffView);
        if (this._onBuffCreated) {
            this._onBuffCreated.call(buffView);
        }
        return buffView;
    }
    /**
     * 创建一个到玩家身上的buff表现，不会创建动态id一样的buff ，默认情况是执行后端生成指令，需要手动调用时可外部调用
     * @param id buff动态id，由后端分配的
     * @param configId buff静态id
     * @param playerId 玩家 guid
     * @param buffClass buff表现类，默认为BuffC
     * @param args buff表现类的额外想使用的参数
     * @param slotIndex 绑定到玩家的那个插槽上的
     * @param relativePos 绑定到玩家身上时的相对位置
     * @param relativeRot 绑定到玩家身上时的相对朝向
     * @param scale 缩放
     * @returns 新的buff表现对象
     */
    createBuffInPlayer(id, configId, playerId, buffClass, args = null, slotIndex = null, relativePos = null, relativeRot = null, scale = null) {
        let buffView = this.createBuff(id, configId, buffClass, args);
        if (!buffView)
            return null;
        buffView.hostType = exports.EBuffHostType.Player;
        if (!this.manualPlayEffect) {
            //自动管理，生成特效到玩家身上
            this.playBuffEffectInPlayer(buffView, playerId, slotIndex, relativePos, relativeRot, scale);
        }
        else {
            //抛出，让模块外调用者自行管理
            if (this._onBuffEffectPreCreate) {
                let spawnInPlayerData = {
                    playerId: playerId, id: buffView.id, configId: configId,
                    slotIndex: slotIndex == null ? buffView.mountSlotIndex : slotIndex,
                    lPos: [relativePos.x, relativePos.y, relativePos.z],
                    lRot: [relativeRot.x, relativeRot.y, relativeRot.z],
                    scale: [scale.x, scale.y, scale.z],
                    args: args
                };
                this._onBuffEffectPreCreate.call(spawnInPlayerData, buffView.hostType);
            }
        }
        return buffView;
    }
    /**
     * 创建一个到物体身上的buff表现，不会创建动态id一样的buff ，默认情况是执行后端生成指令，需要手动调用时可外部调用
     * @param id buff动态id，由后端分配的
     * @param configId buff静态id
     * @param objGuid 物体的guid
     * @param buffClass buff表现类，默认为BuffC
     * @param args buff表现类的额外想使用的参数
     * @param relativePos 绑定到物体身上时的相对位置
     * @param relativeRot 绑定到物体身上时的相对朝向
     * @param scale 缩放
     * @returns 新的buff表现对象
     */
    createBuffInGameObject(id, configId, objGuid, buffClass, args = null, relativePos = null, relativeRot = null, scale = null) {
        if (!this.isInit)
            return;
        let buffView = this.createBuff(id, configId, buffClass, args);
        if (!buffView)
            return null;
        buffView.hostType = exports.EBuffHostType.GameObject;
        if (!this.manualPlayEffect) {
            //自动管理，生成特效到物体上
            this.playBuffEffectInGameObject(buffView, objGuid, relativePos, relativeRot, scale);
        }
        else {
            //抛出，让模块外调用者自行管理
            if (this._onBuffEffectPreCreate) {
                let spawnInObjData = {
                    objGuid: objGuid, id: buffView.id, configId: configId,
                    lPos: [relativePos.x, relativePos.y, relativePos.z],
                    lRot: [relativeRot.x, relativeRot.y, relativeRot.z],
                    scale: [scale.x, scale.y, scale.z]
                };
                this._onBuffEffectPreCreate.call(spawnInObjData, buffView.hostType);
            }
        }
        return buffView;
    }
    /**
     * 创建一个到世界位置的buff表现，不会创建动态id一样的buff ，默认情况是执行后端生成指令，需要手动调用时可外部调用
     * @param id buff动态id，由后端分配的
     * @param configId buff静态id
     * @param buffClass buff表现类，默认为BuffC
     * @param args buff表现类的额外想使用的参数
     * @param worldPos 绑定到玩家身上时的相对位置
     * @param worldRot 绑定到玩家身上时的相对朝向
     * @param scale 缩放
     * @returns 新的buff表现对象
     */
    createBuffInPlace(id, configId, buffClass, args = null, worldPos = null, worldRot = null, scale = null) {
        if (!this.isInit)
            return;
        let buffView = this.createBuff(id, configId, buffClass, args);
        if (!buffView)
            return null;
        if (!this.manualPlayEffect) {
            //自动管理，生成特效到世界位置上
            buffView.playEffectInPlace(worldPos, worldRot, scale);
        }
        else {
            //抛出，让模块外调用者自行管理
            if (this._onBuffEffectPreCreate) {
                let spawnInPlaceData = { id: buffView.id, configId: configId, wPos: [worldPos.x, worldPos.y, worldPos.z], wRot: [worldRot.x, worldRot.y, worldRot.z], scale: [scale.x, scale.y, scale.z] };
                this._onBuffEffectPreCreate.call(spawnInPlaceData, buffView.hostType);
            }
        }
        return buffView;
    }
    //#region  for rpc 用于被服务器调用
    /**
     * 在某个玩家身上生成一个buff 网络通信函数
     * @param param BuffSpawnInPlayerData结构
     */
    net_SpawnBuffInPlayer(param) {
        if (!this.isInit)
            return;
        if (this.manualCreateBuff) {
            //抛出开始创建buff表现的事件
            if (this._onBuffPreCreate)
                this._onBuffPreCreate.call(param, exports.EBuffHostType.Player);
        }
        else {
            //自动管理创建buff表现
            this.createBuffInPlayer(param.id, param.configId, param.playerId, BuffC, null, param.slotIndex, new mw.Vector(param.lPos[0], param.lPos[1], param.lPos[2]), new mw.Rotation(param.lRot[0], param.lRot[1], param.lRot[2]), new mw.Vector(param.scale[0], param.scale[1], param.scale[2]));
        }
    }
    /**
     * 在某个物体身上生成一个buff 网络通信函数
     * @param param BuffSpawnInObjData结构
     */
    net_SpawnBuffInObject(param) {
        if (!this.isInit)
            return;
        if (this.manualCreateBuff) {
            //抛出开始创建buff表现的事件
            if (this._onBuffPreCreate)
                this._onBuffPreCreate.call(param, exports.EBuffHostType.GameObject);
        }
        else {
            //自动管理创建buff表现
            this.createBuffInGameObject(param.id, param.configId, param.objGuid, BuffC, null, new mw.Vector(param.lPos[0], param.lPos[1], param.lPos[2]), new mw.Rotation(param.lRot[0], param.lRot[1], param.lRot[2]), new mw.Vector(param.scale[0], param.scale[1], param.scale[2]));
        }
    }
    /**
     * 在世界位置上生成一个buff 网络通信函数
     * @param param BuffSpawnInPlaceData结构
     */
    net_SpawnBuffInPlace(param) {
        if (!this.isInit)
            return;
        if (this.manualCreateBuff) {
            //抛出开始创建buff表现的事件
            if (this._onBuffPreCreate)
                this._onBuffPreCreate.call(param, exports.EBuffHostType.None);
        }
        else {
            //自动管理创建buff表现
            this.createBuffInPlace(param.id, param.configId, BuffC, null, new mw.Vector(param.wPos[0], param.wPos[1], param.wPos[2]), new mw.Rotation(param.wRot[0], param.wRot[1], param.wRot[2]), new mw.Vector(param.scale[0], param.scale[1], param.scale[2]));
        }
    }
    /**
     * 移除一个buff
     * @param buffId  buff动态id
     */
    net_DestroyBuff(buffId) {
        if (!this.isInit)
            return;
        this.removeBuffById(buffId);
    }
    /**
     * 移除一批buff
     * @param  buffIds buff的动态id
     */
    net_DestroyBuffs(buffIds) {
        if (!this.isInit)
            return;
        this.removeBuffsById(buffIds);
    }
}

/**
* @Author       : MengYao.Zhao
* @Date         : 2022/04/13 10:55:21
* @Description  :  服务端 Buff数据 主要包含有时限类buff和触发次数类buff的生命周期和逻辑，如果有自己特殊的buff行为，可以进行继承，生成时指定需要的buff类和参数
*/
class BuffS extends BuffBase {
    /**
     * buff生成时的位置，如果挂载在身物身上时表示为相对位置，在世界位置时是世界位置
     */
    _buffPos = null;
    get buffPos() {
        return this._buffPos == null ? mw.Vector.zero : new mw.Vector(this._buffPos.x, this._buffPos.y, this._buffPos.z);
    }
    set buffPos(value) {
        this._buffPos = value;
    }
    /**
     * buff生成时的朝向，如果挂载在身物身上时表示为相对朝向，在世界位置时是世界朝向
     */
    _buffRot = null;
    get buffRot() {
        return this._buffRot == null ? mw.Rotation.zero : new mw.Rotation(this._buffRot.x, this._buffRot.y, this._buffRot.z);
    }
    set buffRot(value) {
        this._buffRot = value;
    }
    /**
     * buff生成时的缩放
     */
    _buffScale = null;
    get buffScale() {
        return this._buffScale == null ? mw.Vector.one : new mw.Vector(this._buffScale.x, this._buffScale.y, this._buffScale.z);
    }
    set buffScale(value) {
        this._buffScale = value;
    }
    /**
     * 服务端生成buff时的规则
     */
    _buffSpawnRule = exports.EBuffSpawnRule.Client;
    get buffSpawnRule() {
        return this._buffSpawnRule;
    }
    set buffSpawnRule(value) {
        this._buffSpawnRule = value;
    }
    /**
     * 移除时是否已经检查过要通知客户端了
     */
    _checkedNotifyClient = false;
    get checkedNotifyClient() {
        return this._checkedNotifyClient;
    }
    set checkedNotifyClient(value) {
        this._checkedNotifyClient = value;
    }
    /**
     * 已经过去的时间,有时间限制的buff使用
     */
    elapsedTime = 0;
    /**
     * 上次触发时间，有触发次数类型的buff使用
     */
    lastOccurredTime = 0;
    /**
     * 当前触发的次数，有触发次数类型的buff使用
     */
    curOccurredCount = 0;
    /**
     * 当触buff完成初始化后，当帧初时执行时，给外部一个回调
     */
    _onExecute = null;
    get onExecute() {
        return this._onExecute;
    }
    /**
     * 当触发了buff效果时，给外部一个回调
     */
    _onTrigger = null;
    get onTrigger() {
        return this._onTrigger;
    }
    /**
     * 构造服务端buff类数据
     * @param _id 全局id
     * @param staticConfig buff静态表
     */
    constructor(_id, staticConfig) {
        super(_id, staticConfig);
        this.curOccurredCount = 0;
        this.lastOccurredTime = this._triggerInterval;
        this._onExecute = new mw.Action1();
        this._onTrigger = new mw.Action1();
    }
    /**
     * 构造完成之后， 一些初始化行为
     */
    init() {
    }
    /**
     * buff开始执行了
     */
    execute() {
        if (this._onExecute) {
            this._onExecute.call(this);
        }
    }
    /**
     * 帧驱动
     * @param dt  s
     */
    onUpdate(dt) {
        if (this._dead)
            return;
        if (this._buffLifecycleType == exports.EBuffLifecycleType.LimitByTime) {
            //更新时限类型的周期
            this.elapsedTime += dt;
            if (this.elapsedTime >= this._duration) {
                this._dead = true; //时间到就标记其死亡
            }
        }
        else if (this._buffLifecycleType == exports.EBuffLifecycleType.LimitByTriggerCount) {
            //更新触发性类型的周期
            this.lastOccurredTime += dt;
            if (this.lastOccurredTime >= this._triggerInterval) {
                //触发一次
                if (this._onTrigger) {
                    this._onTrigger.call(this);
                }
                this.lastOccurredTime -= this._triggerInterval;
                this.curOccurredCount++;
                if (this.curOccurredCount == this._triggerCount) {
                    //触发完全了 标记其死亡
                    this._dead = true;
                }
            }
        }
    }
    /**
     * 销毁，清理
     */
    destroy() {
        super.destroy();
        if (this._onExecute) {
            this._onExecute.clear();
            this._onExecute = null;
        }
        if (this._onTrigger) {
            this._onTrigger.clear();
            this._onTrigger = null;
        }
    }
    /**
    * 追加buff持续时间
    */
    addBuffTime() {
        this._duration = (this._duration - this.elapsedTime) + this._staticConfig.duration;
    }
    /**
     * 刷新自己的持续时间
     */
    refreshTime() {
        this._duration = this.elapsedTime + this._staticConfig.duration;
    }
}

/**
* @Author       : MengYao.Zhao
* @Date         : 2022/04/13 10:58:32
* @Description  : 服务端管理BuffS的生命期，生成，驱动，销毁，和前端通信生成/销毁 Buff表现
*/
class BuffManagerS extends BuffManager {
    net;
    constructor() {
        super();
        this.net = mwext["GameInitializer"]["getService"]("NetManager");
    }
    static _instance = null;
    /**
     * 单例实例
     */
    static get instance() {
        if (!BuffManagerS._instance) {
            BuffManagerS._instance = new BuffManagerS();
        }
        return BuffManagerS._instance;
    }
    /**
     * buff的动态id基数  用于给buff分配动态id
     */
    buffBaseId = 0;
    /**
     * 当前帧死亡的buff,收集起来统一回收
     */
    deadBuffs;
    /**
     * 当技能对象型(SkillBaseActor)的宿主创建了新buff时的回调,key= SkillBaseActor.guid/
     */
    onHostBuffCreateActions;
    /**
     * 当技能对象型的宿主准备销毁buff时的回调 ,key= SkillBaseActor.guid/
     */
    onHostBuffPreDestroyActions;
    /**
     * 当技能对象型的宿主在buff使用后准备再调用某个技能时回调 ,key= SkillBaseActor.guid/
     */
    onHostBuffPlaySkillActions;
    /**
     * 当buff完成初始化后，开始正式执行后
     */
    _onBuffExecuted = null;
    get onBuffExecuted() {
        return this._onBuffExecuted;
    }
    /**
     * 当buff触发了一次效果时
     */
    _onBuffEffectTrigger = null;
    get onBuffEffectTrigger() {
        return this._onBuffEffectTrigger;
    }
    /**
     * 当子buff开始触发创建时
     */
    _onSubBuffPreCreate = null;
    get onSubBuffPreCreate() {
        return this._onSubBuffPreCreate;
    }
    /**
     * 是否手动创建子buff，如果为false，将使用默认的BuffS类做为buff类，来自动生成子buff，如果为true,注册回调onSubBuffPreCreate，手动在外部进行子buff的创建
     */
    manualCreateSubBuff = false;
    /**
     * 当技能开始触发调用时
     */
    _onSkillTrigger = null;
    get onSkillTrigger() {
        return this._onSkillTrigger;
    }
    /**
     * 是否手动施放调用的技能，如果为false，将调用SkillBaseActor的默认接口cast进行施放，，如果为true  注册回调onSkillTrigger，手动在外部管理技能的施放
     */
    manualPlaySkill = false;
    /**
     * 获取buff的全局id
     * @returns
     */
    getBuffGuid() {
        return this.buffBaseId++;
    }
    /**
     * 初始化， 服务端使用BuffManagerS前需要调用本方法
     * @param staticBuffData  静态buff数据,传入GameConfig.Buff.getAllElement()即可
     * @param _manualPlayEffect 是否手动的播放buff特效，如果为false，将使用Odin的特效管理器进行特效播放，
     *                            如果为true  注册回调_onBuffEffectPreCreate，手动在外部管理自己的特效
     * @param _manualCreateSubBuff  是否手动创建子buff，如果为false，将使用默认的BuffS类做为buff类，来自动生成子buff，
     *                                 如果为true,注册回调onSubBuffPreCreate，手动在外部进行子buff的创建
     * @param _manualPlaySkill  是否手动施放调用的技能，如果为false，将调用SkillBaseActor的默认接口cast进行施放，
     *                                  如果为true  注册回调onSkillTrigger，手动在外部管理技能的施放
     */
    init(staticBuffData, _manualPlayEffect = false, _manualCreateSubBuff = false, _manualPlaySkill = false) {
        if (mw.SystemUtil.isServer()) {
            super.init(staticBuffData);
            mw.TimeUtil.onEnterFrame.add(this.update, this);
            this.buffBaseId = 0;
            this.deadBuffs = [];
            this.onHostBuffCreateActions = new Map();
            this.onHostBuffPreDestroyActions = new Map();
            this.onHostBuffPlaySkillActions = new Map();
            this._onBuffExecuted = new mw.Action1();
            this._onBuffEffectTrigger = new mw.Action1();
            this._onSubBuffPreCreate = new mw.Action1();
            this._onSkillTrigger = new mw.Action1();
            this.manualPlayEffect = _manualPlayEffect;
            this.manualCreateSubBuff = _manualCreateSubBuff;
            this.manualPlaySkill = _manualPlaySkill;
            this.isInit = true;
        }
    }
    /**
     * 帧驱动
     * @param dt s
     */
    update(dt) {
        //收集已经死亡的buff去移除掉
        this.buffsList.forEach((buff) => {
            if (buff.dead)
                this.deadBuffs.push(buff);
        });
        if (this.deadBuffs.length > 0) {
            this.removeBuffs(this.deadBuffs);
            this.deadBuffs.length = 0;
        }
        //驱动存活的buff
        this.buffsList.forEach((buff) => {
            buff.onUpdate(dt);
        });
    }
    /**
     * 销毁 ,想把BuffManagerS 彻底清除
     * 注意如果调用之后，要再次使用BuffManagerS  需要再调用init方法再做初始化 ,且之前如果有的监听情况需要重新去监听,否则可以考虑 调用 clearBuffs();
     */
    destroy() {
        super.destroy();
        mw.TimeUtil.onEnterFrame.remove(this.update, this);
        BuffManagerS._instance = null;
        this.deadBuffs = null;
        this.onHostBuffCreateActions = null;
        this.onHostBuffPreDestroyActions = null;
        this.onHostBuffPlaySkillActions = null;
        this._onBuffExecuted.clear();
        this._onBuffExecuted = null;
        this._onBuffEffectTrigger.clear();
        this._onBuffEffectTrigger = null;
        this._onSubBuffPreCreate.clear();
        this._onSubBuffPreCreate = null;
        this._onSkillTrigger.clear();
        this._onSkillTrigger = null;
    }
    /**
     * 创建buff
     * @param configId  buff配置id
     * @param hostGuid 宿主对象  技能角色SkillBaseActor.guid | mw.GameObject.guid  ==null表示是生成在世界位置上
     * @param buffClass 要生成的buff类
     * @param args 类额外  数组参数
     * @returns buff创建的结果
     */
    createBuff(configId, hostGuid = null, buffClass = BuffS, args) {
        let archtypeBuff = this.findStaticBuffById(configId);
        if (!archtypeBuff) {
            console.log("createBuff error,archtypeBuff==null,configId: " + configId);
            return { buff: null, isNew: false };
        }
        if (hostGuid) {
            let existBuff = null;
            let hostContainer = this.hostBuffsDic.get(hostGuid);
            if (hostContainer) {
                for (let i = 0; i < hostContainer.length; i++) {
                    if (hostContainer[i].configId == configId) {
                        existBuff = hostContainer[i];
                        break;
                    }
                }
            }
            else {
                hostContainer = [];
                this.hostBuffsDic.set(hostGuid, hostContainer);
            }
            if (existBuff) {
                switch (existBuff.buffOverlayType) {
                    case exports.EBuffOverlayType.Only:
                        //独占buff 
                        return { buff: existBuff, isNew: false };
                    case exports.EBuffOverlayType.AddTime:
                        //在原buff上追加一个该buff原本的持续时间周期
                        existBuff.addBuffTime();
                        return { buff: existBuff, isNew: false };
                    case exports.EBuffOverlayType.RefreshTime:
                        //在原buff上新刷新该buff原来的持续时间周期
                        existBuff.refreshTime();
                        return { buff: existBuff, isNew: false };
                }
            }
            //加个全新到宿主身上的
            let id = this.getBuffGuid();
            let buff = new buffClass(id, archtypeBuff, args);
            hostContainer.push(buff);
            buff.hostGuid = hostGuid;
            this.buffsList.push(buff);
            this.buffsDic.set(buff.id, buff);
            this.onBuffCreateSuccess(buff);
            return { buff: buff, isNew: true };
        }
        else { //为空表示该buff是生成在世界位置中的
            //直接创建一个新的buff
            let id = this.getBuffGuid();
            let buff = new buffClass(id, archtypeBuff, args);
            this.buffsList.push(buff);
            this.buffsDic.set(buff.id, buff);
            this.onBuffCreateSuccess(buff);
            return { buff: buff, isNew: true };
        }
    }
    /**
     * 全新buff做初始化
     * @param buff BuffS
     */
    initBuff(buff) {
        buff.init();
        //监听buff的初次执行
        buff.onExecute.add((buff) => {
            this.onBuffExceuted(buff);
        });
        if (buff.buffLifecycleType == exports.EBuffLifecycleType.LimitByTriggerCount) {
            //监听buff效果触发时
            buff.onTrigger.add((buff) => {
                this.doBuffEffectTrigger(buff);
            });
        }
        buff.execute();
    }
    /**
     * 检查buff生成子buff或者使用技能
     * @param buff
     */
    checkSubBuffOrSkill(buff) {
        if (buff.subBuffTriggerOpportunity == exports.EBuffTriggerOpportunity.OnExecute && buff.subBuffIds.length > 0) {
            this.createSubBuff(buff);
        }
        if (buff.skillTriggerOpportunity == exports.EBuffTriggerOpportunity.OnExecute && buff.skillId > 0) {
            this.playSkill(buff);
        }
    }
    /**
     * 当buff初始化完成后，首次开始执行时
     * @param buff
     */
    onBuffExceuted(buff) {
        this.checkSubBuffOrSkill(buff);
        if (this._onBuffExecuted)
            this._onBuffExecuted.call(buff);
    }
    /**
     * 当有效果触发型的buff触发时
     * @param buff
     */
    doBuffEffectTrigger(buff) {
        this.checkSubBuffOrSkill(buff);
        if (this._onBuffEffectTrigger)
            this._onBuffEffectTrigger.call(buff);
    }
    /**
     * 创建子buff
     * @param buff
     */
    createSubBuff(buff) {
        if (!this.manualCreateSubBuff) {
            if (buff.hostGuid) {
                //把子buff创建到该宿主身上相同位置                 
                buff.subBuffIds.forEach((configId) => {
                    if (buff.hostType == exports.EBuffHostType.Player)
                        this.createBuffInPlayer(buff.hostGuid, configId, BuffS, null, buff.buffSpawnRule, buff.mountSlotIndex, buff.buffPos, buff.buffRot, buff.scale);
                    else if (buff.hostType == exports.EBuffHostType.GameObject)
                        this.createBuffInGameObject(buff.hostGuid, configId, BuffS, null, buff.buffSpawnRule, buff.buffPos, buff.buffRot, buff.scale);
                });
            }
            else {
                //创建子buff到主buff的相同位置上
                buff.subBuffIds.forEach((configId) => {
                    this.createBuffInPlace(configId, buff.buffPos, buff.buffRot, buff.scale, BuffS, null, buff.buffSpawnRule);
                });
            }
        }
        else {
            //通知外部调用者去创建
            if (this._onSubBuffPreCreate)
                this._onSubBuffPreCreate.call(buff);
        }
    }
    /**
     * buff释放新的技能
     * @param buff
     */
    playSkill(buff) {
        if (!this.manualPlaySkill && buff.hostGuid) {
            let onPlaySkillAction = this.onHostBuffPlaySkillActions.get(buff.hostGuid);
            if (onPlaySkillAction)
                onPlaySkillAction(buff);
        }
        else {
            //通知外部调用者去释放
            if (this._onSkillTrigger)
                this._onSkillTrigger.call(buff);
        }
    }
    /**
     * 给某个技能角色对象上创建一个buff。如无指定绑定信息，则使用buff配置的绑定信息, 技能角色对象在自己的onDestroy()方法触发时会onPlayerDestroy()清理自己身上的buff
     * @param playerId   SkillBaseActor.guid
     * @param configId  buff的静态配置id
     * @param buffClass 要生成的buff类
     * @param args 类额外  数组参数
     * @param spawnRule Buff生成规则
     * @param slotIndex  玩家对象上的的插槽
     * @param relativePos  相对位置
     * @param relativeRot  相对朝向
     * @param scale  缩放
     * @returns buff对象，需要追加和刷新时间buff可能是原buff
     */
    createBuffInPlayer(playerId, configId, buffClass = BuffS, args = null, spawnRule = exports.EBuffSpawnRule.Client, slotIndex = null, relativePos = null, relativeRot = null, scale = null) {
        if (!this.isInit)
            return;
        let createResult = this.createBuff(configId, playerId, buffClass, args);
        let buff = createResult.buff;
        buff.buffSpawnRule = spawnRule;
        if (createResult.isNew) {
            buff.hostType = exports.EBuffHostType.Player;
            this.initBuff(buff);
        }
        let onCreateAction = this.onHostBuffCreateActions.get(playerId);
        if (onCreateAction)
            onCreateAction(buff);
        if (this._onBuffCreated && createResult.isNew) {
            this._onBuffCreated.call(buff);
        }
        if (createResult.isNew) {
            let lPosArr = relativePos == null ? [buff.relativePos.x, buff.relativePos.y, buff.relativePos.z] : [relativePos.x, relativePos.y, relativePos.z];
            let lRotArr = relativeRot == null ? [buff.relativeRot.x, buff.relativeRot.y, buff.relativeRot.z] : [relativeRot.x, relativeRot.y, relativeRot.z];
            let scaleArr = scale == null ? [buff.scale.x, buff.scale.y, buff.scale.z] : [scale.x, scale.y, scale.z];
            buff.buffPos = new mw.Vector(lPosArr[0], lPosArr[1], lPosArr[2]);
            buff.buffRot = new mw.Rotation(lRotArr[0], lRotArr[1], lRotArr[2]);
            buff.buffScale = new mw.Vector(scaleArr[0], scaleArr[1], scaleArr[2]);
            switch (spawnRule) {
                case exports.EBuffSpawnRule.Client:
                case exports.EBuffSpawnRule.Server:
                    let spawnInPlayerData = {
                        playerId: playerId, id: buff.id, configId: configId,
                        slotIndex: slotIndex == null ? buff.mountSlotIndex : slotIndex,
                        lPos: lPosArr,
                        lRot: lRotArr,
                        scale: scaleArr,
                        args: args[1]
                    };
                    if (spawnRule == exports.EBuffSpawnRule.Client) {
                        //通知客户端去做客户端特效表现等管理
                        this.net.callAllClientFun(exports.buffRpcFun.net_SpawnBuffInPlayer, spawnInPlayerData);
                    }
                    else {
                        //直接考虑在服务端做双端特效等表现管理
                        if (!this.manualPlayEffect) {
                            //进行自动管理
                            console.log("Server BuffManagerS: playBuffEffectInPlayer  slotIndex: ", slotIndex, " ");
                            this.playBuffEffectInPlayer(buff, playerId, spawnInPlayerData.slotIndex, relativePos == null ? buff.relativePos : relativePos, relativeRot == null ? buff.relativeRot : relativeRot, scale == null ? buff.scale : scale);
                        }
                        else {
                            //抛出，让模块外调用者自行管理
                            if (this._onBuffEffectPreCreate)
                                this._onBuffEffectPreCreate.call(spawnInPlayerData, buff.hostType);
                        }
                    }
                    break;
            }
        }
        return buff;
    }
    /**
     * 给某个物体对象上创建一个buff。如无指定绑定信息，则使用buff配置的绑定信息,注意如果物体对象在外部会有销毁行为，在销毁前需要调用onObjectPreDestroy清理自己身上的buff
     * @param objGuid   mw.GameObject.guid
     * @param configId  buff的静态配置id
     * @param buffClass 要生成的buff类
     * @param args 类额外  数组参数
     * @param spawnRule Buff生成规则
     * @param slotIndex  玩家对象上的的插槽
     * @param relativePos  相对位置
     * @param relativeRot  相对朝向
     * @param scale  缩放
     * @returns buff对象，需要追加和刷新时间buff可能是原buff
     */
    createBuffInGameObject(objGuid, configId, buffClass = BuffS, args = null, spawnRule = exports.EBuffSpawnRule.Client, relativePos = null, relativeRot = null, scale = null) {
        if (!this.isInit)
            return;
        let createResult = this.createBuff(configId, objGuid, buffClass, args);
        let buff = createResult.buff;
        buff.buffSpawnRule = spawnRule;
        if (createResult.isNew) {
            buff.hostType = exports.EBuffHostType.GameObject;
            this.initBuff(buff);
        }
        if (this._onBuffCreated && createResult.isNew) {
            this._onBuffCreated.call(buff);
        }
        if (createResult.isNew) {
            let lPosArr = relativePos == null ? [buff.relativePos.x, buff.relativePos.y, buff.relativePos.z] : [relativePos.x, relativePos.y, relativePos.z];
            let lRotArr = relativeRot == null ? [buff.relativeRot.x, buff.relativeRot.y, buff.relativeRot.z] : [relativeRot.x, relativeRot.y, relativeRot.z];
            let scaleArr = scale == null ? [buff.scale.x, buff.scale.y, buff.scale.z] : [scale.x, scale.y, scale.z];
            buff.buffPos = new mw.Vector(lPosArr[0], lPosArr[1], lPosArr[2]);
            buff.buffRot = new mw.Rotation(lRotArr[0], lRotArr[1], lRotArr[2]);
            buff.buffScale = new mw.Vector(scaleArr[0], scaleArr[1], scaleArr[2]);
            switch (spawnRule) {
                case exports.EBuffSpawnRule.Client:
                case exports.EBuffSpawnRule.Server:
                    let spawnInObjData = {
                        objGuid: objGuid, id: buff.id, configId: configId,
                        lPos: lPosArr,
                        lRot: lRotArr,
                        scale: scaleArr
                    };
                    if (spawnRule == exports.EBuffSpawnRule.Client) {
                        //通知客户端去做客户端特效表现等管理
                        this.net.callAllClientFun(exports.buffRpcFun.net_SpawnBuffInObject, spawnInObjData);
                    }
                    else {
                        //直接考虑在服务端做双端特效等表现管理
                        if (!this.manualPlayEffect) {
                            //进行自动管理
                            this.playBuffEffectInGameObject(buff, objGuid, relativePos == null ? buff.relativePos : relativePos, relativeRot == null ? buff.relativeRot : relativeRot, scale == null ? buff.scale : scale);
                        }
                        else {
                            //抛出，让模块外调用者自行管理
                            if (this._onBuffEffectPreCreate)
                                this._onBuffEffectPreCreate.call(spawnInObjData, buff.hostType);
                        }
                    }
                    break;
            }
        }
        return buff;
    }
    /**
     * 在世界位置上创建一个buff
     * @param configId  buff的静态配置id
     * @param worldPos  相对位置
     * @param worldRot  相对朝向
     * @param scale  缩放
     * @param buffClass 要生成的buff类
     * @param args 类额外  数组参数
     * @param spawnRule Buff生成规则
     * @returns buff对象
     */
    createBuffInPlace(configId, worldPos, worldRot, scale, buffClass = BuffS, args = null, spawnRule = exports.EBuffSpawnRule.Client) {
        if (!this.isInit)
            return;
        let createResult = this.createBuff(configId, null, buffClass, args);
        let buff = createResult.buff;
        buff.buffSpawnRule = spawnRule;
        if (createResult.isNew) {
            this.initBuff(buff);
        }
        if (this._onBuffCreated && createResult.isNew) {
            this._onBuffCreated.call(buff);
        }
        if (createResult.isNew) {
            let wPosArr = worldPos == null ? [buff.relativePos.x, buff.relativePos.y, buff.relativePos.z] : [worldPos.x, worldPos.y, worldPos.z];
            let wRotArr = worldRot == null ? [buff.relativeRot.x, buff.relativeRot.y, buff.relativeRot.z] : [worldRot.x, worldRot.y, worldRot.z];
            let scaleArr = scale == null ? [buff.scale.x, buff.scale.y, buff.scale.z] : [scale.x, scale.y, scale.z];
            buff.buffPos = new mw.Vector(wPosArr[0], wPosArr[1], wPosArr[2]);
            buff.buffRot = new mw.Rotation(wRotArr[0], wRotArr[1], wRotArr[2]);
            buff.buffScale = new mw.Vector(scaleArr[0], scaleArr[1], scaleArr[2]);
            switch (spawnRule) {
                case exports.EBuffSpawnRule.Client:
                case exports.EBuffSpawnRule.Server:
                    let spawnInPlaceData = { id: buff.id, configId: configId, wPos: wPosArr, wRot: wRotArr, scale: scaleArr };
                    if (spawnRule == exports.EBuffSpawnRule.Client) {
                        //通知客户端去做客户端特效表现等管理
                        this.net.callAllClientFun(exports.buffRpcFun.net_SpawnBuffInPlace, spawnInPlaceData);
                    }
                    else if (spawnRule == exports.EBuffSpawnRule.Server) {
                        //直接考虑在服务端做双端特效等表现管理
                        if (!this.manualPlayEffect) {
                            //进行自动管理
                            buff.playEffectInPlace(worldPos, worldRot, scale);
                        }
                        else {
                            //抛出，让模块外调用者自行管理
                            if (this._onBuffEffectPreCreate)
                                this._onBuffEffectPreCreate.call(spawnInPlaceData, buff.hostType);
                        }
                    }
                    break;
            }
        }
        return buff;
    }
    /**
     * 设置技能角色类宿主在buff创建时的回调
     * @param playerId  SkillBaseActor.guid
     * @param callBack
     * @returns
     */
    setOnHostBuffCreateAction(playerId, callBack) {
        if (!this.isInit || !this.onHostBuffCreateActions || this.onHostBuffCreateActions.has(playerId))
            return;
        this.onHostBuffCreateActions.set(playerId, callBack);
    }
    /**
     * 设置技能角色类宿主在buff销毁前回调
     * @param playerId  SkillBaseActor.guid
     * @param callBack
     * @returns
     */
    setOnHostBuffPreDestroyAction(playerId, callBack) {
        if (!this.isInit || !this.onHostBuffPreDestroyActions || this.onHostBuffPreDestroyActions.has(playerId))
            return;
        this.onHostBuffPreDestroyActions.set(playerId, callBack);
    }
    /**
     * 设置buff在调用技能时的回调
     * @param playerId  SkillBaseActor.guid
     * @param callBack
     * @returns
     */
    setOnHostBuffPlaySkillAction(playerId, callBack) {
        if (!this.isInit || !this.onHostBuffPlaySkillActions || this.onHostBuffPlaySkillActions.has(playerId))
            return;
        this.onHostBuffPlaySkillActions.set(playerId, callBack);
    }
    /**
     *内部方法, 当玩家销毁了时，需要移除属于该玩家的buff
     * @param playerId SkillBaseActor.guid
     */
    onPlayerDestroy(playerId) {
        if (!this.isInit)
            return;
        let playerContainer = this.hostBuffsDic.get(playerId);
        if (playerContainer) {
            this.hostBuffsDic.delete(playerId);
            this.removeBuffs(playerContainer);
        }
    }
    /**
     * 外部方法，当某个物体销毁时，如果把buff挂在于物体上时，需要在该物体销毁前调用本方法，清除该物体身上的buff
     * @param objGuid buff宿主物体的guid
     */
    onObjectPreDestroy(objGuid) {
        this.onPlayerDestroy(objGuid);
    }
    /**
     * 同时销毁多个buff
     * @param buffIds  buff的动态id列表
     */
    removeBuffsById(buffIds) {
        if (!this.isInit || !buffIds)
            return;
        let notifyIds = [];
        let buffs = [];
        buffIds.forEach((buffId) => {
            let buff = this.buffsDic.get(buffId);
            if (buff) {
                buffs.push(buff);
                if (!buff.checkedNotifyClient && buff.buffSpawnRule == exports.EBuffSpawnRule.Client) {
                    buff.checkedNotifyClient = true;
                    notifyIds.push(buff.id);
                }
            }
        });
        super.removeBuffs(buffs);
        if (notifyIds.length > 0) {
            this.net.callAllClientFun(exports.buffRpcFun.net_DestroyBuffs, notifyIds);
        }
    }
    /**
     * 通过buff的动态id销毁一个buff
     * @param buffId  buff动态id
     */
    removeBuffById(buffId) {
        if (!this.isInit)
            return;
        let buff = this.buffsDic.get(buffId);
        if (!buff)
            return;
        if (!buff.checkedNotifyClient) {
            buff.checkedNotifyClient = true;
            this.net.callAllClientFun(exports.buffRpcFun.net_DestroyBuff, buffId);
        }
        super.removeBuff(buff);
    }
    /**
     * 销毁一批buff
     * @param buffs BuffS[]
     */
    removeBuffs(buffs) {
        let buffIds = [];
        buffs.forEach((buff) => {
            if (!buff.checkedNotifyClient && buff.buffSpawnRule == exports.EBuffSpawnRule.Client) {
                buff.checkedNotifyClient = true;
                buffIds.push(buff.id);
            }
        });
        super.removeBuffs(buffs);
        if (buffIds.length > 0) {
            this.net.callAllClientFun(exports.buffRpcFun.net_DestroyBuffs, buffIds);
        }
    }
    /**
     * 销毁一个buff
     * @param buff
     */
    removeBuff(buff) {
        if (!this.isInit || !buff)
            return;
        if (!buff.checkedNotifyClient && buff.buffSpawnRule == exports.EBuffSpawnRule.Client) {
            buff.checkedNotifyClient = true;
            this.net.callAllClientFun(exports.buffRpcFun.net_DestroyBuff, buff.id);
        }
        super.removeBuff(buff);
    }
    /**
     * 当buff需要移除前，给技能角色对象一个可能的回调
     * @param buff
     */
    onBuffPreRemove(buff) {
        let removeAction = this.onHostBuffPreDestroyActions.get(buff.hostGuid);
        if (removeAction)
            removeAction(buff);
    }
    /**
     * 判断某个玩家是否处于晕眩状态
     * @param playerGuid SkillBaseActor.guid
     */
    isInStunStatus(playerGuid) {
        let stunBuffs = this.findBuffByEffectType(playerGuid, exports.EBuffEffectType.Stun);
        return stunBuffs.length > 0;
    }
}

exports.BuffBase = BuffBase;
exports.BuffC = BuffC;
exports.BuffData = BuffData;
exports.BuffManager = BuffManager;
exports.BuffManagerC = BuffManagerC;
exports.BuffManagerS = BuffManagerS;
exports.BuffS = BuffS;
exports.convertArrayToRotation = convertArrayToRotation;
exports.convertArrayToVector = convertArrayToVector;
//# sourceMappingURL=index.js.map
