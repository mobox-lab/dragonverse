'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**气泡预制体配置 */
const BubblePrefabConfig = {
    /**可视距离 */
    viewDistance: 3000,
    /**字体颜色 */
    textColor: new mw.LinearColor(0.4, 0.4, 0.4, 1),
    /**字体大小 */
    fontSize: 24,
    /**是否显示尾巴 */
    arrayVisible: true,
    /**背景图guid */
    bg: "186746",
    /**背景图颜色 */
    bgColor: new mw.LinearColor(1, 1, 1, 0.4),
    /**边框颜色 */
    borderColor: new mw.LinearColor(0.1, 0.1, 0.1, 0.4),
};
/**气泡模块配置 */
const BubbleModuleConfig = {
    /**可视距离 */
    viewDistance: 3000,
    /**层级 */
    zOrder: -1,
    /**创建气泡UI方法 */
    onCreateBubbleUI: null,
    /**时间 */
    time: 5,
    /**最大数量 */
    maxCount: 5,
    /**偏移 */
    offset: 0,
};

/**
 * 计算状态
 */
class StateMeasure {
    fsm;
    constructor(fsm) {
        this.fsm = fsm;
    }
    /**
     * 退出
     */
    onExit() {
        this.fsm.bubble.isHide = false;
    }
    /**
     * 进入
     */
    onEnter() {
        this.fsm.bubble.isHide = true;
    }
    /**
     * 更新
     * @param dt 帧时长
     */
    update(dt) {
        if (this.fsm.bubble.isSizeValidate) {
            this.fsm.switchState(StateJump);
        }
    }
}
/**
 * 顶开状态
 */
class StateJump {
    fsm;
    /**
     * 延时时间
     */
    _timer;
    constructor(fsm) {
        this.fsm = fsm;
    }
    onExit() {
    }
    onEnter() {
        this._timer = 0;
    }
    update(dt) {
        this._timer += dt * 5;
        if (this._timer >= 1) {
            this._timer = 1;
            this.fsm.switchState(StateExpand);
        }
        this.fsm.bubble.jump(this._timer);
    }
}
/**
 * 展开状态
 */
class StateExpand {
    fsm;
    /**
     * 展开时间
     */
    _timer;
    constructor(fsm) {
        this.fsm = fsm;
    }
    onExit() {
    }
    onEnter() {
        this._timer = 0;
    }
    update(dt) {
        this._timer += dt * 5;
        if (this._timer >= 1) {
            this._timer = 1;
            this.fsm.switchState(StateView);
        }
        this.fsm.bubble.scale(this._timer);
    }
}
/**
 * 显示状态
 */
class StateView {
    fsm;
    /**
     * 展开时间
     */
    _timer;
    constructor(fsm) {
        this.fsm = fsm;
    }
    onExit() {
    }
    onEnter() {
        this._timer = BubbleModuleConfig.time;
    }
    update(dt) {
        this._timer -= dt;
        if (this._timer <= 0) {
            this.fsm.finish();
        }
    }
}
/**气泡状态机 */
class BubbleFsm {
    bubble;
    /**
     * 是否完成
     */
    _isFinish;
    /**
     * 状态列表
     */
    _stateList;
    /**
     * 当前状态
     */
    _currentState;
    /**
     * 下一个状态
     */
    _nextState;
    constructor(bubble) {
        this.bubble = bubble;
        this._stateList = [];
        this._stateList.push(this._currentState = new StateMeasure(this));
        this._stateList.push(new StateExpand(this));
        this._stateList.push(new StateView(this));
        this._stateList.push(new StateJump(this));
        this._currentState.onEnter();
    }
    /**
     * 状态机完成
     */
    finish() {
        this._isFinish = true;
    }
    /**
     * 状态机重置
     */
    reset() {
        this._isFinish = false;
        this._currentState = null;
        this.switchState(StateMeasure);
    }
    /**
     * 更新状态机
     * @param dt
     */
    onUpdate(dt) {
        this._currentState?.update(dt);
        this._doChangeState();
        return this._isFinish;
    }
    /**
     * 调用切换到下一个状态，为了防止状态混乱，仅在update期间调用
     */
    _doChangeState() {
        if (this._nextState) {
            this._currentState?.onExit();
            this._currentState = this._nextState;
            this._currentState.onEnter();
            this._nextState = null;
        }
    }
    /**
     * 切换到下一个状态
     */
    switchState(stateClass) {
        if (this._currentState?.constructor.name != stateClass.name) {
            this._nextState = this._stateList.find(i => i.constructor.name == stateClass.name);
        }
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

const V2 = new mw.Vector2();
const Margin = new mw.Margin(0.5, 0.5, 0.5, 0.5);
/**气泡UI展示逻辑, 包括气泡样式设置, 生命周期,状态机管理 */
class BubbleUI {
    skin;
    /**ui对象 */
    uiObject;
    /**canvas节点 */
    canvas;
    /**背景图节点 */
    bg;
    /**边界图节点 */
    border;
    /**尾巴图节点 */
    tail;
    /**文本节点 */
    textBlock;
    /**气泡状态机 */
    fsm;
    /**大小 */
    size = new mw.Vector2();
    /**当前高度 */
    currentHeight = 0;
    /**
     * 计算回调
     */
    onMeasure;
    /**
     * Y轴偏移
     */
    offset = 0;
    /**世界缩放大小 */
    worldScale = 1;
    /**UI root节点 */
    rootObject;
    constructor(skin) {
        this.skin = skin;
        //气泡UI生成
        if (!BubbleModuleConfig.onCreateBubbleUI) {
            //使用默认UI
            this.canvas = mw.Canvas.newObject();
            this.border = mw.Image.newObject(this.canvas);
            this.border.imageDrawType = mw.SlateBrushDrawType.Box;
            this.border.margin = Margin;
            this.border.imageGuid = BubblePrefabConfig.bg;
            this.border.imageColor = BubblePrefabConfig.borderColor;
            this.tail = mw.Image.newObject(this.canvas);
            this.tail.imageGuid = "37703";
            this.tail.imageColor = BubblePrefabConfig.bgColor;
            this.tail.size = V2.set(40, 23);
            this.tail.renderTransformAngle = 180;
            this.bg = mw.Image.newObject(this.canvas);
            this.bg.imageGuid = BubblePrefabConfig.bg;
            this.bg.imageDrawType = mw.SlateBrushDrawType.Box;
            this.bg.margin = Margin;
            this.bg.imageColor = BubblePrefabConfig.bgColor;
            this.bg.position = V2.set(3, 3);
            this.textBlock = mw.TextBlock.newObject(this.canvas);
            this.textBlock.fontSize = BubblePrefabConfig.fontSize;
            this.textBlock.fontColor = BubblePrefabConfig.textColor;
            this.textBlock.textAlign = mw.TextJustify.Left;
            this.textBlock.position = V2.set(20, 20);
            this.textBlock.textHorizontalLayout = mw.UITextHorizontalLayout.AutoWarpText;
        }
        else {
            //使用自定义UI
            const ui = BubbleModuleConfig.onCreateBubbleUI();
            this.border = ui.border;
            this.tail = ui.array;
            this.bg = ui.bg;
            this.canvas = ui.rootCanvas;
            this.uiObject = ui.uiObject;
            this.textBlock = mw.TextBlock.newObject(this.canvas);
            this.textBlock.fontSize = BubblePrefabConfig.fontSize;
            this.textBlock.fontColor = BubblePrefabConfig.textColor;
            this.textBlock.textAlign = mw.TextJustify.Left;
            this.textBlock.position = V2.set(20, 20);
            this.textBlock.textHorizontalLayout = mw.UITextHorizontalLayout.AutoWarpText;
            this.bg.position = V2.set(3, 3);
            this.border.position = V2.set(0, 0);
            this.textBlock.position = V2.set(20, 20);
            //气泡皮肤设置
            if (skin) {
                this.tail.visibility = skin.arrayVisible ? mw.SlateVisibility.HitTestInvisible : mw.SlateVisibility.Collapsed;
                this.bg.imageGuid = skin.bg;
                this.bg.imageColor = skin.bgColor;
                this.tail.imageColor = skin.bgColor;
                this.border.imageGuid = skin.border;
                this.border.imageColor = skin.borderColor;
                this.textBlock.fontSize = skin.fontSize;
                this.textBlock.fontColor = skin.textColor;
            }
        }
        this.rootObject = this.uiObject ? this.uiObject : this.canvas;
        this.fsm = new BubbleFsm(this);
    }
    /**
    *设置索引，索引大于0的隐藏小尾巴
    */
    setIndex(index) {
        if (index > 0) {
            this.tail.visible && (this.tail.visibility = mw.SlateVisibility.Collapsed);
        }
    }
    /**
     * 销毁
     */
    destory() {
        this.offset = 0;
        this.worldScale = 1;
        this.textBlock.text = "";
        this.rootObject.removeObject();
        this.fsm.reset();
    }
    /**
     * 设置文本信息
     * @param msg  文本信息
     */
    invalidate(msg) {
        this.tail.visibility = mw.SlateVisibility.HitTestInvisible;
        this.textBlock.desiredSize.y = 0;
        this.textBlock.size = V2.set(350, 0);
        this.textBlock.text = msg;
    }
    /**
     * 是否隐藏
     */
    set isHide(isHide) {
        if (isHide) {
            this.rootObject.renderScale = V2.set(0, 0);
        }
    }
    /**
     * 更新
     * @param playerLocation 玩家位置
     * @param position 位置
     * @param dt 时间
     */
    onUpdate(playerLocation, position, dt) {
        this.worldScale = MathUtil.clamp(1000 / mw.Vector.distance(position, playerLocation), 0.5, 1);
        ScreenUtil.projectWorldPositionToWidgetPosition(mw.Player.localPlayer, position, V2, false);
        V2.x -= this.rootObject.size.x / 2;
        V2.y -= this.offset * this.worldScale + 30 + BubbleModuleConfig.offset;
        this.rootObject.position = V2;
        return this.fsm.onUpdate(dt);
    }
    /**
     * 是否可以显示
     */
    get isSizeValidate() {
        if (!this.rootObject.parent) {
            UIService.canvas?.addChild(this.rootObject);
            this.rootObject.zOrder = BubbleModuleConfig.zOrder;
        }
        else {
            if (this.textBlock.desiredSize.y > 0 && this.textBlock.desiredSize.x <= 350) {
                this.size.set(this.textBlock.desiredSize.x + 40, this.textBlock.desiredSize.y + 40);
                this.uiObject && (this.uiObject.size = this.size);
                this.canvas.size = this.size;
                this.border.size = this.size;
                this.bg.size = V2.set(this.size.x - 6, this.size.y - 6);
                this.tail.position = V2.set(this.size.x / 2 - 20, this.size.y);
                this.textBlock.size = V2.set(this.size.x - 30, this.size.y - 40);
                return true;
            }
        }
        return false;
    }
    /**
     * 设置缩放
     */
    scale(scale) {
        V2.x = Math.min(1, scale * 3);
        V2.y = scale;
        this.rootObject.renderScale = V2.multiply(this.worldScale);
    }
    /**
     * 跳出来
     * @param scale
     */
    jump(scale) {
        this.currentHeight = scale * this.size.y;
        this.onMeasure();
    }
}

/**宿主身上的气泡管理 */
class BubbleUser {
    guid;
    /**所有的气泡 */
    bubbles = [];
    /**碰撞高度 */
    collisionHeight = 0;
    /**宿主对象 */
    owner;
    constructor(guid) {
        this.guid = guid;
        mw.GameObject.asyncFindGameObjectById(guid).then(go => {
            this.owner = go;
            if (go instanceof mw.Character) {
                this.collisionHeight = go.collisionExtent.z / 2 * go.worldTransform.scale.z;
            }
        });
    }
    /**
     * 添加气泡
     * @param bubble 气泡UI
     */
    addBubble(bubble) {
        bubble.onMeasure = this.onMeasure;
        this.bubbles.push(bubble);
    }
    /**
     * 气泡更新
     * @param playerLocation 玩家位置
     * @param dt 帧时长
     * @returns 气泡UI
     */
    onUpdate(playerLocation, dt) {
        if (!this.owner)
            return null;
        const loc = this.owner.isReady ? this.owner.worldTransform.position : Vector.zero;
        loc.z += this.collisionHeight;
        for (let i = 0; i < this.bubbles.length; i++) {
            if (this.bubbles.length - i > BubbleModuleConfig.maxCount || !this.owner.isReady || this.bubbles[i].onUpdate(playerLocation, loc, dt)) {
                const bubble = this.bubbles[i];
                bubble.destory();
                this.bubbles.splice(i, 1);
                return bubble;
            }
        }
        return null;
    }
    /**
     * 清理所有气泡
     */
    clear() {
        for (let i = 0; i < this.bubbles.length; i++) {
            this.bubbles[i].destory();
        }
        this.bubbles.length = 0;
    }
    /**
     * 是否完成
     */
    get isFinish() {
        return this.bubbles.length == 0;
    }
    /**重新定位 */
    onMeasure = () => {
        let offset = 0;
        for (let i = this.bubbles.length - 1; i >= 0; i--) {
            offset += this.bubbles[i].currentHeight;
            this.bubbles[i].offset = offset;
            this.bubbles[i].setIndex(this.bubbles.length - i - 1);
            offset += 5;
        }
    };
}

exports.UIX = void 0;
(function (UIX) {
    /**
     * 缓存的气泡
     */
    const cache = [];
    /**
     * 正在显示的气泡
     */
    const users = [];
    /**
     * 更新气泡
     * @param dt 帧时长
     */
    function onUpdate(dt) {
        if (!UIX.character)
            return;
        for (let i = 0; i < users.length; i++) {
            const bubbleUI = users[i].onUpdate(UIX.character.worldTransform.position, dt);
            if (bubbleUI) {
                cache.push(bubbleUI);
                if (users[i].isFinish) {
                    users.splice(i, 1);
                    i--;
                }
            }
        }
    }
    UIX.onUpdate = onUpdate;
    /**
     * 清理气泡宿主
     * @param gameObjectId 物体guid
     */
    function clear(gameObjectId) {
        const user = users.find(u => u.guid == gameObjectId);
        if (user) {
            user.clear();
        }
    }
    UIX.clear = clear;
    /**
     * 显示气泡
     * @param sender  发送者
     * @param msg  消息
     * @param skin  气泡皮肤
     */
    function showBubble(sender, msg, skin) {
        let bubble = null;
        if (!skin) {
            bubble = cache.pop() || new BubbleUI();
        }
        else {
            const bubbleIndex = cache.findIndex(b => b.skin == skin); //从缓存中找对应皮肤的气泡
            if (bubbleIndex >= 0) {
                bubble = cache.splice(bubbleIndex, 1)[0];
            }
            else {
                bubble = new BubbleUI(skin);
            }
        }
        bubble.invalidate(msg);
        let user = users.find(u => u.guid == sender);
        if (!user) {
            user = new BubbleUser(sender);
            users.push(user);
        }
        user.addBubble(bubble);
    }
    UIX.showBubble = showBubble;
})(exports.UIX || (exports.UIX = {}));

let BubbleSkin = class BubbleSkin {
    id = 0;
    fontSize = 24;
    bg = "136288";
    border = "136288";
    textColor = new mw.LinearColor(0.05, 0.05, 0.05, 1);
    bgColor = new mw.LinearColor(1, 1, 1, 0.6);
    borderColor = new mw.LinearColor(0.05, 0.05, 0.05, 0.2);
    arrayVisible = true;
};
__decorate([
    mw.Property({ displayName: "配置ID" })
], BubbleSkin.prototype, "id", void 0);
__decorate([
    mw.Property({ displayName: "文字大小" })
], BubbleSkin.prototype, "fontSize", void 0);
__decorate([
    mw.Property({ displayName: "背景图片" })
], BubbleSkin.prototype, "bg", void 0);
__decorate([
    mw.Property({ displayName: "边框图片" })
], BubbleSkin.prototype, "border", void 0);
__decorate([
    mw.Property({ displayName: "文字颜色" })
], BubbleSkin.prototype, "textColor", void 0);
__decorate([
    mw.Property({ displayName: "背景颜色" })
], BubbleSkin.prototype, "bgColor", void 0);
__decorate([
    mw.Property({ displayName: "边框颜色" })
], BubbleSkin.prototype, "borderColor", void 0);
__decorate([
    mw.Property({ displayName: "显示尾巴" })
], BubbleSkin.prototype, "arrayVisible", void 0);
BubbleSkin = __decorate([
    Serializable
], BubbleSkin);
exports.Bubble = void 0;
(function (Bubble) {
    /**
     * 展示气泡，双端可用
     * @param skinId 气泡外观配置，为0时根据说话者选择默认配置
     * @param text 文本
     * @param guid 说话者的GUID，可以为场景物体,服务端必传，客户端不传为主控者说话
     * @param isLocally true仅在本地显示 false所以端显示
     */
    function showBubble(skinId, text, guid, isLocally) {
        Bubble._proxy && Bubble._proxy.showBubble(skinId, text, guid, isLocally);
    }
    Bubble.showBubble = showBubble;
    /**
    * 关闭所属物体气泡，双端可用
    * @param guid 说话者的GUID，可以为场景物体,服务端必传，客户端不传为主控者
    * @param isLocally true仅在本地关闭 false所以端关闭
    */
    function closeBubble(guid, isLocally) {
        Bubble._proxy && Bubble._proxy.closeBubble(guid, isLocally);
    }
    Bubble.closeBubble = closeBubble;
})(exports.Bubble || (exports.Bubble = {}));
class BubbleProxy extends mw.Script {
    viewDistance = 3000;
    playerSkinId = 0;
    otherSkinId = 0;
    time = 5;
    maxCount = 5;
    offset = 0;
    zOrder = -1;
    skins = [new BubbleSkin()];
    /**本机玩家 */
    player;
    /** 当脚本被实例后，会在第一帧更新前调用此函数 */
    onStart() {
        exports.Bubble._proxy = this;
        if (SystemUtil.isClient()) {
            for (const key in BubbleModuleConfig) {
                if (this.hasOwnProperty(key)) {
                    BubbleModuleConfig[key] = this[key];
                }
            }
            BubbleModuleConfig.onCreateBubbleUI = this.onCreateBubbleUI;
            mw.Player.asyncGetLocalPlayer().then(player => {
                this.player = player;
                exports.UIX.character = player.character;
                this.useUpdate = true;
            });
            mw.Player.onPlayerLeave.add(player => {
                player.character && exports.UIX.clear(player.character.gameObjectId);
            });
        }
    }
    /**
     * 显示气泡
     * @param skinId
     * @param text
     * @param player
     */
    showBubble(skinId, text, guid, isLocally) {
        if (SystemUtil.isClient()) {
            if (!guid) {
                this.player && (isLocally ? this.boardCastBubble(this.player.character.gameObjectId, skinId, text) : this.serverShowBubble(this.player.character.gameObjectId, skinId, text));
            }
            else {
                isLocally ? this.boardCastBubble(guid, skinId, text) : this.serverShowBubble(guid, skinId, text);
            }
        }
        else {
            this.serverShowBubble(guid, skinId, text);
        }
    }
    /**
     * 中转调用关闭气泡
     * @param guid
     */
    boradcastCloseBubble(guid) {
        exports.UIX.clear(guid);
    }
    /**
     * 关闭气泡
     * @param guid
     */
    closeBubble(guid, isLocally) {
        if (SystemUtil.isClient()) {
            if (isLocally) {
                if (!guid) {
                    this.player && this.boradcastCloseBubble(this.player.character.gameObjectId);
                }
                else {
                    this.boradcastCloseBubble(guid);
                }
            }
            else {
                if (!guid) {
                    this.player && this.serverCloseBubble(this.player.character.gameObjectId);
                }
                else {
                    this.serverCloseBubble(guid);
                }
            }
        }
        else {
            this.serverCloseBubble(guid);
        }
    }
    /**
     * 中转调用全局显示气泡
     * @param guid
     * @param skinId
     * @param text
     */
    serverShowBubble(guid, skinId, text) {
        this.boardCastBubble(guid, skinId, text);
    }
    /**
     * 服务端调用所有客户端关闭气泡
     * @param guid
     */
    serverCloseBubble(guid) {
        this.boradcastCloseBubble(guid);
    }
    /**
     * 所有客户端显示气泡
     * @param guid 发送者
     * @param skinId 气泡皮肤
     * @param text 气泡文本
     */
    boardCastBubble(guid, skinId, text) {
        if (this.viewDistance > 0 && this.player) {
            const obj = mw.GameObject.findGameObjectById(guid);
            if (!obj)
                return;
            const squareDistance = mw.Vector2.squaredDistance(this.player.character.worldTransform.position, obj.worldTransform.position);
            if (squareDistance >= this.viewDistance * this.viewDistance) {
                //距离超出，不显示
                return;
            }
        }
        if (!skinId) {
            //自动选择使用者ID
            skinId = this.player ? (this.player.character.gameObjectId == guid ? this.playerSkinId : this.otherSkinId) : this.otherSkinId;
        }
        const skin = this.skins.find(i => i.id == skinId) || this.skins[0];
        exports.UIX.showBubble(guid, text, skin);
    }
    /**
     * 周期函数 每帧执行
     * 此函数执行需要将this.useUpdate赋值为true
     * @param dt 当前帧与上一帧的延迟 / 秒
     */
    onUpdate(dt) {
        exports.UIX.onUpdate(dt);
    }
    /**
     * 脚本被销毁时最后一帧执行完调用此函数
     */
    onDestroy() {
    }
}
__decorate([
    mw.Property({ displayName: "最大显示距离(0-无限远)", group: "配置" })
], BubbleProxy.prototype, "viewDistance", void 0);
__decorate([
    mw.Property({ displayName: "自己气泡", group: "配置" })
], BubbleProxy.prototype, "playerSkinId", void 0);
__decorate([
    mw.Property({ displayName: "他人气泡", group: "配置" })
], BubbleProxy.prototype, "otherSkinId", void 0);
__decorate([
    mw.Property({ displayName: "存在时间", group: "配置" })
], BubbleProxy.prototype, "time", void 0);
__decorate([
    mw.Property({ displayName: "最大数量", group: "配置" })
], BubbleProxy.prototype, "maxCount", void 0);
__decorate([
    mw.Property({ displayName: "头顶偏移", group: "配置" })
], BubbleProxy.prototype, "offset", void 0);
__decorate([
    mw.Property({ displayName: "ZOrder", group: "配置" })
], BubbleProxy.prototype, "zOrder", void 0);
__decorate([
    mw.Property({ displayName: "气泡配置", arrayDefault: new BubbleSkin() })
], BubbleProxy.prototype, "skins", void 0);
__decorate([
    RemoteFunction(mw.Client, mw.Multicast)
], BubbleProxy.prototype, "boradcastCloseBubble", null);
__decorate([
    RemoteFunction(mw.Server)
], BubbleProxy.prototype, "serverShowBubble", null);
__decorate([
    RemoteFunction(mw.Server)
], BubbleProxy.prototype, "serverCloseBubble", null);
__decorate([
    RemoteFunction(mw.Client, mw.Multicast)
], BubbleProxy.prototype, "boardCastBubble", null);

exports.BubbleFsm = BubbleFsm;
exports.BubbleModuleConfig = BubbleModuleConfig;
exports.BubblePrefabConfig = BubblePrefabConfig;
exports.BubbleProxy = BubbleProxy;
exports.BubbleUI = BubbleUI;
exports.BubbleUser = BubbleUser;
//# sourceMappingURL=index.js.map
