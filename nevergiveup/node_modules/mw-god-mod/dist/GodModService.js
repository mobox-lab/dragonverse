import { GodModPanel } from './ui/GodModPanel.js';
import Gtk, { Singleton, Regulator, GtkTypes } from 'gtoolkit';
import Log4Ts from 'mw-log4ts';
import { GodCommandItem } from './GodCommandItem.js';
export { RangeDataValidator } from './GodModParam.js';
export { GodModParamInputBase } from './ui/param-base/GodModParamInputBase.js';
export { ParamInputSizeY, ParamInputZOrder } from './ui/param-base/IGodModParamInput.js';
import './ui/param-input/GodModEnumParamInput.js';
import './ui/param-input/GodModGameConfigParamInput.js';
import './ui/param-input/GodModIntegerParamInput.js';
import './ui/param-input/GodModNumberParamInput.js';
import './ui/param-input/GodModRotationParamInput.js';
import './ui/param-input/GodModStringParamInput.js';
import './ui/param-input/GodModVectorParamInput.js';
import './ui/param-input/GodModVector2ParamInput.js';
import './ui/param-renderer/GodModGameConfigRenderer.js';
export { ExpandIcon } from './ui/icon/ExpandIcon.js';
export { MoveIcon } from './ui/icon/MoveIcon.js';

/**
 * God Mod 服务.
 *
 * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
 * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
 * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
 * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
 * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
 * @author LviatYi
 * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
 * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
 */
class GodModService extends Singleton() {
    constructor() {
        super(...arguments);
        //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
        this._queriedAdminList = false;
        /**
         * GodCommands 库.
         * @type {Map<string, GodCommandItem<unknown>>}
         * @private
         */
        this._commands = new Map();
        /**
         * 管理员列表.
         * @type {Set<string>}
         * @private
         */
        this._adminList = undefined;
        this._shutdown = false;
        this._checkAuthorityRegulator = new Regulator(GtkTypes.Interval.PerMin * 5);
        this._authStrategy = "weak";
    }
    onConstruct() {
        if (mw.SystemUtil.isClient()) {
            mw.Event.addServerListener(GodModService.GodModCommandRunResultInServerEventName, (event) => {
                const e = event;
                if (this._currentFrontFocus === e.label) {
                    this.showUiResult(e.result);
                }
            });
        }
        if (mw.SystemUtil.isServer()) {
            mw.TimeUtil.onEnterFrame.add(() => {
                if (this._checkAuthorityRegulator.request()) {
                    this.queryAdminList();
                }
            });
            mw.Event.addClientListener(GodModService.GodModQueryAuthorityReqEventName, player => {
                mw.Event.dispatchToClient(player, GodModService.GodModQueryAuthorityRespEventName, this.verifyAuthority(player.userId));
            });
        }
        registerCommonCommands();
    }
    addCommand(label, paramType = "string", clientCmd = undefined, serverCmd = undefined, paramOption = undefined, group) {
        if (this._shutdown)
            return;
        if (this._commands.get(label)) {
            Log4Ts.error(GodModService, `A command with the same label already exists.`, label);
        }
        else {
            this._commands.set(label, new GodCommandItem(label, paramType, clientCmd, serverCmd, paramOption, group));
            if (mw.SystemUtil.isServer()) {
                mw.Event.addClientListener(this.getEventName(label), (player, p) => {
                    this.runCommandInServer(player, label, p);
                });
            }
        }
        return this.refreshGm();
    }
    removeCommand(label) {
        this._commands.delete(label);
        return this;
    }
    getAllCommands() {
        return [...this._commands.values()];
    }
    runCommandInClient(label, p, autoDispatchToServer = true) {
        if (this._shutdown || !mw.SystemUtil.isClient())
            return;
        const command = this._commands.get(label);
        if (!command || !command.isParamValid(p))
            return;
        this._currentFrontFocus = label;
        Log4Ts.log(GodModService, `run command in client.`, `command: ${this._currentFrontFocus}`);
        let result;
        if (command.isClientCmd) {
            try {
                if (typeof command.paramType === "object" &&
                    Gtk.is(command.paramType, "getElement")) {
                    let config = command.paramType.getElement(p);
                    result = command.clientCmd(config);
                }
                else {
                    result = command.clientCmd(p);
                }
            }
            catch (e) {
                Log4Ts.error(GodModService, `error occurs in client command.`, e);
            }
        }
        if (command.serverCmd && autoDispatchToServer) {
            mw.Event.dispatchToServer(this.getEventName(command.label), p);
        }
        else {
            this.showUiResult(typeof result === "string" ?
                result :
                result !== false);
        }
    }
    runCommandInServer(player, label, p) {
        if (this._shutdown || !mw.SystemUtil.isServer())
            return;
        if (!this.verifyAuthority(player.userId)) {
            Log4Ts.warn(GodModService, `User has no authority.`, `NickName: ${player.nickname}`, `User: ${player.userId}`);
            mw.Event.dispatchToLocal(GodModService.GodModUnauthorizedCallEventName, {
                userId: player.userId,
                cmdLabel: label,
            });
            return;
        }
        const command = this._commands.get(label);
        if (!command || !command.isParamValid(p))
            return;
        Log4Ts.log(GodModService, `run command in server.`, `command: ${label}`, `by user: ${player.userId}`);
        let r;
        if (command.isServerCmd) {
            try {
                if (typeof command.paramType === "object" &&
                    Gtk.is(command.paramType, "getElement")) {
                    let config = command.paramType.getElement(p);
                    r = command.serverCmd(player, config);
                }
                else {
                    r = command.serverCmd(player, p);
                }
                mw.Event.dispatchToClient(player, GodModService.GodModCommandRunResultInServerEventName, {
                    label: label,
                    result: typeof r == "string" ? r : r !== false,
                });
            }
            catch (e) {
                Log4Ts.error(GodModService, `error occurs in server command.`, e);
                mw.Event.dispatchToClient(player, GodModService.GodModCommandRunResultInServerEventName, { label: label, result: false });
            }
        }
    }
    /**
     * 显示 God Mod 面板.
     */
    showGm() {
        if (mw.SystemUtil.isClient()) {
            if (!this._view) {
                this._view = GodModPanel
                    .create({
                    items: Array.from(this._commands.values()),
                    zOrder: 650000,
                })
                    .attach(mw.UIService.canvas)
                    .registerCommandHandler((label, p, autoDispatchToServer) => {
                    this.runCommandInClient(label, p, autoDispatchToServer);
                });
                Gtk.setUiPositionY(this._view.root, 100);
            }
            else {
                this._view.attach(mw.UIService.canvas);
            }
        }
        return this;
    }
    /**
     * 刷新 God Mod 面板.
     */
    refreshGm() {
        if (mw.SystemUtil.isClient())
            this._view?.refreshCmdItems(Array.from(this._commands.values()));
        return this;
    }
    /**
     * 隐藏 God Mod 面板.
     */
    hideGm() {
        if (mw.SystemUtil.isClient()) {
            this._view?.detach();
        }
        return this;
    }
    /**
     * 带权限验证地 显示 God Mod 面板.
     * @desc 使用服务器的 权限认证策略.
     * @desc 当 PIE 环境时 无论如何将直接显示.
     */
    authShowGm() {
        if (mw.SystemUtil.isPIE)
            this.showGm();
        if (mw.SystemUtil.isClient()) {
            this.hasAuthority()
                .then(value => {
                if (value)
                    this.showGm();
                else
                    this.hideGm();
            });
        }
        return this;
    }
    /**
     * 关闭 God Mod 服务.
     * @desc 执行后不再生效.
     */
    shutdown() {
        this._shutdown = true;
        this._commands.clear();
        return this;
    }
    /**
     * 设置服务器 权限验证策略.
     * @param {AuthStrategy} strategy
     *  - "strong" 强权限验证.
     *    仅手动添加到管理员列表的用户可使用.
     *  - "weak" 弱权限验证.
     *    若不存在管理员列表则所有用户可使用.
     *    否则仅手动添加到管理员列表的用户可使用.
     * @return {this}
     */
    setAuthStrategy(strategy) {
        this._authStrategy = strategy;
        return this;
    }
    //#region UI Config
    /**
     * 设置 GodMod 面板 zOrder.
     * @param {number} zOrder
     * @return {this}
     */
    setZOrder(zOrder) {
        if (this._view && this._view.root) {
            this._view.root.zOrder = zOrder;
        }
        return this;
    }
    /**
     * 设置 GodMod 面板 位置.
     * @param {number} x
     * @param {number} y
     * @return {this}
     */
    setPosition(x, y) {
        if (this._view && this._view.root) {
            Gtk.setUiPosition(this._view.root, x, y);
        }
        return this;
    }
    //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
    /**
     * 为所有 GameConfig 添加预览命令.
     * @param {object} gameConfig 传入 GameConfig.
     * @return {this}
     */
    addPreviewForGameConfig(gameConfig) {
        if (!mw.SystemUtil.isClient())
            return this;
        Object.getOwnPropertyNames(gameConfig)
            ?.forEach(property => {
            const descriptor = Object.getOwnPropertyDescriptor(gameConfig, property);
            if (descriptor && typeof descriptor.get === "function") {
                const configBase = gameConfig[property];
                if ("getElement" in configBase) {
                    addGMCommand(`预览配置 ${property} | G`, configBase, undefined, undefined, { label: "Config Id" }, "GodMod");
                }
            }
        });
        return this;
    }
    /**
     * 是否 具有权限.
     * @desc 仅服务端.
     * @param {string} userId
     * @return {boolean}
     * @private
     */
    verifyAuthority(userId) {
        switch (this._authStrategy) {
            case "weak":
                return this.verifyWeakAuthority(userId);
            case "strong":
            default:
                return this.verifyStrongAuthority(userId);
        }
    }
    /**
     * 是否 具有弱认证权限.
     * @desc 仅服务端.
     * @param {string} userId
     * @return {boolean}
     * @private
     */
    verifyWeakAuthority(userId) {
        return mw.SystemUtil.isPIE ||
            this._adminList === undefined ||
            (this._adminList && this._adminList.has(userId));
    }
    /**
     * 是否 具有强认证权限.
     * @desc 仅服务端.
     * @param {string} userId
     * @return {boolean}
     * @private
     */
    verifyStrongAuthority(userId) {
        return this._adminList?.has(userId) ?? false;
    }
    /**
     * 是否 自身具有认证权限.
     * @desc 仅客户端.
     * @desc 需服务器手动加入后生效.
     * @return {Promise<boolean>}
     */
    async hasAuthority() {
        if (!mw.SystemUtil.isClient())
            return false;
        return new Promise((resolve, reject) => {
            const listener = mw.Event.addServerListener(GodModService.GodModQueryAuthorityRespEventName, (result) => {
                listener.disconnect();
                resolve(result);
            });
            mw.setTimeout(() => {
                listener.disconnect();
                reject();
            }, GtkTypes.Interval.PerSec * 3);
            mw.Event.dispatchToServer(GodModService.GodModQueryAuthorityReqEventName);
        });
    }
    /**
     * 查询管理员列表.
     */
    queryAdminList() {
        mw.DataStorage
            ?.asyncGetData(GodModService.GodModAdminListStorageKey)
            ?.then(result => {
            if (this._queriedAdminList)
                return;
            switch (result.code) {
                case mw.DataStorageResultCode.Success:
                    if (Gtk.isNullOrEmpty(result.data)) {
                        mw.DataStorage.asyncSetData(GodModService.GodModAdminListStorageKey, [GodModService.GodModDefaultAdmin]);
                    }
                    else {
                        let set = new Set();
                        for (const d of result.data) {
                            if (d !== GodModService.GodModDefaultAdmin)
                                set.add(d);
                        }
                        if (set.size > 0) {
                            this._adminList = set;
                        }
                        else {
                            this._adminList = undefined;
                        }
                    }
                    break;
            }
            this._queriedAdminList = true;
        });
    }
    ;
    /**
     * 获取填充类型名.
     * @param {string} label
     * @return {string}
     * @private
     */
    getEventName(label) {
        return GodModService.GodModRunRequestEventNamePrefix + label;
    }
    /**
     * 显示执行反馈结果。
     * @param {boolean} result
     * @private
     */
    showUiResult(result) {
        if (typeof result === "string") {
            this._view?.showTips(result);
        }
        else {
            if (result)
                this._view?.showSuccess();
            else
                this._view?.showError();
        }
    }
}
//#region Constant
/**
 * 管理员列表存储键.
 */
GodModService.GodModAdminListStorageKey = "GOD_MOD_ADMIN_LIST__STORAGE_KEY";
/**
 * 缺省 管理员 UserId.
 */
GodModService.GodModDefaultAdmin = "ADMIN_USER_ID";
/**
 * God Mod 请求运行 事件名前缀.
 */
GodModService.GodModRunRequestEventNamePrefix = "__GOD_MOD_RUN_REQUEST_EVENT_NAME__";
/**
 * God Mod 命令于服务端运行完成 事件名.
 */
GodModService.GodModCommandRunResultInServerEventName = "__GOD_MOD_COMMAND_RUN_RESULT_IN_SERVER_EVENT_NAME__";
/**
 * God Mod 查询权限请求 事件名.
 */
GodModService.GodModQueryAuthorityReqEventName = "__GOD_MOD_QUERY_AUTHORITY_REQ_EVENT_NAME__";
/**
 * God Mod 查询权限回应 事件名.
 */
GodModService.GodModQueryAuthorityRespEventName = "__GOD_MOD_QUERY_AUTHORITY_RESP_EVENT_NAME__";
/**
 * God Mod 未授权调用 事件名.
 * event {@link GodModUnauthorizedCallEventArgs}
 * @desc 仅服务器.
 */
GodModService.GodModUnauthorizedCallEventName = "__GOD_MOD_UNAUTHORIZED_CALL_EVENT_NAME__";
function addGMCommand(label, paramType, clientCmd = undefined, serverCmd = undefined, paramOption = undefined, group) {
    GodModService.getInstance().addCommand(label, paramType, clientCmd, serverCmd, paramOption, group);
}
//#region Common Command Item
function registerCommonCommands() {
    addGMCommand("所有玩家信息 | G", "void", showAllPlayer, showAllPlayer, undefined, "GodMod");
    addGMCommand("传送 | G", "vector", undefined, (player, params) => {
        player.character.worldTransform.position = params;
    }, undefined, "GodMod");
    addGMCommand("传送至我 | G", "string", undefined, (player, params) => {
        const target = mw.Player.getPlayer(params);
        if (!target) {
            Log4Ts.error(GodModService, `Player not exist. userid: ${params}`);
            throw Error();
        }
        target.character.worldTransform.position = player.character.worldTransform.position.clone();
    }, {
        label: "UserId",
        validator: [{
                reason: "用户不存在",
                validator: (param) => !!mw.Player.getPlayer(param),
            }],
    }, "GodMod");
    addGMCommand("传送至 Ta | G", "string", undefined, (player, params) => {
        const target = mw.Player.getPlayer(params);
        if (!target) {
            Log4Ts.error(GodModService, `Player not exist. userid: ${params}`);
            throw Error();
        }
        player.character.worldTransform.position = target.character.worldTransform.position.clone();
    }, {
        label: "UserId",
        validator: [{
                reason: "用户不存在",
                validator: (param) => !!mw.Player.getPlayer(param),
            }],
    }, "GodMod");
    addGMCommand("踢出游戏 | G", "string", undefined, (player, params) => {
        const target = mw.Player.getPlayer(params);
        if (!target) {
            Log4Ts.error(GodModService, `Player not exist. userid: ${params}`);
            throw Error();
        }
        mw.RoomService.kick(target, "Kicked by GodMod Admin");
    }, {
        label: "UserId",
        validator: [{
                reason: "用户不存在",
                validator: (param) => !!mw.Player.getPlayer(param),
            }],
    }, "GodMod");
    addGMCommand("查看当前位置 | G", "string", (guid) => {
        let out;
        const printGameObj = !Gtk.isNullOrEmpty(guid);
        if (printGameObj) {
            const target = mw.GameObject.findGameObjectById(guid);
            out = target?.worldTransform?.position ?? undefined;
            if (out) {
                Log4Ts.log(GodModService, `position of target whose guid is ${guid}:`, out);
            }
            else {
                Log4Ts.log(registerCommonCommands, `guid ${guid} not found.`);
            }
        }
        const playerPos = mw.Player.localPlayer.character.worldTransform.position;
        if (!printGameObj)
            out = playerPos;
        Log4Ts.log(GodModService, `Current player position:`, playerPos);
        return anyPointToString(out, 0);
    }, undefined, { label: "GameObject Id. 可不填 同时输出玩家" }, "GodMod");
    addGMCommand("查看当前旋转 | G", "string", (guid) => {
        let out;
        const printGameObj = !Gtk.isNullOrEmpty(guid);
        if (printGameObj) {
            const target = mw.GameObject.findGameObjectById(guid);
            out = target?.worldTransform?.rotation ?? undefined;
            if (out) {
                Log4Ts.log(GodModService, `rotation of target whose guid is ${guid}:`, out);
            }
            else {
                Log4Ts.log(registerCommonCommands, `guid ${guid} not found.`);
            }
        }
        const playerRot = mw.Player.localPlayer.character.worldTransform.rotation;
        if (!printGameObj)
            out = playerRot;
        Log4Ts.log(GodModService, `Current player rotation:`, playerRot);
        return rotationToString(out, 0);
    }, undefined, { label: "GameObject Id. 可不填 同时输出玩家" }, "GodMod");
    addGMCommand("我的房间 | G", "void", undefined, (player, params) => {
        Log4Ts.log(registerCommonCommands, `room id: ${mw.SystemUtil.roomId}`, `game id: ${mw.SystemUtil.getGameId()}`, `scene id: ${mw.SystemUtil.sceneId}`);
        return mw.SystemUtil.roomId;
    });
    addGMCommand("跳转房间 | G", "string", undefined, (player, roomId) => {
        mw.TeleportService.asyncTeleportToRoom(roomId, [player.userId], {})
            .then((reason) => {
            switch (reason.status) {
                case mw.TeleportStatus.success:
                    break;
                case mw.TeleportStatus.error:
                case mw.TeleportStatus.timeout:
                case mw.TeleportStatus.ignored:
                    Log4Ts.error(GodModService, `Jump to room failed.`, `roomId: ${roomId}`, `status: ${reason.status}`, `users: ${reason.userIds}`, `error code: ${reason.errorCode}`, `reason: ${reason.message}`);
                    throw new Error(reason.message);
            }
        });
    }, undefined, "GodMod");
    addGMCommand("行走速度 | G", "number", () => {
        const player = mw.Player.localPlayer;
        Log4Ts.log(GodModService, `current walk speed: ${player.character.maxWalkSpeed}`, `current acceleration: ${player.character.maxAcceleration}`);
    }, (player, params) => {
        if (Number.isNaN(params) || params <= 0)
            params = 2000;
        player.character.maxWalkSpeed = params;
        player.character.maxAcceleration = params * 2;
    }, undefined, "GodMod");
    addGMCommand("行走加速度 | G", "number", () => {
        const player = mw.Player.localPlayer;
        Log4Ts.log(GodModService, `current walk speed: ${player.character.maxWalkSpeed}`, `current acceleration: ${player.character.maxAcceleration}`);
    }, (player, params) => {
        if (Number.isNaN(params) || params <= 0)
            params = 4000;
        player.character.maxAcceleration = params;
    }, undefined, "GodMod");
    addGMCommand("停止该房间 GodMod 服务 | G", "string", undefined, (player, params) => {
        if (Gtk.isNullOrEmpty(params))
            return;
        if (params === "我确定") {
            GodModService.getInstance().shutdown();
        }
    }, { label: "你确定吗？" }, "GodMod");
}
function showAllPlayer() {
    Log4Ts.log(GodModService, `All player:`);
    mw.Player.getAllPlayers().forEach((player) => {
        Log4Ts.log(undefined, `displayName: ${player.character.displayName}`, `nickName: ${player.nickname}`, `userId: ${player.userId}`, `playerId: ${player.playerId}`, `position: ${player.character.worldTransform.position}`, `walkSpeed: ${player.character.maxWalkSpeed}`, `currentState: ${mw.CharacterStateType[player.character.getCurrentState()]}`, `--------------------------------------------------`);
    });
}
function anyPointToString(vec, fixed = 2) {
    if ("z" in vec) {
        return `x:${vec.x.toFixed(fixed)}, y:${vec.y.toFixed(fixed)}, z:${vec.z.toFixed(fixed)}`;
    }
    return `${vec.x.toFixed(fixed)}, ${vec.y.toFixed(fixed)}`;
}
function rotationToString(vec, fixed = 2) {
    return `x:${vec.x.toFixed(fixed)}, y:${vec.y.toFixed(fixed)}, z:${vec.z.toFixed(fixed)}`;
}
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄

export { GodCommandItem, GodModPanel, addGMCommand, GodModService as default };
//# sourceMappingURL=GodModService.js.map
