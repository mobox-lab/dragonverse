'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*
 * @Author       : feifei.song
 * @Date         : 2022-11-01 14:38:25
 * @LastEditors: YuKun.Gao
 * @LastEditTime: 2023-11-14 11:08:33
 * @FilePath: \commonmodule_guide\JavaScripts\module\guideModule\GuideContent.ts
 * @Description  :
 */
/*
 * @Author: YuKun.Gao
 * @Date: 2022-06-29 15:33:59
 * @LastEditors: YuKun.Gao
 * @LastEditTime: 2022-07-04 19:10:22
 * @Description: file content
 * @FilePath: \JavaScripts\module\guideModule\GuideContent.ts
 */
class GuideContent {
    /**
     * 引导线Guid，引导线创建的时候所使用到的资源
     */
    static GuideArrowGuid = "197413";
    /**
     * 引导线材质Guid，引导线创建的hi后所使用到的材质资源
     */
    static GuideArrowMartialGuid = "154710";
    /**
     * 目的地特效Guid，引导线创建的时候所使用到的目的地的资源
     */
    static GuideWorldTargetEffectGuid = "4337";
    /**
     * 引导线材质缩放：-1：反向，1：正向，设置引导线材质缩放的方向。
     */
    static GuideMatrialScale = 1;
    /**
     * 新手引导UI刷新时间，单位：秒，用于UIMask和需要引导的UI对齐，如果引导的UI位置不变，可以设置为0，但不建议是0。
     */
    static ConstRefrashUITime = 0.1;
    /**
     * 引导线材质更新
     * @param mat 材质
     * @param arrowGo 引导线对象
     * @returns
     */
    static GuideArrowMatrerialUpdate = (mat, arrowGo) => {
        if (!mat || mat.length == 0) {
            return;
        }
        let matrial = mat[0];
        matrial.setScalarParameterValue("Main_TileX", arrowGo.worldTransform.scale.x * GuideContent.GuideMatrialScale);
    };
}

/*
 * @Author: YuKun.Gao
 * @Date: 2022-06-27 09:56:03
 * @LastEditors: YuKun.Gao
 * @LastEditTime: 2023-11-14 11:52:12
 * @Description: file content
 * @FilePath: \commonmodule_guide\JavaScripts\module\guideModule\GuideModuleC.ts
 */
/**
 * 新手引导客户端模块，用于创建引导对象，以及触发引导，提供引导的基础信息配置。
 */
class GuideModuleC extends mwext.ModuleC {
    /** 引导线缩放 */
    arrowScale = new mw.Vector(-1, 1, 1);
    /**
     * 预设引导信息列表，所有当前创建的引导对象。
     */
    guideInfoList = [];
    /**
     * 是否初始化，会在moduleC的onEnterScene中初始化
     */
    isInit = false;
    /**
     * 当前正在执行的引导id
     */
    curGuideIdVal = 0;
    /**
     * 当前正在运行的引导实例
     */
    runningGuide = null;
    /**
     * 引导实例完成事件。
     */
    guideComplateAction = new mw.Action1();
    /**
     * 重写引导主角对象，默认是本地的玩家角色。如果不是玩家角色，比如是球，或者其他的，需要重写这个对象。
     */
    _reSetCharGo;
    /**
     * 覆盖到达目标点距离判断 默认50 小于50则到达
     */
    _reSetToTargetPosDistance = 50;
    /**
     * 引导起始点z偏移，比如引导线希望绑在角色的腰上，那么就需要设置这个偏移。
     */
    _arrowStartPosOffsetZ = 0;
    /**
     * 引导线起始方向偏移，比如希望从角色前方1米开始引导，那么就需要设置这个偏移。
     */
    _guideArrowDirOffse = 0;
    /**
     * 引导线Y缩放，设置引导线的宽度。
     */
    _guideArrowScaleY = 1;
    /**
     * 引导线间隔，用于Pointer模式下，引导点的间隔距离。距离越大Pointer的数量越少
     */
    _guideArrowIntervalDis = 300;
    /**
     * 引导线地标信息，引导线地标对象Guid，默认 29391
     */
    _guideArrowPointerGuid = "29391";
    /**
     * 引导线地标缩放信息，缩放，默认 (1, 1, 1)
     */
    _guideArrowPointerScale = Vector.negOne.multiply(1);
    /**
     * 引导线地标是否粒子效果，默认 否
     */
    _guideArrowPointerIsEffect = false;
    /**
     * 引导线最多显示的地标数量，默认 10
     */
    _guideArrowPointerShowCount = 10;
    /**
     * 引导线地标模式刷新频率，默认 1000 / 30 ，单位毫秒
     */
    _guideArrowPointerUpdateInterval = 1000 / 30;
    /**
     * 引导线地标材质更新函数
     */
    _guideArrowMatrialInit = null;
    /**
     * 进入场景
     * @param sceneType
     */
    onEnterScene(sceneType) {
        //初始化引导
        if (this.isInit == false) {
            this.initGuide();
        }
    }
    /**
     * 获取引导线地标模式刷新频率，主要用于Pointer的渲染模式
     * @returns
     */
    getGuideArrowPointerUpdateInterval() {
        return this._guideArrowPointerUpdateInterval;
    }
    /**
     * 引导线地标模式刷新频率，角色在动，所以需要重新计算寻路路径，这个是刷新频率，单位毫秒，主要用于Pointer的渲染模式
     * @param updateInterval 更新间隔(毫秒)
     */
    setGuideArrowPointerUpdateInterval(updateInterval) {
        this._guideArrowPointerUpdateInterval = updateInterval;
    }
    /**
     * 获取引导线地标是否粒子效果，主要用于Pointer的渲染模式
     * @returns
     */
    getGuideArrowPointerIsEffect() {
        return this._guideArrowPointerIsEffect;
    }
    /**
     * 获取引导线地标guid，主要用于Pointer的渲染模式
     * @returns
     */
    getGuideArrowPointerGuid() {
        return this._guideArrowPointerGuid;
    }
    /**
     * 获取引导线地标缩放信息，主要用于Pointer的渲染模式
     * @returns
     */
    getGuideArrowPointerScale() {
        return this._guideArrowPointerScale;
    }
    /**
     * 获取引导线最多显示的地标数量，主要用于Pointer的渲染模式
     * @returns
     */
    getGuideArrorShowMaxPointer() {
        return this._guideArrowPointerShowCount;
    }
    /**
     * 设置引导线地标信息，主要用于Pointer的渲染模式
     * @param guid 引导线地标对象Guid，默认 29391
     * @param scale 缩放，默认 (1, 1, 1)
     * @param isEffect 是否特效，默认 否
     * @param showPointerCount 最大显示地标数量，默认 10
     * @param matrialUpdate 材质更新函数， 不传不会覆盖默认方法。如果传 boolean 则表示是否反向
     */
    setGuideArrowPointerInfo(guid, scale, isEffect, showPointerCount, matrialUpdate) {
        if (guid) {
            this._guideArrowPointerGuid = guid;
        }
        if (scale) {
            this._guideArrowPointerScale = scale;
        }
        if (isEffect != null) {
            this._guideArrowPointerIsEffect = isEffect;
        }
        if (showPointerCount != null) {
            this._guideArrowPointerShowCount = showPointerCount;
        }
        if (matrialUpdate != null) {
            if (typeof matrialUpdate == "boolean") {
                GuideContent.GuideMatrialScale = matrialUpdate ? -1 : 1;
            }
            else {
                GuideContent.GuideArrowMatrerialUpdate = matrialUpdate;
            }
        }
    }
    /**
     * 获取引导线地标生成间隔距离，主要用于Pointer的渲染模式
     * @returns
     */
    getGuideArrowIntervalDis() {
        return this._guideArrowIntervalDis;
    }
    /**
     * 设置引导线地标生成间隔距离，主要用于Pointer的渲染模式
     * @param intervalDis 间隔距离
     */
    setGuideArrowIntervalDis(intervalDis) {
        this._guideArrowIntervalDis = intervalDis;
    }
    /**
     * 设置引导线Y缩放
     * @param scaleY 引导线Y缩放
     */
    setGuideArrowScaleY(scaleY) {
        this._guideArrowScaleY = scaleY;
    }
    /**
     * 获取引导线Y缩放
     * @returns
     */
    getGuideArrowScaleY() {
        return this._guideArrowScaleY;
    }
    /**
     * 设置引导线起始方向 偏移
     * @param distance 偏移距离
     */
    setGuideArrowDirOffset(distance) {
        this._guideArrowDirOffse = distance;
    }
    /**
     * 获取引导线起始方向 偏移
     */
    getGuideArrowDirOffsetDis() {
        return this._guideArrowDirOffse;
    }
    /**
     * 设置引导线起始坐标 z偏移
     * @param offsetZ z偏移
     */
    setGuideArrowStartPosOffsetZ(offsetZ) {
        this._arrowStartPosOffsetZ = offsetZ;
    }
    /**
     * 获取引导线起始坐标 z偏移
     * @returns
     */
    getGuideArrowStartPosOffsetZ() {
        return this._arrowStartPosOffsetZ;
    }
    /**
     * 设置引导线 & 目标点特效guid，主要用于Line的渲染模式
     * @param arrowGuid 引导线guid "0"则关闭
     * @param arrowMartialGuid 引导线材质guid "0"则关闭
     * @param targetPointEff 目标点guid "0"则关闭
     */
    async setGuideArrowGuid(arrowGuid, arrowMartialGuid, targetPointEff) {
        if (arrowGuid == "0")
            GuideContent.GuideArrowGuid = "";
        else if (arrowGuid != "")
            GuideContent.GuideArrowGuid = arrowGuid;
        if (arrowMartialGuid == "0")
            GuideContent.GuideArrowMartialGuid = "";
        else if (arrowMartialGuid != "")
            GuideContent.GuideArrowMartialGuid = arrowMartialGuid;
        if (targetPointEff == "0")
            GuideContent.GuideWorldTargetEffectGuid = "";
        else if (targetPointEff != "")
            GuideContent.GuideWorldTargetEffectGuid = targetPointEff;
    }
    /**
     * 重置所有引导存档，以及所有引导阶段任务的状态。
     */
    async resetAllGuideDB() {
        await this.server.net_ResetAllGuide();
        this.curGuideIdVal = 0;
        this.guideInfoList.forEach(e => {
            e.resetAllStage();
        });
        this.runningGuide = null;
        console.warn("kang log resetAllGuideDB");
        UIService.getUI(GuideModuleView).hideAllItem();
    }
    /**
     * 重置指定的引导，会重置这个引导的存档状态，以及运行时的状态。
     * @param guideId 引导id
     * @returns 成功/失败
     */
    async resetGuideById(guideId) {
        let res = await this.server.net_ResetGuideAtGuideId(guideId);
        this.guideInfoList.forEach(e => {
            if (e.guideStage == guideId) {
                e.resetAllStage();
            }
        });
        if (this.curGuideIdVal == guideId) {
            this.curGuideIdVal = 0;
        }
        if (this.runningGuide && this.runningGuide.guideStage == guideId) {
            this.runningGuide = null;
            UIService.getUI(GuideModuleView).hideAllItem();
        }
        return res;
    }
    /**
     * 强制完成一个引导，会添加这个引导的存档状态到已完成。
     * @param guideId 引导id
     * @returns
     */
    async forceComplateGuide(guideId) {
        await this.server.net_ComplateGuide(guideId);
        return true;
    }
    /**
     * 获取最后一次执行引导时的id
     */
    getLastGuideId() {
        return this.data.getCurGuide();
    }
    /**
     * 获取当前引导id (废弃)
     * @deprecated 获取当前引导Id - 最新使用 getCurGuideId
     * @returns 返回引导id
     */
    getCurStageVal() {
        return this.curGuideIdVal;
    }
    /**
     * 获取当前引导id
     * @returns 返回引导id
     */
    getCurGuideId() {
        return this.curGuideIdVal;
    }
    /**
     * 到达目标点距离判断 默认50 小于50则到达
     * @param dis 目标点判定距离
     */
    reSetToTargetPosDistance(dis) {
        this._reSetToTargetPosDistance = dis;
    }
    /**
     * 获取到达目标点距离判断 默认50 小于50则到达
     * @returns
     */
    getToTargetPosDistance() {
        return this._reSetToTargetPosDistance;
    }
    /**
     * 设置引导主角对象
     * @param go 主角GameObject对象
     */
    reSetCharGo(go) {
        this._reSetCharGo = go;
    }
    /**
     * 获取引导主角对象
     * @returns
     */
    async getCharGo() {
        if (this._reSetCharGo == null) {
            let player = await mw.Player.localPlayer;
            return player.character;
        }
        return this._reSetCharGo;
    }
    /**
     * 初始化引导模块
     */
    initGuide() {
        if (this.isInit == false)
            this.isInit = true;
        //初始化当前阶段
        this.curGuideIdVal = this.data.getCurGuide();
        //清理掉通过的引导阶段
        // let newList = [];
        // this.guideInfoList.forEach((v) => {
        //     if (v.guideStage >= this.curGuideIdVal) {
        //         newList.push(v);
        //     }
        // })
        // this.guideInfoList = newList;
        //排序引导
        this.guideInfoList = this.guideInfoList.sort((a, b) => {
            return a.guideStage - b.guideStage;
        });
        //触发当前引导
        //TODO:考虑后这里不触发了，还是又外部去触发
        // let guideInfo = this.guideInfoList.find(e => { return e.guideStage == this.curStageVal })
        //监听引导完成
        this.guideComplateAction.add((guideId) => {
            console.error("GuideModuleC : 监听引导完成" + guideId);
            this.server.net_ComplateGuide(guideId);
        }, this);
    }
    /**
     * 移除指定引导，但是不影响存档。
     * @param guideId
     */
    removeGuideId(guideId) {
        let index = this.guideInfoList.findIndex(v => { return v.guideStage == guideId; });
        if (index != -1) {
            this.guideInfoList.splice(index, 1);
        }
    }
    /**
     * 通过引导ID，添加引导对象实例。
     * @param guideId 引导id - 不要重复
     * @return 引导对象实例
     */
    addGuideStageHandle(guideId) {
        // 检测引导Id是否可用
        let canUseGuideId = true;
        this.guideInfoList.forEach(e => {
            if (e.guideStage == guideId)
                canUseGuideId = false;
        });
        if (!canUseGuideId) {
            console.error("repeat stage val : " + guideId);
            return null;
        }
        // 创建引导
        let guideInfo = new GuideInfo(this.guideComplateAction);
        guideInfo.guideStage = guideId;
        this.guideInfoList.push(guideInfo);
        return guideInfo;
    }
    /**
     * 通过引导Id，触发指定的引导。同时会将对应引导示例执行起来。
     * @param guideId 引导id
     */
    triggerGuide(guideId) {
        // 查询引导
        let guide = this.guideInfoList.find(e => e.guideStage == guideId);
        if (guide == null) {
            console.error("[GuideModuleC] : find guide info error -> stage = " + guideId + " " + this.guideInfoList.length);
            return false;
        }
        // 判断引导是否完成
        if (this.data.guideIsComplate(guideId))
            return false;
        // 执行引导
        this.runningGuide = guide;
        // 设置当前引导
        this.server.net_SetCurrentRunGuide(guideId);
        this.curGuideIdVal = guideId;
        //UIService.getUI(GuideModuleView).show();// getUI().show();
        UIService.show(GuideModuleView);
        return true;
    }
    /**
     * Tick，用于运行当前的引导实例。
     * @param dt
     */
    onUpdate(dt) {
        // 更新当前引导
        if (this.runningGuide)
            this.runningGuide.handle(dt);
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

//aits-ignore
exports.GuideModuleUI_Generate = class GuideModuleUI_Generate extends mw.UIScript {
    mLeftMask = undefined;
    mTopMask = undefined;
    mButtomMask = undefined;
    mRightMask = undefined;
    mBtn = undefined;
    mBtnHand = undefined;
    mTextHand = undefined;
    onAwake() {
    }
};
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mLeftMask')
], exports.GuideModuleUI_Generate.prototype, "mLeftMask", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mTopMask')
], exports.GuideModuleUI_Generate.prototype, "mTopMask", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mButtomMask')
], exports.GuideModuleUI_Generate.prototype, "mButtomMask", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mRightMask')
], exports.GuideModuleUI_Generate.prototype, "mRightMask", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mBtn')
], exports.GuideModuleUI_Generate.prototype, "mBtn", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mBtnHand')
], exports.GuideModuleUI_Generate.prototype, "mBtnHand", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mTextHand')
], exports.GuideModuleUI_Generate.prototype, "mTextHand", void 0);
exports.GuideModuleUI_Generate = __decorate([
    UIBind('UI/guideModule/GuideModuleUI.ui')
], exports.GuideModuleUI_Generate);

/*
 * @Author: YuKun.Gao
 * @Date: 2022-06-27 09:56:29
 * @LastEditors: YuKun.Gao
 * @LastEditTime: 2023-11-29 13:19:22
 * @Description: file content
 * @FilePath: \commonmodule_guide\JavaScripts\module\guideModule\GuideModuleView.ts
 */
/**
 * 新手引导视图对象
 */
class GuideModuleView extends exports.GuideModuleUI_Generate {
    /**
     * 接收空间坐标，用于接收UI本地坐标到视口坐标的转换。
     */
    _outPixelPos = new mw.Vector2(0, 0);
    /**
     * 用于接收视口坐标，用于接收UI本地坐标到视口坐标的转换。
     */
    _outViewPos = new mw.Vector2(0, 0);
    /**
     * 当前需要引导的目标UI对象
     */
    _bindTarget = null;
    /**
     * 按钮触发后的通知
     */
    _btnClickToGuide = null;
    /**
     * 按钮触发后的事件传递
     */
    _btnClickToTarget = null;
    /**
     * 引导箭头对象，用于显示引导线
     */
    _guideArrow;
    /**
     * 目标点粒子特效，用于显示目标点
     */
    _targetPosEff;
    /**
     * 到达目标点后的回调
     */
    _toTargetPosCallback = null;
    /**
     * 目标点坐标
     */
    _targetPos;
    /**
     * 上一次的位置
     */
    _lastPos;
    /**
     * Pointer渲染模式中，缓存的渲染对象。
     */
    _cachePointerGo = [];
    /**
     * 当前引导线的渲染类型
     */
    _drawType = 0;
    /**
     * 引导线最后更新时间
     */
    _lastUpdateTime = 0;

    tipOffset = new mw.Vector2(0, 0);

    /**
     * 显示/更新 Pointer 的位置。以渲染引导线。
     * @param pos 所有要引导的位置
     */
    async showPointers(pos) {
        let guideModuleC = ModuleService.getModule(GuideModuleC);
        let intervalDis = guideModuleC.getGuideArrowIntervalDis();
        let newPos = [];
        for (let i = pos.length - 1; i >= 0; i--) {
            let curPos = pos[i];
            if (i - 1 < 0) {
                break;
            }
            newPos.push(curPos);
            let nextPos = pos[i - 1];
            let dirInfo = nextPos.clone().subtract(curPos);
            let length = dirInfo.length;
            let dirNormal = dirInfo.normalized;
            let count = 1;
            while (length > intervalDis) {
                newPos.push(curPos.clone().add(dirNormal.clone().multiply(intervalDis * count)));
                length -= intervalDis;
                count++;
            }
        }
        pos = newPos;
        let lastDir;
        let cacheLength = this._cachePointerGo.length;
        let useCount = 0;
        for (let i = Math.max(0, pos.length - guideModuleC.getGuideArrorShowMaxPointer()); i < pos.length; i++) {
            let go = null;
            const index = i;
            if (useCount >= cacheLength) {
                let trans = new Transform(pos[index], Rotation.zero, Vector.negOne.multiply(-1));
                if (guideModuleC.getGuideArrowPointerIsEffect()) {
                    go = await mw.Effect.asyncSpawn(guideModuleC.getGuideArrowPointerGuid(), { replicates: false, transform: trans });
                    if (go instanceof mw.Effect) {
                        go.loop = true;
                        go.play();
                    }
                }
                else {
                    go = await mw.GameObject.asyncSpawn(guideModuleC.getGuideArrowPointerGuid(), { replicates: false, transform: trans });
                }
                go.setCollision(mw.PropertyStatus.Off);
                // go.setCollision(mw.PropertyStatus.Off);
                go.worldTransform.scale = guideModuleC.getGuideArrowPointerScale();
                this._cachePointerGo.push(go);
                useCount++;
            }
            else {
                go = this._cachePointerGo[useCount];
                useCount++;
                if (guideModuleC.getGuideArrowPointerIsEffect()) {
                    if (go instanceof mw.Effect) {
                        go.loop = true;
                        go.play();
                    }
                }
                go.worldTransform.position = pos[index];
            }
            if (pos.length > index + 1) {
                lastDir = (pos[index].subtract(pos[index + 1]));
                let dir = lastDir.toRotation();
                dir.x = 0;
                dir.y = 0;
                lastDir = dir.getForce();
                go.worldTransform.rotation = dir;
            }
            else {
                if (lastDir) {
                    go.worldTransform.rotation = lastDir.toRotation();
                }
            }
            go.setVisibility(mw.PropertyStatus.On);
        }
        for (let i = useCount; i < cacheLength; i++) {
            if (guideModuleC.getGuideArrowPointerIsEffect()) {
                let eff = this._cachePointerGo[i];
                if (eff instanceof mw.Effect) {
                    eff.loop = false;
                    eff.stop();
                }
            }
            this._cachePointerGo[i].setVisibility(mw.PropertyStatus.Off);
        }
    }
    /**
     * 模块初始化，只会调用一次，主要完成一些按钮的监听等操作，以及引导线，目标点特效的初始化。
     */
    onStart() {
        this.layer = mw.UILayerTop;
        this.canUpdate = true;
        this.mLeftMask.onClicked.add(() => {
            Event.dispatchToLocal("PlayButtonClick", "mLeftMask");
        });
        this.mTopMask.onClicked.add(() => {
            Event.dispatchToLocal("PlayButtonClick", "mTopMask");
        });
        this.mButtomMask.onClicked.add(() => {
            Event.dispatchToLocal("PlayButtonClick", "mButtomMask");
        });
        this.mRightMask.onClicked.add(() => {
            Event.dispatchToLocal("PlayButtonClick", "mRightMask");
        });
        this.mBtn.onClicked.add(() => {
            Event.dispatchToLocal("PlayButtonClick", "mBtn");
        });
        this.mBtn.onClicked.add(() => {
            this.buttonClick();
        });
        // 初始化引导线
        if (this._guideArrow == null) {
            if (GuideContent.GuideArrowGuid != "") {
                mw.GameObject.asyncSpawn(GuideContent.GuideArrowGuid).then(async (go) => {
                    this._guideArrow = go;
                    let mesh = this._guideArrow;
                    if (!mw.AssetUtil.assetLoaded(GuideContent.GuideArrowMartialGuid)) {
                        await mw.AssetUtil.asyncDownloadAsset(GuideContent.GuideArrowMartialGuid);
                    }
                    mesh.setMaterial(GuideContent.GuideArrowMartialGuid);
                    this._guideArrow.setVisibility(mw.PropertyStatus.Off);
                    this._guideArrow.setCollision(mw.PropertyStatus.Off);
                    // this._guideArrow.setCollision(mw.PropertyStatus.Off);
                    GuideContent.GuideArrowMatrerialUpdate && GuideContent.GuideArrowMatrerialUpdate(mesh.getMaterialInstance(), go);
                });
            }
        }
        if (this._targetPosEff == null) {
            if (GuideContent.GuideWorldTargetEffectGuid) {
                mw.Effect.asyncSpawn(GuideContent.GuideWorldTargetEffectGuid, { replicates: false }).then(async (go) => {
                    this._targetPosEff = go;
                    if (!this._targetPosEff) {
                        this._targetPosEff = (await mw.Effect.asyncSpawn(GuideContent.GuideWorldTargetEffectGuid, { replicates: false }));
                    }
                    this._targetPosEff?.setVisibility(mw.PropertyStatus.Off);
                });
            }
        }
        // 设置隐藏mask
        this.showMask(false);
        // 隐藏按钮
        this.mBtn.visibility = (mw.SlateVisibility.Hidden);
        this.mBtnHand.visibility = (mw.SlateVisibility.Hidden);
        this.mTextHand.visibility = (mw.SlateVisibility.Hidden);
    }
    /**
     * 隐藏所有的组件
     */
    hideAllItem() {
        // 设置隐藏mask
        this.showMask(false);
        // 隐藏按钮
        this.mBtn.visibility = (mw.SlateVisibility.Hidden);
        this.mBtnHand.visibility = (mw.SlateVisibility.Hidden);
        this.mTextHand.visibility = (mw.SlateVisibility.Hidden);
        if (this._targetPosEff)
            this._targetPosEff.setVisibility(mw.PropertyStatus.Off);
        if (this._guideArrow)
            this._guideArrow.setVisibility(mw.PropertyStatus.Off);
        for (let i = 0; i < this._cachePointerGo.length; i++) {
            if (ModuleService.getModule(GuideModuleC).getGuideArrowPointerIsEffect()) {
                let eff = this._cachePointerGo[i];
                eff.loop = false;
                eff.stop();
            }
            this._cachePointerGo[i].setVisibility(mw.PropertyStatus.Off);
        }
        this._targetPos = null;
    }
    /**
     * 引导视图UI被显示的时候，会回调该函数，会初始化引导线，以及初始化目标点特效。
     * @param params
     */
    onShow(...params) {
        //super.onShow();
        //oTrace("guide module view show")
        //oTrace(GuideContent.GuideArrowGuid);
        //oTrace(GuideContent.GuideWorldTargetEffectGuid);
        // 初始化引导线
        if (this._guideArrow && GuideContent.GuideArrowGuid == "") {
            this._guideArrow.destroy();
            this._guideArrow = null;
        }
        // 初始化目标点特效
        if (this._targetPosEff && GuideContent.GuideWorldTargetEffectGuid == "") {
            this._targetPosEff.destroy();
            this._targetPosEff = null;
        }
    }
    /**
     * 引导视图UI的显示隐藏处理。
     * @param isShow
     */
    showMask(isShow) {
        // 隐藏引导组件
        let state = mw.SlateVisibility.Visible;
        if (!isShow)
            state = mw.SlateVisibility.Hidden;
        this.mTopMask.visibility = (state);
        this.mButtomMask.visibility = (state);
        this.mLeftMask.visibility = (state);
        this.mRightMask.visibility = (state);
        if (isShow)
            UIService.show(GuideModuleView);
        else
            UIService.hide(GuideModuleView);
    }
    /**
     * 引导button点击后的回调，完成当前引导，以及触发对应的点击事件。并且隐藏当前hook的按钮对象。
     */
    buttonClick() {
        // 完成当前引导
        if (this._btnClickToGuide) {
            this._btnClickToGuide();
            this._btnClickToGuide = null;
        }
        // 触发对应点击按钮事件
        if (this._btnClickToTarget) {
            this._btnClickToTarget();
            this._btnClickToTarget = null;
            this._bindTarget = null;
        }
        // 隐藏按钮组件
        this.mBtn.visibility = (mw.SlateVisibility.Hidden);
        this.mBtnHand.visibility = (mw.SlateVisibility.Hidden);
        this.mTextHand.visibility = (mw.SlateVisibility.Hidden);
    }
    /**
     * 设置引导到目标点，会被GuideStage重复调用，通过bUpdateArrow判断是否更新引导线目标点，用于更新引导线的位置，以及目标点特效的位置。
     * @param targetPos 目标点
     * @param callback 回调事件
     */
    async setGuideArrowTargetPos(targetPos, callback, drawType, bUpdateArrow) {
        // 检查玩家是否到达目标点
        let char = await ModuleService.getModule(GuideModuleC).getCharGo();
        let guideModuleC = ModuleService.getModule(GuideModuleC);
        if (!bUpdateArrow) {
            //oTrace("设置到达目标点");
            // 设置到达目标点后的回调
            this._drawType = drawType;
            this._toTargetPosCallback = callback;
            // 设置目标点特效
            if (this._targetPosEff) {
                if (this._targetPos != null && mw.Vector.equals(this._targetPos, targetPos))
                    return;
                this._targetPosEff.worldTransform.position = targetPos.clone(); //(new mw.Vector(0, 0, 0));
                this._targetPosEff.setVisibility(mw.PropertyStatus.On);
                if (this._targetPosEff instanceof mw.Effect) {
                    this._targetPosEff.loop = (true);
                    this._targetPosEff.play();
                }
            }
            // 设置目标点
            this._targetPos = targetPos;
        }
        if (char.worldTransform.position.clone().subtract(targetPos).length <= guideModuleC.getToTargetPosDistance()) {
            // 回调到达目标点
            if (this._toTargetPosCallback) {
                let res = this._toTargetPosCallback();
                if (!res)
                    return;
            }
            this._toTargetPosCallback = null;
            // 关闭寻路显示
            if (this._guideArrow)
                this._guideArrow.setVisibility(mw.PropertyStatus.Off);
            if (this._targetPosEff)
                this._targetPosEff.setVisibility(mw.PropertyStatus.Off);
            this._cachePointerGo.forEach(e => {
                e.setVisibility(mw.PropertyStatus.Off);
            });
            return;
        }
        // 设置箭头到达目标点
        if (this._drawType == 0) {
            if (this._guideArrow) {
                let dirOffset = guideModuleC.getGuideArrowDirOffsetDis();
                let chrLocal = new mw.Vector(char.worldTransform.position.x, char.worldTransform.position.y, char.worldTransform.position.z + guideModuleC.getGuideArrowStartPosOffsetZ());
                let subdir = targetPos.clone().subtract(chrLocal);
                let scale = (subdir.length - dirOffset) / 100;
                let offsetPos = subdir.multiply(0.5).add(subdir.normalized.multiply(dirOffset));
                this._guideArrow.worldTransform.position = chrLocal.clone().add(offsetPos);
                this._guideArrow.worldTransform.rotation = offsetPos.toRotation().rotateVector(new Vector(90, 0, 0)).toRotation();
                this._guideArrow.setVisibility(mw.PropertyStatus.On);
                this._guideArrow.worldTransform.scale = new mw.Vector(scale, guideModuleC.getGuideArrowScaleY(), 1).multiply(guideModuleC.arrowScale);
                GuideContent.GuideArrowMatrerialUpdate &&
                    GuideContent.GuideArrowMatrerialUpdate(this._guideArrow.getMaterialInstance(), this._guideArrow);
            }
        }
        else if (this._drawType == 1) {
            if (this._lastUpdateTime == 0 || Date.now() - this._lastUpdateTime >= guideModuleC.getGuideArrowPointerUpdateInterval()) {
                let paths = await Navigation.findPath(char.worldTransform.position, targetPos);
                this.showPointers(paths);
                this._lastUpdateTime = Date.now();
            }
        }
    }
    /**
     * 引导一个UI对象，会用mask将除这个UI对象外的区域全部遮罩起来，并且会生成一个Hook按钮完全遮挡住引导的UI对象，以Hook对应的事件，进行下发。
     * @param target 目标UI对象
     */
    lockMWUIWidget(target, callback, tips = "", isShowBtn = true) {
        // 获取target的slot信息
        let target_slot = target;
        if (target.tickSpaceGeometry == null) {
            return;
        }
        mw.localToViewport(target.tickSpaceGeometry, mw.Vector2.zero, this._outPixelPos, this._outViewPos);
        // 如果对象是一个按钮，则同时添加一个监听消息，点击覆盖区域后触发对应按钮事件
        if (this._bindTarget != target) {
            this._btnClickToGuide = callback;
            this._bindTarget = target;
            this._btnClickToTarget = null;
            //Input
            if (target instanceof mw.Button || target instanceof mw.StaleButton || target instanceof mw.MaskButton) {
                this._btnClickToTarget = () => {
                    if (target["clickedDelegate"]) {
                        target["clickedDelegate"].broadcast();
                    }
                    else if (target["onClicked"]) {
                        target["onClicked"].broadcast();
                    }
                };
            }
        }
        if (!this._outViewPos || this._outViewPos.equals(mw.Vector2.zero)) {
            return;
        }
        // 设置mask区域
        const viewportSize = mw.WindowUtil.getViewportSize();
        //const viewportSize = new mw.Vector2(5000, 5000);
        let targetSlotSize = target_slot.size;
        // 设置Top
        this.mTopMask.size = new mw.Vector2(viewportSize.x, this._outViewPos.y);
        // 设置Buttom
        this.mButtomMask.position = new mw.Vector2(0, this._outViewPos.y + targetSlotSize.y);
        this.mButtomMask.size = new mw.Vector2(viewportSize.x, viewportSize.y - this.mButtomMask.position.y);
        // 设置Left
        this.mLeftMask.position = new mw.Vector2(0, this.mTopMask.size.y);
        this.mLeftMask.size = new mw.Vector2(this._outViewPos.x, viewportSize.y - this.mTopMask.size.y - this.mButtomMask.size.y);
        // 设置Right
        this.mRightMask.position = new mw.Vector2(this._outViewPos.x + targetSlotSize.x, this.mTopMask.size.y);
        this.mRightMask.size = new mw.Vector2(viewportSize.x - this.mButtomMask.position.x, viewportSize.y - this.mTopMask.size.y - this.mButtomMask.size.y);
        //设置手指
        this.mBtnHand.position =
            //new mw.Vector2(this._outViewPos.x + targetSlotSize.x / 2 - this.mBtnHand.size.x / 2, this._outViewPos.y + targetSlotSize.y / 2);
            new mw.Vector2(this._outViewPos.x + targetSlotSize.x / 2 - this.mBtnHand.size.x / 2, this._outViewPos.y + targetSlotSize.y / 2 - this.mBtnHand.size.y / 2);
        this.mTextHand.text = (tips);
        let size = this.mTextHand.desiredSize;
        let btnHandPos = this.mBtnHand.position.clone(); //.addition(mw.Vector2.zero);
        let btnHandSize = this.mBtnHand.size.clone(); //.addition(mw.Vector2.zero);
        if (this._outViewPos.y < viewportSize.y / 2) {
            //在屏幕上方
            if (this._outViewPos.x < viewportSize.x / 2) {
                this.mTextHand.position =
                    new mw.Vector2(btnHandPos.x + this.tipOffset.x, btnHandPos.y + btnHandSize.y + this.tipOffset.y);
            }
            else {
                this.mTextHand.position =
                    new mw.Vector2(btnHandPos.x + (btnHandSize.x - size.x) + this.tipOffset.x, btnHandPos.y + btnHandSize.y + this.tipOffset.y);
            }
        }
        else {
            //在屏幕下方
            if (this._outViewPos.x < viewportSize.x / 2) {
                this.mTextHand.position =
                    new mw.Vector2(btnHandPos.x + this.tipOffset.x, btnHandPos.y - btnHandSize.y + this.tipOffset.y);
            }
            else {
                this.mTextHand.position =
                    new mw.Vector2(btnHandPos.x + (btnHandSize.x - size.x) + this.tipOffset.x, btnHandPos.y - btnHandSize.y + this.tipOffset.y);
            }
        }
        // 设置button区域
        this.mBtn.position = new mw.Vector2(this._outViewPos.x, this._outViewPos.y);
        this.mBtn.size = new mw.Vector2(target_slot.size.x, target_slot.size.y);
        this.showMask(true);
        if (isShowBtn)
            this.mBtn.visibility = (mw.SlateVisibility.Visible);
        else
            this.mBtn.visibility = (mw.SlateVisibility.Hidden);
        this.mBtnHand.visibility = (mw.SlateVisibility.SelfHitTestInvisible);
        if (tips != "")
            this.mTextHand.visibility = (mw.SlateVisibility.SelfHitTestInvisible);
    }
}

/*
 * @Author: YuKun.Gao
 * @Date: 2022-06-27 10:36:36
 * @LastEditors: YuKun.Gao
 * @LastEditTime: 2023-11-14 11:33:29
 * @Description: file content
 * @FilePath: \commonmodule_guide\JavaScripts\module\guideModule\GuideInfo.ts
 */
/**
 * 每个引导任务阶段对象的状态
 */
var GuideState;
(function (GuideState) {
    /**
     * 拉取任务状态
     * */
    GuideState[GuideState["Pull"] = 0] = "Pull";
    /**
     * 等待完成UI引导状态
     */
    GuideState[GuideState["WaitUI"] = 1] = "WaitUI";
    /**
     * 等待到达世界坐标状态
     */
    GuideState[GuideState["WaitToPos"] = 2] = "WaitToPos";
    /**
     * 等待完成自定义条件状态
     */
    GuideState[GuideState["ConditionRes"] = 3] = "ConditionRes";
    /**
     * 执行自定义函数状态
     */
    GuideState[GuideState["RunFunc"] = 4] = "RunFunc";
    /**
     * 完成状态
     */
    GuideState[GuideState["Complate"] = 5] = "Complate";
})(GuideState || (GuideState = {}));
/**
 * 引导任务的阶段对象，内部会完成当前阶段的一些逻辑，比如UI引导，到达目标点，完成自定义条件等
 */
class GuideTaskStage {
    /**
     * 当前任务阶段的状态
     */
    type;
    /**
     * 需要引导的UI组件，由外部传入可能是按钮，图片，一个widget的区域等。
     */
    uiWidget = null;
    /**
     * 默认刷新dt，引导UI时，要处理mask的对齐，所以需要刷新UI
     */
    refrashDt = GuideContent.ConstRefrashUITime;
    /**
     * 当前刷新UI的dt，用于计算是否需要刷新UI
     */
    curReFrashDt = 0;
    /**
     * 需要引导到达的位置,世界坐标
     */
    toWorldPos = null;
    /**
     * UI完成需要检测的条件,如果不为空，会在每次刷新UI的时候，检测条件是否满足，如果满足，会直接完成当前阶段的引导任务。
     */
    uiCheckCondition = null;
    /**
     * 完成需要检测的条件,如果不为空，会在当前阶段任务每次刷新的时候执行checkCondition，如果满足，会直接完成当前阶段的引导任务。
     */
    checkCondition = [];
    /**
     * 引导UI时的提示语言,如果为空，不会显示提示语言,否则会在对应需要引导的区域显示对应的tips。
     */
    tips = "";
    /**
     * 寻路线段渲染方式,默认为0，如果时line的模式则是用一个支持平铺的材质去调整scale进行平铺，如果是point会生成多个gameobject，去表达寻路的线段。
     * 0 为line 1为point
     */
    drawType = 0;
    /**
     * 需要执行的自定义函数,如果不为空，会在当前阶段被调起的时候执行自定义函数。执行后完成当前任务。
     */
    runFuncs = [];
    /**
     * 复制一个引导任务阶段
     * @returns
     */
    copy() {
        let condition = null;
        switch (this.type) {
            case GuideState.WaitUI:
                condition = this.uiWidget;
                break;
            case GuideState.WaitToPos:
                condition = this.toWorldPos;
                break;
            case GuideState.ConditionRes:
                condition = this.checkCondition;
                break;
        }
        let res = GuideTaskStage.newGuideTaskStage(this.type, condition, this.runFuncs, this.uiCheckCondition);
        res.tips = this.tips;
        res.drawType = this.drawType;
        return res;
    }
    /**
     * 创建引导任务阶段，根据传入的GuideState去判断创建的类型，可以创建引导UI，到达目标点，完成自定义条件，执行自定义函数等任务。
     * @param type 类型
     * @param condition 条件
     */
    static newGuideTaskStage(type, condition, runFuncs = [], uiConditionRes = null) {
        let guideTaskStage = new GuideTaskStage();
        guideTaskStage.type = type;
        switch (type) {
            case GuideState.WaitUI:
                if (condition instanceof mw.Widget) {
                    guideTaskStage.uiWidget = condition;
                }
                guideTaskStage.uiCheckCondition = uiConditionRes;
                break;
            case GuideState.WaitToPos:
                if (condition instanceof mw.Vector)
                    guideTaskStage.toWorldPos = condition;
                guideTaskStage.uiCheckCondition = uiConditionRes;
                break;
            case GuideState.ConditionRes:
                if (condition instanceof Array)
                    guideTaskStage.checkCondition = condition;
                break;
            case GuideState.RunFunc:
                guideTaskStage.runFuncs = runFuncs;
                break;
        }
        return guideTaskStage;
    }
}
/**
 * 引导信息，一个引导信息包含了引导的所有阶段，每个阶段都是一个GuideTaskStage对象。通过多个引导阶段的任务来表示一个引导信息。多个引导信息组成一个完成的引导系统。
 */
class GuideInfo {
    /**
     * 引导信息id。
     */
    guideStage = 0;
    /**
     * 当前引导信息还需要执行的所有引导阶段的任务，执行完成一个则会删除一个。
     */
    taskStage = [];
    /**
     * 源引导列表，存储了当前引导信息中所有需要完成的引导阶段的任务，用于可以重置当前引导。
     */
    srcStage = [];
    /**
     * 当前引导状态，用于标识内部执行逻辑的状态。
     */
    curState = GuideState.Pull;
    /**
     * 引导完成后的通知，会传入当前引导的id。
     */
    complateNotify = null;
    // /**
    //  * 每100毫秒刷新下UI，用于UI引导时，mask的对齐。
    //  */
    // private refrashUITime: number = 0.1;
    /**
     *
     * @param complateNotify 引导完成后的通知，会传入当前引导的id。
     */
    constructor(complateNotify) {
        this.complateNotify = complateNotify;
    }
    /**
     * 添加一个引导UI的阶段，并且同时添加一个完成条件，当UI引导完成后，会检测完成条件，如果满足则会直接完成当前阶段的引导任务。
     * @param widget 需要引导的UI
     * @param condition 完成条件
     * @returns
     */
    addBindUIByCondition(widget, condition) {
        let stage = GuideTaskStage.newGuideTaskStage(GuideState.WaitUI, widget, [], condition);
        this.taskStage.push(stage);
        this.srcStage.push(stage.copy());
        return this;
    }
    /**
     * 添加一个引导UI的阶段，并且同时添加一个完成条件，在引导的过程中显示对应的tips,当UI引导完成后，会检测完成条件，如果满足则会直接完成当前阶段的引导任务。
     * @param widget 需要引导的UI
     * @param tips 引导提示语言
     * @param condition 完成条件
     * @returns
     */
    addBindUIAndTipsByCondition(widget, tips, condition) {
        let stage = GuideTaskStage.newGuideTaskStage(GuideState.WaitUI, widget, [], condition);
        stage.tips = tips;
        this.taskStage.push(stage);
        this.srcStage.push(stage.copy());
        return this;
    }
    /**
     * 添加多个引导UI的阶段，可以传入多个UI，每个UI会创建一个引导阶段的任务，按顺序压入，完成一个会删除一个。这样会按顺序引导多个UI。
     * @param widgets 需要顺序引导的多个UI
     * @returns
     */
    addBindUI(...widgets) {
        widgets.forEach((v, i, arrs) => {
            let stage = GuideTaskStage.newGuideTaskStage(GuideState.WaitUI, v);
            this.taskStage.push(stage);
            this.srcStage.push(stage.copy());
        });
        return this;
    }
    /**
     * 添加一个引导UI的阶段，引导UI时会显示对应的tips
     * @param widget 需要引导的UI
     * @param tips 引导UI时的提示信息
     * @returns
     */
    addBindUIAndTips(widget, tips) {
        let stage = GuideTaskStage.newGuideTaskStage(GuideState.WaitUI, widget);
        stage.tips = tips;
        this.taskStage.push(stage);
        this.srcStage.push(stage.copy());
        return this;
    }
    /**
     * 添加多个引导UI的阶段，可以传入多个UI，每个UI会创建一个引导阶段的任务，按顺序压入，完成一个会删除一个。这样会按顺序引导多个UI。并且引导这些UI的时候会总是刷新Mask的位置，因为这些UI可能是动态的。
     * @param widgets 需要顺序引导的多个UI
     * @returns
     */
    addBindUIAlawaysRefrash(...widgets) {
        widgets.forEach((v, i, arrs) => {
            let stage = GuideTaskStage.newGuideTaskStage(GuideState.WaitUI, v);
            stage.refrashDt = 0;
            stage.curReFrashDt = 0;
            this.taskStage.push(stage);
            this.srcStage.push(stage.copy());
        });
        return this;
    }
    /**
     * 添加多个目的地坐标，按顺序压入，完成一个会删除一个。这样会按顺序引导到多个目的地。并且会以line的方式渲染寻路线段。
     * @param poslist 多个目的地坐标
     * @returns
     */
    addBindWorldPos(...poslist) {
        poslist.forEach((v, i, arrs) => {
            let stage = GuideTaskStage.newGuideTaskStage(GuideState.WaitToPos, v);
            this.taskStage.push(stage);
            this.srcStage.push(stage.copy());
        });
        return this;
    }
    /**
     * 添加一个目的地坐标，引导到达目的地后，会检测完成条件，如果满足则会直接完成当前阶段的引导任务。并且会以line的方式渲染寻路线段。
     * @param poslist 多个目的地坐标
     * @param callback 自定义通过条件
     * @returns
     */
    addBindWorldPosByCondition(poslist, callback) {
        let stage = GuideTaskStage.newGuideTaskStage(GuideState.WaitToPos, poslist, [], callback);
        this.taskStage.push(stage);
        this.srcStage.push(stage.copy());
        return this;
    }
    /**
     * 添加多个目的地坐标，按顺序压入，完成一个会删除一个。这样会按顺序引导到多个目的地。并且会以Pointer的方式渲染寻路线段。
     * @param poslist 多个目的地坐标
     * @returns
     */
    addBindWorldPos_Pointer(...poslist) {
        poslist.forEach((v, i, arrs) => {
            let stage = GuideTaskStage.newGuideTaskStage(GuideState.WaitToPos, v);
            stage.drawType = 1;
            this.taskStage.push(stage);
            this.srcStage.push(stage.copy());
        });
        return this;
    }
    /**
     * 添加一个目的地坐标，引导到达目的地后，会检测完成条件，如果满足则会直接完成当前阶段的引导任务。并且会以Pointer的方式渲染寻路线段。
     * @param poslist 坐标
     * @param callback 自定义通过条件
     * @returns
     */
    addBindWorldPosByCondition_Pointer(poslist, callback) {
        let stage = GuideTaskStage.newGuideTaskStage(GuideState.WaitToPos, poslist, [], callback);
        stage.drawType = 1;
        this.taskStage.push(stage);
        this.srcStage.push(stage.copy());
        return this;
    }
    /**
     * 添加多个判断条件，按顺序压入，会顺序执行每个自定义判断条件的引导阶段任务，完成一个删除一个，直到所有的自定义判断条件都满足，才会完成当前引导阶段的任务。
     * @param conditions 多个判断条件
     * @returns
     */
    addCondition(...conditions) {
        let stage = GuideTaskStage.newGuideTaskStage(GuideState.ConditionRes, conditions);
        this.taskStage.push(stage);
        this.srcStage.push(stage.copy());
        return this;
    }
    /**
     * 添加多个自定义执行函数，按顺序压入，会顺序执行每个自定义执行函数的引导阶段任务，完成一个删除一个，直到所有的自定义执行函数都执行完成，才会完成当前引导阶段的任务。
     * @param func 多个执行函数
     */
    addRunFunc(...funcs) {
        let stage = GuideTaskStage.newGuideTaskStage(GuideState.RunFunc, null, funcs);
        this.taskStage.push(stage);
        this.srcStage.push(stage.copy());
        return this;
    }
    /**
     * 重置所有引导阶段，会重新拉取一次所有的引导阶段任务，用于引导失败后，重新拉取引导阶段。
     */
    resetAllStage() {
        this.curState = GuideState.Pull;
        //this.refrashUITime = 0.1;
        this.taskStage = [];
        for (let i = 0; i < this.srcStage.length; ++i) {
            this.taskStage.push(this.srcStage[i].copy());
        }
    }
    /**
     * 获取当前引导任务，如果没有任务则返回null
     * @returns
     */
    getCurTask() {
        if (this.taskStage.length <= 0)
            return null;
        return this.taskStage[0];
    }
    /**
     * 执行引导任务，每帧执行一次，内部会根据当前引导任务的状态，去执行对应的逻辑。比如是该拉取一个引导任务，还是应该等待当前引导任务完成。或者检查是否到达目标点，或者检查是否完成自定义条件等。
     */
    handle(dt) {
        /**
         * 当前状态是拉取任务
         */
        if (this.curState == GuideState.Pull) {
            this.pullTask();
            return;
        }
        if (this.curState == GuideState.WaitUI) {
            this.taskStage[0].curReFrashDt -= dt;
            if (this.taskStage[0].curReFrashDt <= 0) {
                let first = this.taskStage[0].uiWidget;
                this.beginUITask(first);
                let stage = this.taskStage[0];
                if (stage.uiCheckCondition && stage.uiCheckCondition()) {
                    UIService.getUI(GuideModuleView).hideAllItem();
                    this.onUITaskCallback();
                    return;
                }
            }
            return;
        }
        /**
         * 验证是否到达目标点
         */
        if (this.curState == GuideState.WaitToPos) {
            UIService.getUI(GuideModuleView).setGuideArrowTargetPos(this.taskStage[0].toWorldPos, null, 0, true);
            return;
        }
        /**
         * 验证是否完成自定义条件
         */
        if (this.curState == GuideState.ConditionRes) {
            if (this.checkCondition()) {
                this.curState = GuideState.Pull;
                this.taskStage.shift();
            }
            return;
        }
    }
    /**
     * 拉取一个引导任务，如果拉取不到任务，则会完成当前引导。
     */
    pullTask() {
        let task = null;
        //当前是否还有任务
        if (this.taskStage.length > 0) {
            //获取最前面的任务
            task = this.taskStage[0];
            //拉取UI任务
            if (task.type == GuideState.WaitUI) {
                this.taskStage[0];
                let first = this.taskStage[0].uiWidget;
                this.beginUITask(first);
                return;
            }
            else {
                UIService.getUI(GuideModuleView).showMask(false);
            }
            //拉取目标点任务
            if (task.type == GuideState.WaitToPos) {
                let toPos = this.taskStage[0].toWorldPos;
                this.beginToWorldPosTask(toPos, this.taskStage[0].drawType);
                return;
            }
            //拉取自定义判断条件
            if (task.type == GuideState.ConditionRes) {
                this.curState = GuideState.ConditionRes;
                return;
            }
            //拉取自定义运行函数
            if (task.type == GuideState.RunFunc) {
                // oTrace("执行自定义函数")
                this.taskStage.shift();
                this.curState = GuideState.Pull;
                try {
                    task.runFuncs.forEach((v, i, arrs) => {
                        v();
                    });
                }
                catch (ex) {
                    console.error(ex.stack);
                }
                return;
            }
        }
        //拉取不到任务 - 完成引导
        this.curState = GuideState.Complate;
        UIService.getUI(GuideModuleView).showMask(false);
        if (this.complateNotify) {
            this.complateNotify.call(this.guideStage);
        }
    }
    /**
     * 检查自定义条件是否满足
     * @returns
     */
    checkCondition() {
        let res = true;
        this.taskStage[0].checkCondition.forEach(v => {
            if (!v())
                res = false;
        });
        return res;
    }
    /**
     * UI任务触发完成后的回调，比如引导一个UI，要等用户点触对应的UI区域时，才会回调当前函数来标注当前引导阶段任务的完成。
     */
    onUITaskCallback() {
        this.curState = GuideState.Pull;
        this.taskStage.shift();
    }
    /**
     * 引导到目标地点后的回调，比如引导一个目的地，需要等用户到达目的地后，才会回调当前函数来标注当前引导阶段任务的完成。
     */
    onWorldToPosTaskCallback() {
        //oTrace("回调到达目标点")
        let stage = this.taskStage[0];
        if (stage.uiCheckCondition != null) {
            let res = stage.uiCheckCondition();
            if (!res) {
                return false;
            }
        }
        this.curState = GuideState.Pull;
        this.taskStage.shift();
        return true;
    }
    /**
     * 开始UI引导任务，会锁定对应的UI，当用户点击对应的UI区域时，会回调onUITaskCallback函数来标注当前引导阶段任务的完成。
     * @param widget 要引导点击的目标UI对象或区域
     */
    beginUITask(widget) {
        this.taskStage[0].curReFrashDt = this.taskStage[0].refrashDt;
        this.curState = GuideState.WaitUI;
        UIService.getUI(GuideModuleView).lockMWUIWidget(widget, this.onUITaskCallback.bind(this), this.taskStage[0].tips, this.taskStage[0].uiCheckCondition == null);
    }
    /**
     * 开始引导到达目标点的任务，会显示对应的寻路线段，当用户到达目标点后，会回调onWorldToPosTaskCallback函数来标注当前引导阶段任务的完成。
     * @param toPos 目标点
     */
    beginToWorldPosTask(toPos, drawType) {
        this.curState = GuideState.WaitToPos;
        UIService.getUI(GuideModuleView).showMask(false);
        UIService.getUI(GuideModuleView).setGuideArrowTargetPos(toPos, this.onWorldToPosTaskCallback.bind(this), drawType, false);
    }
}

/*
 * @Author: YuKun.Gao
 * @Date: 2022-06-27 10:15:29
 * @LastEditors: YuKun.Gao
 * @LastEditTime: 2023-11-14 11:36:07
 * @Description: file content
 * @FilePath: \commonmodule_guide\JavaScripts\module\guideModule\GuideModelData.ts
 */
/**
 * 新手引导数据的存储类，用于存储用户完成的引导，以及当前正在进行的引导。
 */
class GuideDataHelper extends Subdata {
    /**
     * 引导数据变化事件
     */
    onGuideChangeAction = new mw.Action();
    /**
     * 以前老的引导列表存储，废弃掉了。
     */
    complateGuide = null;
    /**
     * 已经完成的引导列表
     */
    complateGuideList = null;
    /**
     * 当前正在执行的引导
     */
    curGuide = 0;
    get dataName() {
        return "GuideSrcData";
    }
    /**
     * 初始化数据
     */
    onDataInit() {
        this.complateGuideList = this.complateGuideList || [];
        if (this.complateGuide && this.complateGuide.length > 0) {
            this.complateGuideList.push(...this.complateGuide);
            this.complateGuide = [];
        }
    }
    /**
     * 初始化默认引导数据。
     */
    initDefaultData() {
        if (this.complateGuideList == null)
            this.complateGuideList = [];
    }
    /**
     * 重置所有引导存档
     */
    resetAllGuide() {
        this.complateGuideList = [];
        this.curGuide = 0;
        this.save(true);
    }
    /**
     * 重置引导存档
     * @param guideId
     */
    resetGuideById(guideId) {
        let newList = [];
        let has = false;
        this.complateGuideList.forEach(e => {
            if (e == guideId) {
                has = true;
                return;
            }
            newList.push(e);
        });
        if (!has)
            return true;
        this.complateGuideList = newList;
        if (this.curGuide == guideId) {
            this.curGuide = 0;
        }
        this.save(true);
        return true;
    }
    /**
     * 完成引导
     * @param guideId 引导id
     */
    complateGuideHandle(guideId) {
        this.complateGuideList.push(guideId);
        this.onGuideChangeAction.call();
        this.save(true);
    }
    /**
     * 引导是否完成
     * @param guideId 引导id
     * @returns
     */
    guideIsComplate(guideId) {
        let guide = this.complateGuideList.findIndex(e => { return e == guideId; });
        if (guide >= 0) {
            return true;
        }
    }
    /**
     * 获取当前引导
     */
    getCurGuide() {
        return this.curGuide;
    }
    /**
     * 设置当前引导id
     * @param val
     */
    setCurGuide(val) {
        this.curGuide = val;
        this.save(true);
    }
}
__decorate([
    Decorator.persistence()
], GuideDataHelper.prototype, "complateGuide", void 0);
__decorate([
    Decorator.persistence()
], GuideDataHelper.prototype, "complateGuideList", void 0);
__decorate([
    Decorator.persistence()
], GuideDataHelper.prototype, "curGuide", void 0);

/**
 * 新手引导服务器模块
 */
class GuideModuleS extends mwext.ModuleS {
    /**
     * 客户端通知服务器，设置当前执行的引导
     * @param guideId 引导id
     */
    net_SetCurrentRunGuide(guideId) {
        this.currentData.setCurGuide(guideId);
    }
    /**
     * 客户端通知服务器，重置所有引导
     */
    net_ResetAllGuide() {
        this.currentData.resetAllGuide();
    }
    /**
     * 客户端通知服务器，重置指定引导存档
     * @param guideId 引导id
     * @returns
     */
    net_ResetGuideAtGuideId(guideId) {
        return this.currentData.resetGuideById(guideId);
    }
    /**
     * 客户端通知服务器，完成引导
     * @param guideId  引导id
     */
    net_ComplateGuide(guideId) {
        //oTrace("完成引导 : " + guideId)
        // 引导是否完成
        if (this.currentData.guideIsComplate(guideId)) {
            return;
        }
        // 完成引导
        this.currentData.complateGuideHandle(guideId);
    }
    /**
     * 引导是否完成
     * @param guideId 引导id
     * @param playerId 玩家id
     * @returns 是否完成
     */
    guideIsComplate(guideId, playerId) {
        return DataCenterS.getData(playerId, GuideDataHelper).guideIsComplate(guideId);
    }
}
__decorate([
    Decorator.noReply()
], GuideModuleS.prototype, "net_SetCurrentRunGuide", null);
__decorate([
    Decorator.noReply()
], GuideModuleS.prototype, "net_ResetAllGuide", null);
__decorate([
    Decorator.noReply()
], GuideModuleS.prototype, "net_ComplateGuide", null);

exports.GuideContent = GuideContent;
exports.GuideDataHelper = GuideDataHelper;
exports.GuideInfo = GuideInfo;
exports.GuideModuleC = GuideModuleC;
exports.GuideModuleS = GuideModuleS;
exports.GuideModuleView = GuideModuleView;
exports.GuideTaskStage = GuideTaskStage;
//# sourceMappingURL=index.js.map
