declare module "module_guide" {
    export class GuideContent {
        /**
         * 引导线Guid，引导线创建的时候所使用到的资源
         */
        static GuideArrowGuid: string;
        /**
         * 引导线材质Guid，引导线创建的hi后所使用到的材质资源
         */
        static GuideArrowMartialGuid: string;
        /**
         * 目的地特效Guid，引导线创建的时候所使用到的目的地的资源
         */
        static GuideWorldTargetEffectGuid: string;
        /**
         * 引导线材质缩放：-1：反向，1：正向，设置引导线材质缩放的方向。
         */
        static GuideMatrialScale: number;
        /**
         * 新手引导UI刷新时间，单位：秒，用于UIMask和需要引导的UI对齐，如果引导的UI位置不变，可以设置为0，但不建议是0。
         */
        static ConstRefrashUITime: number;
        /**
         * 引导线材质更新
         * @param mat 材质
         * @param arrowGo 引导线对象
         * @returns
         */
        static GuideArrowMatrerialUpdate: (mat: mw.MaterialInstance[], go: mw.GameObject) => void;
    }
}

declare module "module_guide" {
    /**
     * 新手引导数据的存储类，用于存储用户完成的引导，以及当前正在进行的引导。
     */
    export class GuideDataHelper extends Subdata {
        /**
         * 引导数据变化事件
         */
        onGuideChangeAction: mw.Action;
        /**
         * 以前老的引导列表存储，废弃掉了。
         */
        complateGuide: number[];
        /**
         * 已经完成的引导列表
         */
        complateGuideList: number[];
        /**
         * 当前正在执行的引导
         */
        curGuide: number;
        get dataName(): string;
        /**
         * 初始化数据
         */
        protected onDataInit(): void;
        /**
         * 初始化默认引导数据。
         */
        protected initDefaultData(): void;
        /**
         * 重置所有引导存档
         */
        resetAllGuide(): void;
        /**
         * 重置引导存档
         * @param guideId
         */
        resetGuideById(guideId: number): boolean;
        /**
         * 完成引导
         * @param guideId 引导id
         */
        complateGuideHandle(guideId: number): void;
        /**
         * 引导是否完成
         * @param guideId 引导id
         * @returns
         */
        guideIsComplate(guideId: number): boolean;
        /**
         * 获取当前引导
         */
        getCurGuide(): number;
        /**
         * 设置当前引导id
         * @param val
         */
        setCurGuide(val: number): void;
    }
}

declare module "module_guide" {
    /**
     * 新手引导服务器模块
     */
    export class GuideModuleS extends mwext.ModuleS<GuideModuleC, GuideDataHelper> {
        /**
         * 客户端通知服务器，设置当前执行的引导
         * @param guideId 引导id
         */
        net_SetCurrentRunGuide(guideId: number): void;
        /**
         * 客户端通知服务器，重置所有引导
         */
        net_ResetAllGuide(): void;
        /**
         * 客户端通知服务器，重置指定引导存档
         * @param guideId 引导id
         * @returns
         */
        net_ResetGuideAtGuideId(guideId: number): boolean;
        /**
         * 客户端通知服务器，完成引导
         * @param guideId  引导id
         */
        net_ComplateGuide(guideId: number): void;
        /**
         * 引导是否完成
         * @param guideId 引导id
         * @param playerId 玩家id
         * @returns 是否完成
         */
        guideIsComplate(guideId: number, playerId: number): boolean;
    }
}

declare module "module_guide" {
    /**
     * 新手引导客户端模块，用于创建引导对象，以及触发引导，提供引导的基础信息配置。
     */
    export class GuideModuleC extends mwext.ModuleC<GuideModuleS, GuideDataHelper> {
        /** 引导线缩放 */
        arrowScale: mw.Vector;
        /**
         * 预设引导信息列表，所有当前创建的引导对象。
         */
        private guideInfoList;
        /**
         * 是否初始化，会在moduleC的onEnterScene中初始化
         */
        private isInit;
        /**
         * 当前正在执行的引导id
         */
        private curGuideIdVal;
        /**
         * 当前正在运行的引导实例
         */
        private runningGuide;
        /**
         * 引导实例完成事件。
         */
        guideComplateAction: mw.Action1<number>;
        /**
         * 重写引导主角对象，默认是本地的玩家角色。如果不是玩家角色，比如是球，或者其他的，需要重写这个对象。
         */
        private _reSetCharGo;
        /**
         * 覆盖到达目标点距离判断 默认50 小于50则到达
         */
        private _reSetToTargetPosDistance;
        /**
         * 引导起始点z偏移，比如引导线希望绑在角色的腰上，那么就需要设置这个偏移。
         */
        private _arrowStartPosOffsetZ;
        /**
         * 引导线起始方向偏移，比如希望从角色前方1米开始引导，那么就需要设置这个偏移。
         */
        private _guideArrowDirOffse;
        /**
         * 引导线Y缩放，设置引导线的宽度。
         */
        private _guideArrowScaleY;
        /**
         * 引导线间隔，用于Pointer模式下，引导点的间隔距离。距离越大Pointer的数量越少
         */
        private _guideArrowIntervalDis;
        /**
         * 引导线地标信息，引导线地标对象Guid，默认 29391
         */
        private _guideArrowPointerGuid;
        /**
         * 引导线地标缩放信息，缩放，默认 (1, 1, 1)
         */
        private _guideArrowPointerScale;
        /**
         * 引导线地标是否粒子效果，默认 否
         */
        private _guideArrowPointerIsEffect;
        /**
         * 引导线最多显示的地标数量，默认 10
         */
        private _guideArrowPointerShowCount;
        /**
         * 引导线地标模式刷新频率，默认 1000 / 30 ，单位毫秒
         */
        private _guideArrowPointerUpdateInterval;
        /**
         * 引导线地标材质更新函数
         */
        private _guideArrowMatrialInit;
        /**
         * 进入场景
         * @param sceneType
         */
        onEnterScene(sceneType: number): void;
        /**
         * 获取引导线地标模式刷新频率，主要用于Pointer的渲染模式
         * @returns
         */
        getGuideArrowPointerUpdateInterval(): number;
        /**
         * 引导线地标模式刷新频率，角色在动，所以需要重新计算寻路路径，这个是刷新频率，单位毫秒，主要用于Pointer的渲染模式
         * @param updateInterval 更新间隔(毫秒)
         */
        setGuideArrowPointerUpdateInterval(updateInterval: number): void;
        /**
         * 获取引导线地标是否粒子效果，主要用于Pointer的渲染模式
         * @returns
         */
        getGuideArrowPointerIsEffect(): boolean;
        /**
         * 获取引导线地标guid，主要用于Pointer的渲染模式
         * @returns
         */
        getGuideArrowPointerGuid(): string;
        /**
         * 获取引导线地标缩放信息，主要用于Pointer的渲染模式
         * @returns
         */
        getGuideArrowPointerScale(): Vector;
        /**
         * 获取引导线最多显示的地标数量，主要用于Pointer的渲染模式
         * @returns
         */
        getGuideArrorShowMaxPointer(): number;
        /**
         * 设置引导线地标信息，主要用于Pointer的渲染模式
         * @param guid 引导线地标对象Guid，默认 29391
         * @param scale 缩放，默认 (1, 1, 1)
         * @param isEffect 是否特效，默认 否
         * @param showPointerCount 最大显示地标数量，默认 10
         * @param matrialUpdate 材质更新函数， 不传不会覆盖默认方法。如果传 boolean 则表示是否反向
         */
        setGuideArrowPointerInfo(guid: string, scale: Vector, isEffect: boolean, showPointerCount: number, matrialUpdate?: boolean | ((matrial: mw.MaterialInstance[], arrowGo: mw.GameObject) => void)): void;
        /**
         * 获取引导线地标生成间隔距离，主要用于Pointer的渲染模式
         * @returns
         */
        getGuideArrowIntervalDis(): number;
        /**
         * 设置引导线地标生成间隔距离，主要用于Pointer的渲染模式
         * @param intervalDis 间隔距离
         */
        setGuideArrowIntervalDis(intervalDis: number): void;
        /**
         * 设置引导线Y缩放
         * @param scaleY 引导线Y缩放
         */
        setGuideArrowScaleY(scaleY: number): void;
        /**
         * 获取引导线Y缩放
         * @returns
         */
        getGuideArrowScaleY(): number;
        /**
         * 设置引导线起始方向 偏移
         * @param distance 偏移距离
         */
        setGuideArrowDirOffset(distance: number): void;
        /**
         * 获取引导线起始方向 偏移
         */
        getGuideArrowDirOffsetDis(): number;
        /**
         * 设置引导线起始坐标 z偏移
         * @param offsetZ z偏移
         */
        setGuideArrowStartPosOffsetZ(offsetZ: number): void;
        /**
         * 获取引导线起始坐标 z偏移
         * @returns
         */
        getGuideArrowStartPosOffsetZ(): number;
        /**
         * 设置引导线 & 目标点特效guid，主要用于Line的渲染模式
         * @param arrowGuid 引导线guid "0"则关闭
         * @param arrowMartialGuid 引导线材质guid "0"则关闭
         * @param targetPointEff 目标点guid "0"则关闭
         */
        setGuideArrowGuid(arrowGuid: string, arrowMartialGuid: string, targetPointEff: string): Promise<void>;
        /**
         * 重置所有引导存档，以及所有引导阶段任务的状态。
         */
        resetAllGuideDB(): Promise<void>;
        /**
         * 重置指定的引导，会重置这个引导的存档状态，以及运行时的状态。
         * @param guideId 引导id
         * @returns 成功/失败
         */
        resetGuideById(guideId: number): Promise<boolean>;
        /**
         * 强制完成一个引导，会添加这个引导的存档状态到已完成。
         * @param guideId 引导id
         * @returns
         */
        forceComplateGuide(guideId: number): Promise<boolean>;
        /**
         * 获取最后一次执行引导时的id
         */
        getLastGuideId(): number;
        /**
         * 获取当前引导id (废弃)
         * @deprecated 获取当前引导Id - 最新使用 getCurGuideId
         * @returns 返回引导id
         */
        getCurStageVal(): number;
        /**
         * 获取当前引导id
         * @returns 返回引导id
         */
        getCurGuideId(): number;
        /**
         * 到达目标点距离判断 默认50 小于50则到达
         * @param dis 目标点判定距离
         */
        reSetToTargetPosDistance(dis: number): void;
        /**
         * 获取到达目标点距离判断 默认50 小于50则到达
         * @returns
         */
        getToTargetPosDistance(): number;
        /**
         * 设置引导主角对象
         * @param go 主角GameObject对象
         */
        reSetCharGo(go: mw.GameObject): void;
        /**
         * 获取引导主角对象
         * @returns
         */
        getCharGo(): Promise<mw.GameObject>;
        /**
         * 初始化引导模块
         */
        private initGuide;
        /**
         * 移除指定引导，但是不影响存档。
         * @param guideId
         */
        removeGuideId(guideId: number): void;
        /**
         * 通过引导ID，添加引导对象实例。
         * @param guideId 引导id - 不要重复
         * @return 引导对象实例
         */
        addGuideStageHandle(guideId: number): GuideInfo;
        /**
         * 通过引导Id，触发指定的引导。同时会将对应引导示例执行起来。
         * @param guideId 引导id
         */
        triggerGuide(guideId: number): boolean;
        /**
         * Tick，用于运行当前的引导实例。
         * @param dt
         */
        onUpdate(dt: number): void;
    }
}

declare module "module_guide" {
    /**
     * AUTO GENERATE BY UI EDITOR.
     * WARNING: DO NOT MODIFY THIS FILE,MAY CAUSE CODE LOST.
     * AUTHOR: 幸好时光与你同在
     * UI: UI/guideModule/GuideModuleUI.ui
     * TIME: 2022.10.25-09.35.32
     */
    export class GuideModuleUI_Generate extends mw.UIScript {
        mLeftMask: mw.StaleButton;
        mTopMask: mw.StaleButton;
        mButtomMask: mw.StaleButton;
        mRightMask: mw.StaleButton;
        mBtn: mw.StaleButton;
        mBtnHand: mw.Image;
        mTextHand: mw.TextBlock;
        protected onAwake(): void;
    }
}

declare module "module_guide" {
    /**
     * 新手引导视图对象
     */
    export class GuideModuleView extends GuideModuleUI_Generate {
        /**
         * 接收空间坐标，用于接收UI本地坐标到视口坐标的转换。
         */
        private _outPixelPos;
        /**
         * 用于接收视口坐标，用于接收UI本地坐标到视口坐标的转换。
         */
        private _outViewPos;
        /**
         * 当前需要引导的目标UI对象
         */
        private _bindTarget;
        /**
         * 按钮触发后的通知
         */
        private _btnClickToGuide;
        /**
         * 按钮触发后的事件传递
         */
        private _btnClickToTarget;
        /**
         * 引导箭头对象，用于显示引导线
         */
        private _guideArrow;
        /**
         * 目标点粒子特效，用于显示目标点
         */
        private _targetPosEff;
        /**
         * 到达目标点后的回调
         */
        private _toTargetPosCallback;
        /**
         * 目标点坐标
         */
        private _targetPos;
        /**
         * 上一次的位置
         */
        private _lastPos;
        /**
         * Pointer渲染模式中，缓存的渲染对象。
         */
        private _cachePointerGo;
        /**
         * 当前引导线的渲染类型
         */
        private _drawType;
        /**
         * 引导线最后更新时间
         */
        private _lastUpdateTime;
        /**
         * 显示/更新 Pointer 的位置。以渲染引导线。
         * @param pos 所有要引导的位置
         */
        private showPointers;

        /**提示偏移 */
        public tipOffset;

        /**
         * 模块初始化，只会调用一次，主要完成一些按钮的监听等操作，以及引导线，目标点特效的初始化。
         */
        onStart(): void;
        /**
         * 隐藏所有的组件
         */
        hideAllItem(): void;
        /**
         * 引导视图UI被显示的时候，会回调该函数，会初始化引导线，以及初始化目标点特效。
         * @param params
         */
        protected onShow(...params: any[]): void;
        /**
         * 引导视图UI的显示隐藏处理。
         * @param isShow
         */
        showMask(isShow: boolean): void;
        /**
         * 引导button点击后的回调，完成当前引导，以及触发对应的点击事件。并且隐藏当前hook的按钮对象。
         */
        private buttonClick;
        /**
         * 设置引导到目标点，会被GuideStage重复调用，通过bUpdateArrow判断是否更新引导线目标点，用于更新引导线的位置，以及目标点特效的位置。
         * @param targetPos 目标点
         * @param callback 回调事件
         */
        setGuideArrowTargetPos(targetPos: mw.Vector, callback: () => boolean, drawType: number, bUpdateArrow: boolean): Promise<void>;
        /**
         * 引导一个UI对象，会用mask将除这个UI对象外的区域全部遮罩起来，并且会生成一个Hook按钮完全遮挡住引导的UI对象，以Hook对应的事件，进行下发。
         * @param target 目标UI对象
         */
        lockMWUIWidget(target: mw.Widget, callback: () => void, tips?: string, isShowBtn?: boolean): void;
    }
}

declare module "module_guide" {
    /**
     * 每个引导任务阶段对象的状态
     */
    enum GuideState {
        /**
         * 拉取任务状态
         * */
        Pull = 0,
        /**
         * 等待完成UI引导状态
         */
        WaitUI = 1,
        /**
         * 等待到达世界坐标状态
         */
        WaitToPos = 2,
        /**
         * 等待完成自定义条件状态
         */
        ConditionRes = 3,
        /**
         * 执行自定义函数状态
         */
        RunFunc = 4,
        /**
         * 完成状态
         */
        Complate = 5
    }
    /**
     * 引导任务的阶段对象，内部会完成当前阶段的一些逻辑，比如UI引导，到达目标点，完成自定义条件等
     */
    export class GuideTaskStage {
        /**
         * 当前任务阶段的状态
         */
        type: GuideState;
        /**
         * 需要引导的UI组件，由外部传入可能是按钮，图片，一个widget的区域等。
         */
        uiWidget: mw.Widget;
        /**
         * 默认刷新dt，引导UI时，要处理mask的对齐，所以需要刷新UI
         */
        refrashDt: number;
        /**
         * 当前刷新UI的dt，用于计算是否需要刷新UI
         */
        curReFrashDt: number;
        /**
         * 需要引导到达的位置,世界坐标
         */
        toWorldPos: mw.Vector;
        /**
         * UI完成需要检测的条件,如果不为空，会在每次刷新UI的时候，检测条件是否满足，如果满足，会直接完成当前阶段的引导任务。
         */
        uiCheckCondition: () => boolean;
        /**
         * 完成需要检测的条件,如果不为空，会在当前阶段任务每次刷新的时候执行checkCondition，如果满足，会直接完成当前阶段的引导任务。
         */
        checkCondition: Array<() => boolean>;
        /**
         * 引导UI时的提示语言,如果为空，不会显示提示语言,否则会在对应需要引导的区域显示对应的tips。
         */
        tips: string;
        /**
         * 寻路线段渲染方式,默认为0，如果时line的模式则是用一个支持平铺的材质去调整scale进行平铺，如果是point会生成多个gameobject，去表达寻路的线段。
         * 0 为line 1为point
         */
        drawType: number;
        /**
         * 需要执行的自定义函数,如果不为空，会在当前阶段被调起的时候执行自定义函数。执行后完成当前任务。
         */
        runFuncs: Array<() => void>;
        /**
         * 复制一个引导任务阶段
         * @returns
         */
        copy(): GuideTaskStage;
        /**
         * 创建引导任务阶段，根据传入的GuideState去判断创建的类型，可以创建引导UI，到达目标点，完成自定义条件，执行自定义函数等任务。
         * @param type 类型
         * @param condition 条件
         */
        static newGuideTaskStage(type: GuideState, condition: mw.Widget | mw.Vector | Array<() => boolean>, runFuncs?: Array<() => void>, uiConditionRes?: () => boolean): GuideTaskStage;
    }
    /**
     * 引导信息，一个引导信息包含了引导的所有阶段，每个阶段都是一个GuideTaskStage对象。通过多个引导阶段的任务来表示一个引导信息。多个引导信息组成一个完成的引导系统。
     */
    export class GuideInfo {
        /**
         * 引导信息id。
         */
        guideStage: number;
        /**
         * 当前引导信息还需要执行的所有引导阶段的任务，执行完成一个则会删除一个。
         */
        private taskStage;
        /**
         * 源引导列表，存储了当前引导信息中所有需要完成的引导阶段的任务，用于可以重置当前引导。
         */
        private srcStage;
        /**
         * 当前引导状态，用于标识内部执行逻辑的状态。
         */
        private curState;
        /**
         * 引导完成后的通知，会传入当前引导的id。
         */
        private complateNotify;
        /**
         *
         * @param complateNotify 引导完成后的通知，会传入当前引导的id。
         */
        constructor(complateNotify: mw.Action1<number>);
        /**
         * 添加一个引导UI的阶段，并且同时添加一个完成条件，当UI引导完成后，会检测完成条件，如果满足则会直接完成当前阶段的引导任务。
         * @param widget 需要引导的UI
         * @param condition 完成条件
         * @returns
         */
        addBindUIByCondition(widget: mw.Widget, condition: () => boolean): GuideInfo;
        /**
         * 添加一个引导UI的阶段，并且同时添加一个完成条件，在引导的过程中显示对应的tips,当UI引导完成后，会检测完成条件，如果满足则会直接完成当前阶段的引导任务。
         * @param widget 需要引导的UI
         * @param tips 引导提示语言
         * @param condition 完成条件
         * @returns
         */
        addBindUIAndTipsByCondition(widget: mw.Widget, tips: string, condition: () => boolean): GuideInfo;
        /**
         * 添加多个引导UI的阶段，可以传入多个UI，每个UI会创建一个引导阶段的任务，按顺序压入，完成一个会删除一个。这样会按顺序引导多个UI。
         * @param widgets 需要顺序引导的多个UI
         * @returns
         */
        addBindUI(...widgets: mw.Widget[]): GuideInfo;
        /**
         * 添加一个引导UI的阶段，引导UI时会显示对应的tips
         * @param widget 需要引导的UI
         * @param tips 引导UI时的提示信息
         * @returns
         */
        addBindUIAndTips(widget: mw.Widget, tips: string): GuideInfo;
        /**
         * 添加多个引导UI的阶段，可以传入多个UI，每个UI会创建一个引导阶段的任务，按顺序压入，完成一个会删除一个。这样会按顺序引导多个UI。并且引导这些UI的时候会总是刷新Mask的位置，因为这些UI可能是动态的。
         * @param widgets 需要顺序引导的多个UI
         * @returns
         */
        addBindUIAlawaysRefrash(...widgets: mw.Widget[]): GuideInfo;
        /**
         * 添加多个目的地坐标，按顺序压入，完成一个会删除一个。这样会按顺序引导到多个目的地。并且会以line的方式渲染寻路线段。
         * @param poslist 多个目的地坐标
         * @returns
         */
        addBindWorldPos(...poslist: mw.Vector[]): GuideInfo;
        /**
         * 添加一个目的地坐标，引导到达目的地后，会检测完成条件，如果满足则会直接完成当前阶段的引导任务。并且会以line的方式渲染寻路线段。
         * @param poslist 多个目的地坐标
         * @param callback 自定义通过条件
         * @returns
         */
        addBindWorldPosByCondition(poslist: mw.Vector, callback: () => boolean): GuideInfo;
        /**
         * 添加多个目的地坐标，按顺序压入，完成一个会删除一个。这样会按顺序引导到多个目的地。并且会以Pointer的方式渲染寻路线段。
         * @param poslist 多个目的地坐标
         * @returns
         */
        addBindWorldPos_Pointer(...poslist: mw.Vector[]): GuideInfo;
        /**
         * 添加一个目的地坐标，引导到达目的地后，会检测完成条件，如果满足则会直接完成当前阶段的引导任务。并且会以Pointer的方式渲染寻路线段。
         * @param poslist 坐标
         * @param callback 自定义通过条件
         * @returns
         */
        addBindWorldPosByCondition_Pointer(poslist: mw.Vector, callback: () => boolean): GuideInfo;
        /**
         * 添加多个判断条件，按顺序压入，会顺序执行每个自定义判断条件的引导阶段任务，完成一个删除一个，直到所有的自定义判断条件都满足，才会完成当前引导阶段的任务。
         * @param conditions 多个判断条件
         * @returns
         */
        addCondition(...conditions: (() => boolean)[]): GuideInfo;
        /**
         * 添加多个自定义执行函数，按顺序压入，会顺序执行每个自定义执行函数的引导阶段任务，完成一个删除一个，直到所有的自定义执行函数都执行完成，才会完成当前引导阶段的任务。
         * @param func 多个执行函数
         */
        addRunFunc(...funcs: (() => void)[]): GuideInfo;
        /**
         * 重置所有引导阶段，会重新拉取一次所有的引导阶段任务，用于引导失败后，重新拉取引导阶段。
         */
        resetAllStage(): void;
        /**
         * 获取当前引导任务，如果没有任务则返回null
         * @returns
         */
        getCurTask(): GuideTaskStage;
        /**
         * 执行引导任务，每帧执行一次，内部会根据当前引导任务的状态，去执行对应的逻辑。比如是该拉取一个引导任务，还是应该等待当前引导任务完成。或者检查是否到达目标点，或者检查是否完成自定义条件等。
         */
        handle(dt: number): void;
        /**
         * 拉取一个引导任务，如果拉取不到任务，则会完成当前引导。
         */
        private pullTask;
        /**
         * 检查自定义条件是否满足
         * @returns
         */
        checkCondition(): boolean;
        /**
         * UI任务触发完成后的回调，比如引导一个UI，要等用户点触对应的UI区域时，才会回调当前函数来标注当前引导阶段任务的完成。
         */
        private onUITaskCallback;
        /**
         * 引导到目标地点后的回调，比如引导一个目的地，需要等用户到达目的地后，才会回调当前函数来标注当前引导阶段任务的完成。
         */
        private onWorldToPosTaskCallback;
        /**
         * 开始UI引导任务，会锁定对应的UI，当用户点击对应的UI区域时，会回调onUITaskCallback函数来标注当前引导阶段任务的完成。
         * @param widget 要引导点击的目标UI对象或区域
         */
        private beginUITask;
        /**
         * 开始引导到达目标点的任务，会显示对应的寻路线段，当用户到达目标点后，会回调onWorldToPosTaskCallback函数来标注当前引导阶段任务的完成。
         * @param toPos 目标点
         */
        private beginToWorldPosTask;
    }
}
