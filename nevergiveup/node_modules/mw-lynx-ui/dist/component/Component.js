import Gtk, { Delegate } from 'gtoolkit';

const rootComponentMap = new Map();
class Component {
    constructor() {
        this._componentChildren = new Set();
        this._destroyed = false;
        //#region Anim
        this.renderAnim = (dt) => {
            if (this._root && this._root.visible) {
                this.renderAnimHandler(dt);
            }
        };
        //#endregion
        //#region Event
        this.onAttach = new Delegate.SimpleDelegate().setProtected();
        this.onDetach = new Delegate.SimpleDelegate().setProtected();
        this.onDestroy = new Delegate.SimpleDelegate().setProtected();
        //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
    }
    static create() {
        throw new Error("not implemented.");
    }
    static defaultOption() {
        throw new Error("not implemented.");
    }
    static destroyObject(component) {
        component._destroyed = true;
        component.onDestroy.invoke();
        rootComponentMap.get(component.root.parent)?._componentChildren.delete(component);
        for (const componentChild of component._componentChildren.values()) {
            componentChild.destroy();
        }
        if (component.renderAnimHandler) {
            mw.TimeUtil.onEnterFrame.remove(component.renderAnim);
        }
        component.destruct();
        component._root.constructor.prototype.destroyObject.call(component._root);
        rootComponentMap.delete(component.root);
    }
    get destroyed() {
        return this._destroyed;
    }
    initRoot(_root) {
        this._root = _root ? _root :
            mw.Canvas.newObject(undefined, "root");
        rootComponentMap.set(this._root, this);
        this._root.visibility = mw.SlateVisibility.SelfHitTestInvisible;
        if (this._root.destroyObject === this._root.constructor.prototype.destroyObject) {
            this._root.destroyObject = () => {
                Component.destroyObject(this);
            };
        }
        if (this.renderAnimHandler) {
            mw.TimeUtil.onEnterFrame.add(this.renderAnim);
        }
    }
    get name() {
        return this.constructor.name;
    }
    get root() {
        if (!this._root)
            this.initRoot();
        return this._root;
    }
    setLayout(option) {
        if (this._root) {
            if (option.zOrder !== undefined)
                this._root.zOrder = option.zOrder;
            Gtk.setUiSize(this._root, option.size.x, option.size.y);
        }
        return this;
    }
    destruct() {
    }
    attach(canvas) {
        if (this._root?.parent)
            this.detach();
        if (canvas instanceof mw.Canvas) {
            canvas.addChild(this._root);
            traceComponentParent(canvas)?._componentChildren.add(this);
        }
        else {
            canvas.root.addChild(this._root);
            canvas._componentChildren.add(this);
        }
        this.onAttach.invoke();
        return this;
    }
    detach() {
        if (!this._root?.parent)
            return;
        this.onDetach.invoke();
        rootComponentMap.get(this.root)
            ?._componentChildren.delete(this);
        this._root?.removeObject();
    }
    destroy() {
        if (this._destroyed)
            return;
        this._root?.destroyObject();
    }
}
/**
 * 追溯 Widget 的首个祖先组件.
 * @param {mw.Widget} widget
 * @return {Component | undefined}
 */
function traceComponentParent(widget) {
    let focus = widget;
    while (focus) {
        if (rootComponentMap.has(focus))
            return rootComponentMap.get(focus);
        focus = focus.parent;
    }
    return undefined;
}
/**
 * Extract layout from option.
 * @param {ComponentOption} option
 * @returns {[
 * [number, number],
 * [number, number, number, number],
 * [number, number]
 * ]}
 *      [x,y]
 *      [pt, pr, pb, pl]
 *      [x - pl - pr, y - pt - pb]
 */
function extractLayoutFromOption(option) {
    const [x, y] = [option.size.x, option.size.y];
    const [pt, pr, pb, pl] = [option.padding.top ?? 0,
        option.padding.right ?? 0,
        option.padding.bottom ?? 0,
        option.padding.left ?? 0,
    ];
    return [[x, y],
        [pt, pr, pb, pl],
        [x - pl - pr, y - pt - pb]];
}
/**
 * Override layout option.
 * @param {ComponentOption} self
 * @param {ComponentOption} from
 * @returns {ComponentOption}
 */
function overrideOption(self, from) {
    if (self === from)
        return;
    if (from?.zOrder !== undefined)
        self.zOrder = from.zOrder;
    if (from?.size !== undefined) {
        if (from.size.x !== undefined)
            self.size.x = from.size.x;
        if (from.size.y !== undefined)
            self.size.y = from.size.y;
    }
    if (from?.padding) {
        if (from.padding.top !== undefined)
            self.padding.top = from.padding.top;
        if (from.padding.right !== undefined)
            self.padding.right = from.padding.right;
        if (from.padding.bottom !== undefined)
            self.padding.bottom = from.padding.bottom;
        if (from.padding.left !== undefined)
            self.padding.left = from.padding.left;
    }
    return self;
}
/**
 * 获取 root 为 Canvas 的组件.
 * @param {mw.Canvas} root
 * @returns {Component | undefined}
 */
function getComponentFromRoot(root) {
    return rootComponentMap.get(root);
}
let lastTouchActivePosition = [];
let touchActive = [];
function updateLastTouchActivePosition(index, x, y) {
    if (lastTouchActivePosition[index])
        lastTouchActivePosition[index] = new mw.Vector2();
    lastTouchActivePosition[index].set(x, y);
}
/**
 * Get last touch active position.
 * @param {number} index
 * @return {mw.Vector2 | undefined}
 */
function getLastTouchActivePosition(index) {
    return lastTouchActivePosition[index];
}
/**
 * Check if touch is active.
 * @param {number} index
 * @return {boolean}
 */
function isTouchActive(index) {
    return touchActive[index] ?? false;
}
/**
 * Get click position on platform.
 * @return {mw.Vector2 | undefined}
 */
function getClickPositionOnPlatform() {
    return Gtk.useMouse ?
        mw.getMousePositionOnPlatform() :
        getLastTouchActivePosition(0);
}
if (mw.SystemUtil.isClient()) {
    mw.InputUtil?.["onRawTouchBegin"]?.()?.add((index, location) => {
        updateLastTouchActivePosition(index, location.x, location.y);
        touchActive[index] = true;
    });
    mw.InputUtil?.["onRawTouchMove"]?.()?.add((index, location) => {
        updateLastTouchActivePosition(index, location.x, location.y);
    });
    mw.InputUtil?.["onRawTouchEnd"]?.()?.add((index) => {
        touchActive[index] = false;
    });
}

export { Component, extractLayoutFromOption, getClickPositionOnPlatform, getComponentFromRoot, getLastTouchActivePosition, isTouchActive, overrideOption };
//# sourceMappingURL=Component.js.map
