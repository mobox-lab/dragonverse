'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

class CProxy {
    binder;
    players = [];
    constructor(binder) {
        this.binder = binder;
        if (SystemUtil.isClient()) {
            mw.Event.addServerListener("Console.onConsole", this.onClientConsole.bind(this));
        }
        else {
            mw.Event.addClientListener("Console.Player.Attach", (player, isAttach, isMonitorServer) => {
                if (isAttach) {
                    this.attachPlayer(player, isMonitorServer);
                }
                else {
                    this.deatachPlayer(player);
                }
            });
            mw.Player.onPlayerLeave.add((player) => {
                this.deatachPlayer(player);
            });
        }
    }
    onClientConsole(level, text) {
        UE.MWCommonTypeScriptMethods.MWLibLog(level, text);
    }
    sendConsole(level, text) {
        this.players.forEach(player => {
            mw.Event.dispatchToClient(player, "Console.onConsole", level, `[Server]: ${text}`);
        });
    }
    deatachPlayer(player) {
        if (SystemUtil.isClient()) {
            mw.Event.dispatchToServer("Console.Player.Attach", false);
        }
        else {
            const index = this.players.findIndex(p => p.playerId == player.playerId);
            if (index >= 0) {
                this.players.splice(index, 1);
                if (this.players.length == 0) {
                    this.binder.unBind();
                }
            }
        }
    }
    attachPlayer(player, isMonitorServer) {
        if (SystemUtil.isClient()) {
            mw.Event.dispatchToServer("Console.Player.Attach", true, isMonitorServer);
        }
        else {
            const index = this.players.findIndex(p => p.playerId == player.playerId);
            if (index < 0) {
                this.players.push(player);
            }
            isMonitorServer && this.binder.bind(isMonitorServer);
        }
    }
}

exports.CTemp = void 0;
(function (CTemp) {
    CTemp.V2 = new mw.Vector2();
    CTemp.ConstraintFill = new mw.UIConstraintAnchors(UIConstraintHorizontal.LeftRight, UIConstraintVertical.TopBottom);
    CTemp.ConstraintLeftFill = new mw.UIConstraintAnchors(UIConstraintHorizontal.Left, UIConstraintVertical.TopBottom);
    CTemp.MaxMessageCount = 1000;
    CTemp.Actions = {
        onConsole: new Action2(),
        onClose: new Action(),
    };
})(exports.CTemp || (exports.CTemp = {}));

class CConsole {
    originConsole;
    proxy;
    isBind = false;
    originConsoleFunc = {
        error: null,
        info: null,
        log: null,
        warn: null,
        ueLog: null,
        isShipping: false
    };
    constructor(originConsole) {
        this.originConsole = originConsole;
        const inst = puerts.argv.getByName("Proxy");
        this.proxy = new CProxy(this);
        this.originConsoleFunc.isShipping = inst.IsShipping;
        this.originConsoleFunc.error = this.originConsole.error;
        this.originConsoleFunc.info = this.originConsole.info;
        this.originConsoleFunc.log = this.originConsole.log;
        this.originConsoleFunc.warn = this.originConsole.warn;
        this.originConsoleFunc.ueLog = UE.MWCommonTypeScriptMethods.MWLibLog;
    }
    bind(isMonitorServer) {
        if (this.isBind)
            return;
        this.isBind = true;
        if (SystemUtil.isClient()) {
            this.proxy.attachPlayer(Player.localPlayer, isMonitorServer);
            const inst = puerts.argv.getByName("Proxy");
            inst.IsShipping = false;
        }
        this.originConsole.error = this.error.bind(this);
        this.originConsole.info = this.info.bind(this);
        this.originConsole.log = this.log.bind(this);
        this.originConsole.warn = this.warn.bind(this);
        UE.MWCommonTypeScriptMethods.MWLibLog = this.ueLog.bind(this);
        this.error(`调试控制台已开启,Shipping=${this.originConsoleFunc.isShipping},Version=${SystemUtil.getFullEditorVersion()}`);
    }
    unBind() {
        if (!this.isBind)
            return;
        this.isBind = false;
        if (SystemUtil.isClient()) {
            const inst = puerts.argv.getByName("Proxy");
            inst.IsShipping = this.originConsoleFunc.isShipping;
        }
        this.proxy.deatachPlayer(Player.localPlayer);
        this.originConsole.error = this.originConsoleFunc.error;
        this.originConsole.info = this.originConsoleFunc.info;
        this.originConsole.log = this.originConsoleFunc.log;
        this.originConsole.warn = this.originConsoleFunc.warn;
        UE.MWCommonTypeScriptMethods.MWLibLog = this.originConsoleFunc.ueLog;
    }
    ueLog(level, text) {
        this.originConsoleFunc.ueLog(level, text);
        switch (level) {
            case 0:
                this.info(text);
                break;
            case 1:
                this.log(text);
                break;
            case 2:
                this.warn(text);
                break;
            case 3:
                this.error(text);
                break;
        }
    }
    error(...data) {
        this.originConsoleFunc.error(...data);
        exports.CTemp.Actions.onConsole.call(3, data);
        if (SystemUtil.isServer()) {
            this.proxy.sendConsole(3, data.length == 1 ? data[0] : data.join(","));
        }
    }
    info(...data) {
        this.originConsoleFunc.info(...data);
        exports.CTemp.Actions.onConsole.call(0, data);
        if (SystemUtil.isServer()) {
            this.proxy.sendConsole(0, data.length == 1 ? data[0] : data.join(","));
        }
    }
    log(...data) {
        this.originConsoleFunc.log(...data);
        exports.CTemp.Actions.onConsole.call(1, data);
        if (SystemUtil.isServer()) {
            this.proxy.sendConsole(1, data.length == 1 ? data[0] : data.join(","));
        }
    }
    warn(...data) {
        this.originConsoleFunc.warn(...data);
        exports.CTemp.Actions.onConsole.call(2, data);
        if (SystemUtil.isServer()) {
            this.proxy.sendConsole(2, data.length == 1 ? data[0] : data.join(","));
        }
    }
}

class UIBehivor extends mw.UIScript {
    colors = [mw.LinearColor.gray, mw.LinearColor.white, mw.LinearColor.yellow, mw.LinearColor.red];
    renderLines = [];
    contentCanvas;
    scroller;
    isPause = false;
    onStart() {
        const baseCanvas = mw.Canvas.newObject(this.rootCanvas);
        baseCanvas.size = exports.CTemp.V2.set(600, 1080);
        baseCanvas.constraints = exports.CTemp.ConstraintLeftFill;
        this.createBg(baseCanvas);
        this.createScroller(baseCanvas);
        this.createButtons(baseCanvas);
        this.bindEvents();
    }
    bindEvents() {
        exports.CTemp.Actions.onConsole.add((type, args) => {
            this.canUpdate = true;
            const tb = mw.TextBlock.newObject();
            tb.fontSize = 20;
            tb.text = args.join(" ");
            this.renderLines.push({ type: type, time: 0, textBlock: tb });
        });
    }
    createText(type, textBlock) {
        if (this.contentCanvas.getChildrenCount() > exports.CTemp.MaxMessageCount) {
            this.contentCanvas.removeChildAt(0);
        }
        this.contentCanvas.addChild(textBlock);
        textBlock.size = exports.CTemp.V2.set(580, 0);
        textBlock.constraints = exports.CTemp.ConstraintLeftFill;
        textBlock.fontColor = this.colors[type];
        textBlock.textHorizontalLayout = mw.UITextHorizontalLayout.AutoWarpText;
        textBlock.textVerticalAlign = mw.TextVerticalJustify.Top;
        textBlock.textAlign = mw.TextJustify.Left;
        return textBlock;
    }
    onUpdate(dt) {
        if (this.renderLines.length > 0) {
            const { type, time, textBlock } = this.renderLines[0];
            if (time == 0) {
                this.renderLines[0].textBlock = this.createText(type, textBlock);
                this.renderLines[0].time += dt;
            }
            else if (time > 0.1) {
                const size = this.renderLines[0].textBlock.desiredSize;
                this.renderLines[0].textBlock.size = size;
                !this.isPause && this.scroller.scrollToEnd();
                this.renderLines.shift();
                if (this.renderLines.length == 0) {
                    this.canUpdate = false;
                }
            }
            else {
                this.renderLines[0].time += dt;
            }
        }
    }
    createButtons(baseCanvas) {
        const closeBtn = mw.Button.newObject(this.rootCanvas);
        closeBtn.size = exports.CTemp.V2.set(100, 100);
        closeBtn.normalImageGuid = "120734";
        closeBtn.position = exports.CTemp.V2.set(600, 0);
        closeBtn.onClicked.add(() => {
            baseCanvas.visibility = baseCanvas.visible ? mw.SlateVisibility.Collapsed : mw.SlateVisibility.SelfHitTestInvisible;
            closeBtn.normalImageGuid = baseCanvas.visible ? "120734" : "128703";
        });
        const pauseBtn = mw.Button.newObject(baseCanvas);
        pauseBtn.size = exports.CTemp.V2.set(100, 100);
        pauseBtn.normalImageGuid = "98222";
        pauseBtn.position = exports.CTemp.V2.set(600, 100);
        pauseBtn.onClicked.add(() => {
            this.isPause = !this.isPause;
            pauseBtn.normalImageGuid = this.isPause ? "132509" : "98222";
        });
    }
    createScroller(baseCanvas) {
        const scroller = mw.ScrollBox.newObject(baseCanvas);
        scroller.size = exports.CTemp.V2.set(600, 1080);
        scroller.constraints = exports.CTemp.ConstraintFill;
        this.scroller = scroller;
        const content = mw.Canvas.newObject();
        scroller.addChild(content);
        content.size = exports.CTemp.V2.set(600, 1080);
        content.constraints = exports.CTemp.ConstraintFill;
        content.autoLayoutEnable = true;
        content.autoLayoutContainerRule = mw.UILayoutType.Vertical;
        content.autoLayoutSpacing = 10;
        content.autoLayoutHugContent = new mw.UIHugContent(mw.UIHugContentHorizontally.FixWidth, mw.UIHugContentVertically.HugContent);
        this.contentCanvas = content;
    }
    createBg(baseCanvas) {
        const bg = mw.Image.newObject(baseCanvas);
        bg.size = exports.CTemp.V2.set(600, 1080);
        bg.constraints = exports.CTemp.ConstraintFill;
        bg.imageGuid = "164191";
        bg.imageColor = mw.LinearColor.black;
        bg.renderOpacity = 0.4;
    }
}

class UIX {
    /**
     * ui载体
     */
    ui;
    showMainPanel() {
        this.bindScript();
        UIService.showUI(this.ui);
    }
    hideMainPanel() {
        UIService.hideUI(this.ui);
        this.ui.destroy();
    }
    bindScript() {
        const script = mw.createUI("", UIBehivor);
        script.rootCanvas.size = exports.CTemp.V2.set(1920, 1080);
        script.rootCanvas.constraints = exports.CTemp.ConstraintFill;
        this.ui = script;
    }
}

/**
 * 调试控制台
 */
exports.DebugConsole = void 0;
(function (DebugConsole) {
    const cConsole = new CConsole(console);
    const uix = new UIX();
    /**
     * 最大消息数量
     */
    DebugConsole.maxMessageCount = 1000;
    let isStart = false;
    function init() {
        exports.CTemp.Actions.onClose.add(() => { stop(); });
    }
    /**
     * 开启调试控制
     * @param isMonitorServer
     * @effect 仅在客户端调用生效
     * ```
     * 是否监控服务器
     * *如果监控服务器RPC会增高
     * ```
     */
    function start(isMonitorServer) {
        if (SystemUtil.isPIE)
            return;
        if (SystemUtil.isClient()) {
            exports.CTemp.MaxMessageCount = DebugConsole.maxMessageCount;
            if (isStart)
                return;
            isStart = true;
            uix.showMainPanel();
            cConsole.bind(isMonitorServer);
        }
    }
    DebugConsole.start = start;
    /**
     * 停止调试控制
     * @effect 仅在客户端调用生效
     */
    function stop() {
        if (SystemUtil.isPIE)
            return;
        if (SystemUtil.isClient()) {
            if (!isStart)
                return;
            isStart = false;
            uix.hideMainPanel();
            cConsole.unBind();
        }
    }
    DebugConsole.stop = stop;
    init();
})(exports.DebugConsole || (exports.DebugConsole = {}));

class RenderLine {
    type;
    time = 0;
    textBlock;
}

exports.CConsole = CConsole;
exports.CProxy = CProxy;
exports.RenderLine = RenderLine;
exports.UIBehivor = UIBehivor;
exports.UIX = UIX;
//# sourceMappingURL=index.js.map
