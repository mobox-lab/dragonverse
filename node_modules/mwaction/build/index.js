var __reflect = (globalThis && globalThis.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var actions;
(function (actions) {
    const TAG_INVALID = "none";
    class BaseAction {
        constructor() {
            this._tag = TAG_INVALID;
            this._target = null;
            this._originalTarget = null;
            this._duration = 0;
        }
        get target() {
            return this._target;
        }
        set target(value) {
            this._target = value;
        }
        getOriginalTarget() {
            return this._originalTarget;
        }
        startWithTarget(target) {
            this._originalTarget = target;
            this._target = target;
        }
        get originalTarget() {
            return this._originalTarget;
        }
        set tag(value) {
            this._tag = value;
        }
        get tag() {
            return this._tag;
        }
        stop() {
            this._target = null;
        }
        release() {
            this._target = null;
            this._originalTarget = null;
        }
        get duration() {
            return this._duration;
        }
    }
    actions.BaseAction = BaseAction;
    __reflect(BaseAction.prototype, "actions.BaseAction");
})(actions || (actions = {}));
var actions;
(function (actions) {
    class FiniteTimeAction extends actions.BaseAction {
        constructor(duration) {
            super();
            this.initWithDuration(duration);
        }
        initWithDuration(d) {
            this._duration = d;
        }
    }
    actions.FiniteTimeAction = FiniteTimeAction;
    __reflect(FiniteTimeAction.prototype, "actions.FiniteTimeAction", ["actions.IAction"]);
})(actions || (actions = {}));
var actions;
(function (actions) {
    class InstanceAction extends actions.FiniteTimeAction {
        constructor() {
            super(0);
        }
        step(dt) {
            this.update(1);
        }
        isDone() {
            return true;
        }
    }
    actions.InstanceAction = InstanceAction;
    __reflect(InstanceAction.prototype, "actions.InstanceAction", ["actions.IAction"]);
})(actions || (actions = {}));
var actions;
(function (actions) {
    const FLT_EPSILON = 0.0000001192092896;
    class IntervalAction extends actions.FiniteTimeAction {
        constructor(duration) {
            super(duration);
            this._elapsed = 0;
            this._isFirstTick = false;
        }
        /**
         *
         * @param d
         * @returns
         */
        initWithDuration(d) {
            d = d === 0 ? FLT_EPSILON : d;
            super.initWithDuration(d);
            this._elapsed = 0;
            this._isFirstTick = true;
            return true;
        }
        isDone() {
            return this._elapsed >= this.duration;
        }
        step(dt) {
            if (this._isFirstTick) {
                this._isFirstTick = false;
                this._elapsed = 0;
            }
            else {
                this._elapsed += dt;
            }
            var t = this._elapsed / (this.duration > FLT_EPSILON ? this.duration : FLT_EPSILON);
            t = 1 > t ? t : 1;
            this.update(t > 0 ? t : 0);
        }
        startWithTarget(target) {
            super.startWithTarget(target);
            this._elapsed = 0;
            this._isFirstTick = true;
        }
        computeEaseTime(dt) {
            return dt;
        }
        get elapsed() {
            return this._elapsed;
        }
    }
    actions.IntervalAction = IntervalAction;
    __reflect(IntervalAction.prototype, "actions.IntervalAction");
})(actions || (actions = {}));
var actions;
(function (actions) {
    class SetAction extends actions.InstanceAction {
        constructor(props) {
            super();
            this._props = {};
            this._originProps = Object.create(null);
            props !== undefined && this.init(props);
        }
        init(props) {
            for (var name in props) {
                this._props[name] = props[name];
            }
            return true;
        }
        update(dt) {
            var props = this._props;
            var target = this.target;
            for (var name in props) {
                this._originProps[name] = target[name];
                target[name] = props[name];
            }
        }
        clone() {
            let action = new SetAction();
            action.init(this._props);
            return action;
        }
        reverse() {
            let ret = new SetAction(this._originProps);
            return ret;
        }
        release() {
            this._originProps = null;
            this._props = null;
        }
    }
    actions.SetAction = SetAction;
    __reflect(SetAction.prototype, "actions.SetAction");
})(actions || (actions = {}));
var actions;
(function (actions) {
    class HashElement {
        constructor() {
            this.actions = [];
            this.target = null;
            this.actionIndex = 0;
            this.paused = false;
            this.lock = false;
        }
    }
    __reflect(HashElement.prototype, "HashElement");
    class ActionManager {
        constructor() {
            this._elementPool = [];
            this._hashTargets = {};
            this._arrayTargets = [];
            this._currentTarget = null;
        }
        // private searchElementByTarget(arr, target) {
        //     for (var k = 0; k < arr.length; k++) {
        //         if (target === arr[k].target)
        //             return arr[k];
        //     }
        //     return null;
        // }
        getElement(target, paused) {
            let element = this._elementPool.pop();
            if (!element) {
                element = new HashElement();
            }
            element.target = target;
            element.paused = !!paused;
            return element;
        }
        putElement(element) {
            element.actions.length = 0;
            element.actionIndex = 0;
            element.currentAction = null;
            element.paused = false;
            element.target = null;
            element.lock = false;
            this._elementPool.push(element);
        }
        addAction(action, target, paused) {
            if (!action || !target) {
                return;
            }
            let element = this._hashTargets[target.__signActionId];
            if (!element) {
                element = this.getElement(target, paused);
                this._hashTargets[target.__signActionId] = element;
                this._arrayTargets.push(element);
            }
            else if (!element.actions) {
                element.actions = [];
            }
            element.actions.push(action);
            action.startWithTarget(target);
        }
        removeAllActions() {
            let locTargets = this._arrayTargets;
            for (let i = 0; i < locTargets.length; i++) {
                let element = locTargets[i];
                if (element) {
                    this.putElement(element);
                }
            }
            this._arrayTargets.length = 0;
            this._hashTargets = {};
        }
        removeAllActionsFromTarget(target) {
            if (target == null)
                return;
            var element = this._hashTargets[target.__signActionId];
            if (element) {
                element.actions.length = 0;
                this.deleteHashElement(element);
            }
        }
        removeAction(action) {
            if (!action) {
                return;
            }
            let target = action.originalTarget;
            let element = this._hashTargets[target.__signActionId];
            if (!element) {
                return;
            }
            for (var i = 0; i < element.actions.length; i++) {
                if (element.actions[i] === action) {
                    element.actions.splice(i, 1);
                    if (element.actionIndex >= i)
                        element.actionIndex--;
                    break;
                }
            }
            action.release();
        }
        _removeActionByTag(tag, element, target) {
            for (var i = 0, l = element.actions.length; i < l; ++i) {
                var action = element.actions[i];
                if (action && action.tag === tag) {
                    if (target && action.originalTarget !== target) {
                        continue;
                    }
                    this._removeActionAtIndex(i, element);
                    break;
                }
            }
        }
        removeActionByTag(tag, target) {
            if (tag === "none")
                return;
            var hashTargets = this._hashTargets;
            if (target) {
                var element = hashTargets[target.__signActionId];
                if (element) {
                    this._removeActionByTag(tag, element, target);
                }
            }
            else {
                for (var name in hashTargets) {
                    var _element = hashTargets[name];
                    this._removeActionByTag(tag, _element);
                }
            }
        }
        getActionByTag(tag, target) {
            if (tag === "none")
                return;
            var element = this._hashTargets[target.__signActionId];
            if (element) {
                if (element.actions != null) {
                    for (var i = 0; i < element.actions.length; ++i) {
                        var action = element.actions[i];
                        if (action && action.tag === tag)
                            return action;
                    }
                }
            }
            return null;
        }
        getNumberOfRunningActionsInTarget(target) {
            var element = this._hashTargets[target.__signActionId];
            if (element)
                return element.actions ? element.actions.length : 0;
            return 0;
        }
        pauseTarget(target) {
            var element = this._hashTargets[target.__signActionId];
            if (element)
                element.paused = true;
        }
        resumeTarget(target) {
            var element = this._hashTargets[target.__signActionId];
            if (element)
                element.paused = false;
        }
        pauseAllRunningActions() {
            var idsWithActions = [];
            var locTargets = this._arrayTargets;
            for (var i = 0; i < locTargets.length; i++) {
                var element = locTargets[i];
                if (element && !element.paused) {
                    element.paused = true;
                    idsWithActions.push(element.target);
                }
            }
            return idsWithActions;
        }
        resumeTargets(targetsToResume) {
            if (!targetsToResume)
                return;
            for (var i = 0; i < targetsToResume.length; i++) {
                if (targetsToResume[i])
                    this.resumeTarget(targetsToResume[i]);
            }
        }
        pauseTargets(targetsToPause) {
            if (!targetsToPause)
                return;
            for (var i = 0; i < targetsToPause.length; i++) {
                if (targetsToPause[i])
                    this.pauseTarget(targetsToPause[i]);
            }
        }
        _removeActionAtIndex(index, element) {
            var action = element.actions[index];
            element.actions.splice(index, 1);
            if (element.actionIndex >= index)
                element.actionIndex--;
            if (element.actions.length === 0) {
                this.deleteHashElement(element);
            }
        }
        deleteHashElement(element) {
            var ret = false;
            if (element && !element.lock) {
                if (this._hashTargets[element.target.__signActionId]) {
                    delete this._hashTargets[element.target.__signActionId];
                    var targets = this._arrayTargets;
                    for (var i = 0, l = targets.length; i < l; i++) {
                        if (targets[i] === element) {
                            targets.splice(i, 1);
                            break;
                        }
                    }
                    this.putElement(element);
                    ret = true;
                }
            }
            return ret;
        }
        update(dt) {
            var locTargets = this._arrayTargets, locCurrTarget;
            for (var elt = 0; elt < locTargets.length; elt++) {
                this._currentTarget = locTargets[elt];
                locCurrTarget = this._currentTarget;
                if (!locCurrTarget.paused && locCurrTarget.actions) {
                    locCurrTarget.lock = true;
                    for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
                        locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                        if (!locCurrTarget.currentAction)
                            continue;
                        locCurrTarget.currentAction.step(dt);
                        if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                            locCurrTarget.currentAction.stop();
                            var action = locCurrTarget.currentAction;
                            locCurrTarget.currentAction = null;
                            this.removeAction(action);
                        }
                        locCurrTarget.currentAction = null;
                    }
                    locCurrTarget.lock = false;
                }
                if (locCurrTarget.actions.length === 0) {
                    this.deleteHashElement(locCurrTarget) && elt--;
                }
            }
        }
    }
    __reflect(ActionManager.prototype, "ActionManager");
    actions.AcitonMgr = new ActionManager();
})(actions || (actions = {}));
var actions;
(function (actions) {
    class CallFunAction extends actions.InstanceAction {
        constructor(func, thisArg, ...data) {
            super();
            this.func = func;
            this._thisArgs = thisArg;
            this._passArgs = data ? data : [];
        }
        clone() {
            let action = new CallFunAction(this.func, this._thisArgs, this._passArgs);
            return action;
        }
        update(dt) {
            this.execute();
        }
        reverse() {
            return this.clone();
        }
        execute() {
            this.func.apply(this._thisArgs, this._passArgs);
        }
        release() {
            super.release();
            this.func = null;
            this._thisArgs = null;
            this._passArgs = null;
        }
    }
    actions.CallFunAction = CallFunAction;
    __reflect(CallFunAction.prototype, "actions.CallFunAction", ["actions.IAction"]);
})(actions || (actions = {}));
var actions;
(function (actions) {
    class DelayAction extends actions.IntervalAction {
        clone() {
            let action = new DelayAction(this.duration);
            return action;
        }
        reverse() {
            return this.clone();
        }
        update(dt) {
        }
    }
    actions.DelayAction = DelayAction;
    __reflect(DelayAction.prototype, "actions.DelayAction", ["actions.IAction"]);
})(actions || (actions = {}));
var actions;
(function (actions) {
    function _makeOutIn(fnIn, fnOut) {
        return (k) => {
            if (k < 0.5) {
                return fnOut(k * 2) / 2;
            }
            return fnIn(2 * k - 1) / 2 + 0.5;
        };
    }
    /**
     * 目前支持的Ease动画
     */
    let Ease;
    (function (Ease) {
        Ease["Constant"] = "constant";
        Ease["Linear"] = "linear";
        /**平方曲线缓入函数。运动由慢到快。 */
        Ease["QuadIn"] = "quadIn";
        /**平方曲线缓出函数。运动由快到慢。 */
        Ease["QuadOut"] = "quadOut";
        Ease["QuadInOut"] = "quadInOut";
        Ease["QuadOutIn"] = "quadOutIn";
    })(Ease = actions.Ease || (actions.Ease = {}));
    class easing {
        static constant() {
            return 0;
        }
        static linear(k) {
            return k;
        }
        // quad
        //  easing equation function for a quadratic (t^2)
        //  @param t: Current time (in frames or seconds).
        //  @return: The correct value.
        /**
         *
         * 平方曲线缓入函数。运动由慢到快。
         * @method quadIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value
         */
        static quadIn(k) {
            return k * k;
        }
        /**
         * Easing out with quadratic formula. From fast to slow.
         * 平方曲线缓出函数。运动由快到慢。
         * @method quadOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value
         */
        static quadOut(k) {
            return k * (2 - k);
        }
        /**
         *
         * 平方曲线缓入缓出函数。运动由慢到快再到慢。
         * @method quadInOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value
         */
        static quadInOut(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k;
            }
            return -0.5 * (--k * (k - 2) - 1);
        }
        // cubic
        //  easing equation function for a cubic (t^3)
        //  @param t: Current time (in frames or seconds).
        //  @return: The correct value.
        /**
         * Easing in with cubic formula. From slow to fast.
         * 立方曲线缓入函数。运动由慢到快。
         * @method cubicIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static cubicIn(k) {
            return k * k * k;
        }
        /**
         * Easing out with cubic formula. From slow to fast.
         * 立方曲线缓出函数。运动由快到慢。
         * @method cubicOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static cubicOut(k) {
            return --k * k * k + 1;
        }
        /**
         * Easing in and out with cubic formula. From slow to fast, then back to slow.
         * 立方曲线缓入缓出函数。运动由慢到快再到慢。
         * @method cubicInOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static cubicInOut(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k + 2);
        }
        // quart
        //  easing equation function for a quartic (t^4)
        //  @param t: Current time (in frames or seconds).
        //  @return: The correct value.
        /**
         * Easing in with quartic formula. From slow to fast.
         * 四次方曲线缓入函数。运动由慢到快。
         * @method quartIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static quartIn(k) {
            return k * k * k * k;
        }
        /**
         * Easing out with quartic formula. From fast to slow.
         * 四次方曲线缓出函数。运动由快到慢。
         * @method quartOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static quartOut(k) {
            return 1 - --k * k * k * k;
        }
        /**
         * Easing in and out with quartic formula. From slow to fast, then back to slow.
         * 四次方曲线缓入缓出函数。运动由慢到快再到慢。
         * @method quartInOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static quartInOut(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k;
            }
            return -0.5 * ((k -= 2) * k * k * k - 2);
        }
        // quint
        //  easing equation function for a quintic (t^5)
        //  @param t: Current time (in frames or seconds).
        //  @return: The correct value.
        /**
         * Easing in with quintic formula. From slow to fast.
         * 五次方曲线缓入函数。运动由慢到快。
         * @method quintIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static quintIn(k) {
            return k * k * k * k * k;
        }
        /**
         * Easing out with quintic formula. From fast to slow.
         * 五次方曲线缓出函数。运动由快到慢。
         * @method quintOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static quintOut(k) {
            return --k * k * k * k * k + 1;
        }
        /**
         * Easing in and out with quintic formula. From slow to fast, then back to slow.
         * 五次方曲线缓入缓出函数。运动由慢到快再到慢。
         * @method quintInOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static quintInOut(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        }
        // sine
        //  easing equation function for a sinusoidal (sin(t))
        //  @param t: Current time (in frames or seconds).
        //  @return: The correct value.
        /**
         * Easing in and out with sine formula. From slow to fast.
         * 正弦曲线缓入函数。运动由慢到快。
         * @method sineIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static sineIn(k) {
            return 1 - Math.cos(k * Math.PI / 2);
        }
        /**
         * Easing in and out with sine formula. From fast to slow.
         * 正弦曲线缓出函数。运动由快到慢。
         * @method sineOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static sineOut(k) {
            return Math.sin(k * Math.PI / 2);
        }
        /**
         * Easing in and out with sine formula. From slow to fast, then back to slow.
         * 正弦曲线缓入缓出函数。运动由慢到快再到慢。
         * @method sineInOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static sineInOut(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        }
        // expo
        //  easing equation function for an exponential (2^t)
        //  param t: Current time (in frames or seconds).
        //  return: The correct value.
        /**
         * Easing in and out with exponential formula. From slow to fast.
         * 指数曲线缓入函数。运动由慢到快。
         * @method expoIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static expoIn(k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        }
        /**
         * Easing in and out with exponential formula. From fast to slow.
         * 指数曲线缓出函数。运动由快到慢。
         * @method expoOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static expoOut(k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        }
        /**
         * Easing in and out with exponential formula. From slow to fast.
         * 指数曲线缓入和缓出函数。运动由慢到很快再到慢。
         * @method expoInOut
         * @param {Number} t The current time as a percentage of the total time, then back to slow.
         * @return {Number} The correct value.
         */
        static expoInOut(k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(1024, k - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        }
        // circ
        //  easing equation function for a circular (sqrt(1-t^2))
        //  @param t: Current time (in frames or seconds).
        //  @return:	The correct value.
        /**
         * Easing in and out with circular formula. From slow to fast.
         * 循环公式缓入函数。运动由慢到快。
         * @method circIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static circIn(k) {
            return 1 - Math.sqrt(1 - k * k);
        }
        /**
         * Easing in and out with circular formula. From fast to slow.
         * 循环公式缓出函数。运动由快到慢。
         * @method circOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static circOut(k) {
            return Math.sqrt(1 - --k * k);
        }
        /**
         * Easing in and out with circular formula. From slow to fast.
         * 指数曲线缓入缓出函数。运动由慢到很快再到慢。
         * @method circInOut
         * @param {Number} t The current time as a percentage of the total time, then back to slow.
         * @return {Number} The correct value.
         */
        static circInOut(k) {
            if ((k *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        }
        // elastic
        //  easing equation function for an elastic (exponentially decaying sine wave)
        //  @param t: Current time (in frames or seconds).
        //  @return: The correct value.
        //  recommand value: elastic (t)
        /**
         * Easing in action with a spring oscillating effect.
         * 弹簧回震效果的缓入函数。
         * @method elasticIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static elasticIn(k) {
            var s, a = 0.1, p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            }
            else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        /**
         * Easing out action with a spring oscillating effect.
         * 弹簧回震效果的缓出函数。
         * @method elasticOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static elasticOut(k) {
            var s, a = 0.1, p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            }
            else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
        }
        /**
         * Easing in and out action with a spring oscillating effect.
         * 弹簧回震效果的缓入缓出函数。
         * @method elasticInOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static elasticInOut(k) {
            var s, a = 0.1, p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            }
            else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            if ((k *= 2) < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            }
            return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
        }
        // back
        //  easing equation function for a back (overshooting cubic easing: (s+1)*t^3 - s*t^2)
        //  @param t: Current time (in frames or seconds).
        //  @return: The correct value.
        /**
         * Easing in action with "back up" behavior.
         * 回退效果的缓入函数。
         * @method backIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static backIn(k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        }
        /**
         * Easing out action with "back up" behavior.
         * 回退效果的缓出函数。
         * @method backOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static backOut(k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        }
        /**
         * Easing in and out action with "back up" behavior.
         * 回退效果的缓入缓出函数。
         * @method backInOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static backInOut(k) {
            var s = 1.70158 * 1.525;
            if ((k *= 2) < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
            }
            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        }
        // bounce
        //  easing equation function for a bounce (exponentially decaying parabolic bounce)
        //  @param t: Current time (in frames or seconds).
        //  @return: The correct value.
        /**
         * Easing in action with bouncing effect.
         * 弹跳效果的缓入函数。
         * @method bounceIn
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static bounceIn(k) {
            return 1 - easing.bounceOut(1 - k);
        }
        /**
         * Easing out action with bouncing effect.
         * 弹跳效果的缓出函数。
         * @method bounceOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static bounceOut(k) {
            if (k < 1 / 2.75) {
                return 7.5625 * k * k;
            }
            else if (k < 2 / 2.75) {
                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
            }
            else if (k < 2.5 / 2.75) {
                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
            }
            else {
                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
            }
        }
        /**
         * Easing in and out action with bouncing effect.
         * 弹跳效果的缓入缓出函数。
         * @method bounceInOut
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        static bounceInOut(k) {
            if (k < 0.5) {
                return easing.bounceIn(k * 2) * 0.5;
            }
            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
        }
        /**
         * Target will run action with smooth effect.
         * 平滑效果函数。
         * @method smooth
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        // t<=0: 0 | 0<t<1: 3*t^2 - 2*t^3 | t>=1: 1
        static smooth(t) {
            if (t <= 0) {
                return 0;
            }
            if (t >= 1) {
                return 1;
            }
            return t * t * (3 - 2 * t);
        }
        /**
         * Target will run action with fade effect.
         * 渐褪效果函数。
         * @method fade
         * @param {Number} t The current time as a percentage of the total time.
         * @return {Number} The correct value.
         */
        // t<=0: 0 | 0<t<1: 6*t^5 - 15*t^4 + 10*t^3 | t>=1: 1
        static fade(t) {
            if (t <= 0) {
                return 0;
            }
            if (t >= 1) {
                return 1;
            }
            return t * t * t * (t * (t * 6 - 15) + 10);
        }
    }
    easing.quadOutIn = _makeOutIn(easing.quadIn, easing.quadOut);
    easing.cubicOutIn = _makeOutIn(easing.cubicIn, easing.cubicOut);
    easing.quartOutIn = _makeOutIn(easing.quartIn, easing.quartOut);
    easing.quintOutIn = _makeOutIn(easing.quintIn, easing.quintOut);
    easing.sineOutIn = _makeOutIn(easing.sineIn, easing.sineOut);
    easing.expoOutIn = _makeOutIn(easing.expoIn, easing.expoOut);
    easing.circOutIn = _makeOutIn(easing.circIn, easing.circOut);
    easing.backOutIn = _makeOutIn(easing.backIn, easing.backOut);
    actions.easing = easing;
    __reflect(easing.prototype, "actions.easing");
    ;
})(actions || (actions = {}));
var actions;
(function (actions) {
    class SequenceAction extends actions.IntervalAction {
        constructor(...args) {
            super(0);
            this._actions = [null, null];
            this._split = 0;
            this._lastIndex = 0;
            this._reversed = false;
            if (args.length <= 1) {
                return;
            }
            let last = args.length - 1;
            if (last >= 0 && !args[last]) {
                return;
            }
            if (last >= 0) {
                let prev = args[0], action1;
                for (let i = 1; i < last; i++) {
                    if (args[i]) {
                        action1 = prev;
                        prev = SequenceAction.actionOneTwo(action1, args[i]);
                    }
                }
                this.initWithTwoActions(prev, args[last]);
            }
        }
        clone() {
            let action = new SequenceAction();
            action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
            return action;
        }
        startWithTarget(target) {
            super.startWithTarget(target);
            this._split = this._actions[0].duration / this.duration;
            this._lastIndex = -1;
        }
        stop() {
            if (this._lastIndex !== -1)
                this._actions[this._lastIndex].stop();
            super.stop();
        }
        reverse() {
            let action = SequenceAction.actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
            action._reversed = true;
            return action;
        }
        initWithTwoActions(actionOne, actionTwo) {
            if (!actionOne || !actionTwo) {
                return false;
            }
            let durationOne = actionOne.duration, durationTwo = actionTwo.duration;
            let d = durationOne + durationTwo;
            this.initWithDuration(d);
            this._actions[0] = actionOne;
            this._actions[1] = actionTwo;
            return true;
        }
        update(dt) {
            let new_t, found = 0;
            let locSplit = this._split, locActions = this._actions, locLast = this._lastIndex, actionFound;
            dt = this.computeEaseTime(dt);
            if (dt < locSplit) {
                new_t = locSplit !== 0 ? dt / locSplit : 1;
                if (found === 0 && locLast === 1 && this._reversed) {
                    locActions[1].update(0);
                    locActions[1].stop();
                }
            }
            else {
                found = 1;
                new_t = locSplit === 1 ? 1 : (dt - locSplit) / (1 - locSplit);
                if (locLast === -1) {
                    // action[0] was skipped, execute it.
                    locActions[0].startWithTarget(this.target);
                    locActions[0].update(1);
                    locActions[0].stop();
                }
                if (locLast === 0) {
                    locActions[0].update(1);
                    locActions[0].stop();
                }
            }
            actionFound = locActions[found];
            if (locLast === found && actionFound.isDone())
                return;
            if (locLast !== found)
                actionFound.startWithTarget(this.target);
            actionFound.update(new_t > 1 ? new_t % 1 : new_t);
            this._lastIndex = found;
        }
        release() {
            super.release();
            this._actions[0].release();
            this._actions[1].release();
            this._actions = null;
        }
        static actionOneTwo(actionOne, actionTwo) {
            let sequence = new SequenceAction();
            sequence.initWithTwoActions(actionOne, actionTwo);
            return sequence;
        }
    }
    actions.SequenceAction = SequenceAction;
    __reflect(SequenceAction.prototype, "actions.SequenceAction");
})(actions || (actions = {}));
var actions;
(function (actions) {
    class SpawnAction extends actions.IntervalAction {
        constructor(...args) {
            super(0);
            let last = args.length - 1;
            if (last >= 0 && args[last] == null) {
                return;
            }
            if (last >= 0) {
                let prev = args[0], action1;
                for (let i = 1; i < last; i++) {
                    if (args[i]) {
                        action1 = prev;
                        prev = SpawnAction.actionOneTwo(action1, args[i]);
                    }
                }
                this.initWithTwoActions(prev, args[last]);
            }
        }
        initWithTwoActions(action1, action2) {
            let ret = false;
            let d1 = action1.duration;
            let d2 = action2.duration;
            if (this.initWithDuration(Math.max(d1, d2))) {
                this._one = action1;
                this._two = action2;
                if (d1 > d2) {
                    this._two = actions.SequenceAction.actionOneTwo(action2, new actions.DelayAction(d1 - d2));
                }
                else if (d1 < d2) {
                    this._one = actions.SequenceAction.actionOneTwo(action1, new actions.DelayAction(d2 - d1));
                }
                ret = true;
            }
            return ret;
        }
        clone() {
            let action = new SpawnAction();
            action.initWithTwoActions(this._one.clone(), this._two.clone());
            return action;
        }
        startWithTarget(target) {
            super.startWithTarget(target);
            this._one.startWithTarget(target);
            this._two.startWithTarget(target);
        }
        stop() {
            this._one.stop();
            this._two.stop();
            super.stop();
        }
        reverse() {
            let action = SpawnAction.actionOneTwo(this._one.reverse(), this._two.reverse());
            return action;
        }
        update(dt) {
            var _a, _b;
            dt = this.computeEaseTime(dt);
            (_a = this._one) === null || _a === void 0 ? void 0 : _a.update(dt);
            (_b = this._two) === null || _b === void 0 ? void 0 : _b.update(dt);
        }
        static actionOneTwo(actionOne, actionTwo) {
            let action = new SpawnAction();
            action.initWithTwoActions(actionOne, actionTwo);
            return action;
        }
        release() {
            super.release();
            this._one.release();
            this._one = null;
            this._two.release();
            this._two = null;
        }
    }
    actions.SpawnAction = SpawnAction;
    __reflect(SpawnAction.prototype, "actions.SpawnAction", ["actions.IAction"]);
})(actions || (actions = {}));
var actions;
(function (actions) {
    class FlexSpeedAction extends actions.BaseAction {
        constructor(action, speed) {
            super();
            this._speed = 1;
            this.initWithAction(action, speed);
        }
        set innerAction(value) {
            this._innerAction = value;
        }
        get innerAction() {
            return this._innerAction;
        }
        set speed(value) {
            this._speed = value;
        }
        get speed() {
            return this._speed;
        }
        initWithAction(action, speed) {
            this._innerAction = action;
            this._speed = speed;
        }
        clone() {
            let ret = new FlexSpeedAction(this._innerAction.clone(), this._speed);
            return ret;
        }
        isDone() {
            return this._innerAction.isDone();
        }
        startWithTarget(target) {
            super.startWithTarget(target);
            this._innerAction.startWithTarget(target);
        }
        step(dt) {
            this._innerAction.step(dt * this._speed);
        }
        stop() {
            super.stop();
            this._innerAction.stop();
        }
        update(dt) {
        }
        reverse() {
            return new FlexSpeedAction(this._innerAction.reverse(), this._speed);
        }
        release() {
            super.release();
            this._innerAction.release();
            this._innerAction = null;
            this._speed = 0;
        }
    }
    actions.FlexSpeedAction = FlexSpeedAction;
    __reflect(FlexSpeedAction.prototype, "actions.FlexSpeedAction", ["actions.IAction"]);
})(actions || (actions = {}));
var actions;
(function (actions) {
    var utils;
    (function (utils) {
        class Bezier {
            static bezier(start, c1, c2, end, t) {
                if (typeof (start) === 'number') {
                    let t1 = 1 - t;
                    return t1 * (t1 * (start + (c1 * 3 - start) * t) + c2 * 3 * t * t) + end * t * t * t;
                }
                else {
                    let x = this.bezier(start.x, c1.x, c2.x, end.x, t);
                    let y = this.bezier(start.y, c1.y, c2.y, end.y, t);
                    let z = this.bezier(start.z, c1.z, c2.z, end.z, t);
                    return [x, y, z];
                }
            }
        }
        utils.Bezier = Bezier;
        __reflect(Bezier.prototype, "actions.utils.Bezier");
        class CatmullRom {
            /**
             * 通过控制点以及张力以及插值返回样条曲线中的点
             * https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
             * @param p0
             * @param p1
             * @param p2
             * @param p3
             * @param tension
             * @param t
             * @returns
             */
            static cardinalSplineAt(p0, p1, p2, p3, tension, t) {
                let t2 = t * t;
                let t3 = t2 * t;
                /*
                 * Formula: s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4
                 */
                let s = (1 - tension) / 2;
                let b1 = s * (-t3 + 2 * t2 - t); // s(-t3 + 2 t2 - t)P1
                let b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1); // s(-t3 + t2)P2 + (2 t3 - 3 t2 + 1)P2
                let b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2); // s(t3 - 2 t2 + t)P3 + (-2 t3 + 3 t2)P3
                let b4 = s * (t3 - t2); // s(t3 - t2)P4
                let x = p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4;
                let y = p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4;
                let z = p0.z * b1 + p1.z * b2 + p2.z * b3 + p3.z * b4;
                return [x, y, z];
            }
            /**
             * 从控制点中取出一个点
             * @param controlPoints
             * @param pos
             * @returns
             */
            static getControlPointAt(controlPoints, pos) {
                var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
                return controlPoints[p];
            }
        }
        utils.CatmullRom = CatmullRom;
        __reflect(CatmullRom.prototype, "actions.utils.CatmullRom");
    })(utils = actions.utils || (actions.utils = {}));
})(actions || (actions = {}));
var actions;
(function (actions) {
    class RepeatAction extends actions.IntervalAction {
        constructor(action, times) {
            super(0);
            this._times = 0;
            this._total = 0;
            this._nextDt = 0;
            this._actionInstant = false;
            times !== undefined && this.initWithAction(action, times);
        }
        initWithAction(action, times) {
            let duration = action.duration * times;
            if (this.initWithDuration(duration)) {
                this._times = times;
                this._innerAction = action;
                if (action instanceof actions.InstanceAction) {
                    this._actionInstant = true;
                    this._times -= 1;
                }
                this._total = 0;
                return true;
            }
            return false;
        }
        update(dt) {
            dt = this.computeEaseTime(dt);
            let locInnerAction = this._innerAction;
            let locDuration = this.duration;
            let locTimes = this._times;
            let locNextDt = this._nextDt;
            if (dt >= locNextDt) {
                while (dt > locNextDt && this._total < locTimes) {
                    locInnerAction.update(1);
                    this._total++;
                    locInnerAction.stop();
                    locInnerAction.startWithTarget(this.target);
                    locNextDt += locInnerAction.duration / locDuration;
                    this._nextDt = locNextDt > 1 ? 1 : locNextDt;
                }
                if (dt >= 1.0 && this._total < locTimes) {
                    locInnerAction.update(1);
                    this._total++;
                }
                if (!this._actionInstant) {
                    if (this._total === locTimes) {
                        locInnerAction.stop();
                    }
                    else {
                        locInnerAction.update(dt - (locNextDt - locInnerAction.duration / locDuration));
                    }
                }
            }
            else {
                locInnerAction.update(dt * locTimes % 1.0);
            }
        }
        clone() {
            let action = new RepeatAction(this._innerAction.clone(), this._times);
            return action;
        }
        startWithTarget(target) {
            this._total = 0;
            this._nextDt = this._innerAction.duration / this.duration;
            super.startWithTarget(target);
            this._innerAction.startWithTarget(target);
        }
        stop() {
            this._innerAction.stop();
            super.stop();
        }
        isDone() {
            return this._total === this._times;
        }
        reverse() {
            let action = new RepeatAction(this._innerAction.reverse(), this._times);
            return action;
        }
        release() {
            super.release();
            this._innerAction.release();
            this._innerAction = null;
        }
    }
    actions.RepeatAction = RepeatAction;
    __reflect(RepeatAction.prototype, "actions.RepeatAction", ["actions.IAction"]);
})(actions || (actions = {}));
var actions;
(function (actions) {
    class RepeatForeverAction extends actions.IntervalAction {
        constructor(action) {
            super(0);
            this._innerAction = action;
        }
        update(dt) {
        }
        clone() {
            let action = new RepeatForeverAction(this._innerAction.clone());
            return action;
        }
        reverse() {
            let action = new RepeatForeverAction(this._innerAction.reverse());
            return action;
        }
        startWithTarget(target) {
            super.startWithTarget(target);
            this._innerAction.startWithTarget(target);
        }
        step(dt) {
            var locInnerAction = this._innerAction;
            locInnerAction.step(dt);
            if (locInnerAction.isDone()) {
                locInnerAction.startWithTarget(this.target);
                locInnerAction.step(locInnerAction.elapsed - locInnerAction.duration);
            }
        }
        isDone() {
            return false;
        }
        release() {
            super.release();
            this._innerAction.release();
            this._innerAction = null;
        }
    }
    actions.RepeatForeverAction = RepeatForeverAction;
    __reflect(RepeatForeverAction.prototype, "actions.RepeatForeverAction", ["actions.IAction"]);
})(actions || (actions = {}));
var actions;
(function (actions_1) {
    var tweens;
    (function (tweens) {
        var easing = actions.easing;
        var ActionInterval = actions.IntervalAction;
        var ActionMgr = actions.AcitonMgr;
        var SequenceAction = actions.SequenceAction;
        var DelayAction = actions.DelayAction;
        var CallFuncAction = actions.CallFunAction;
        var SpawnAction = actions.SpawnAction;
        let _tweenID = 0;
        function stopAll() {
            ActionMgr.removeAllActions();
        }
        tweens.stopAll = stopAll;
        function stopAllByTag(tag) {
            ActionMgr.removeActionByTag(tag);
        }
        tweens.stopAllByTag = stopAllByTag;
        function stopAllByTarget(target) {
            ActionMgr.removeAllActionsFromTarget(target);
        }
        tweens.stopAllByTarget = stopAllByTarget;
        class TweenAction extends ActionInterval {
            constructor(duration, props, opts) {
                super(duration);
                this._opts = opts = opts || Object.create(null);
                this._props = {};
                opts.progress = opts.progress || this.progress;
                if (opts.easing && typeof opts.easing === 'string') {
                    opts.easing = easing[opts.easing];
                }
                if (!opts.easing) {
                    opts.easing = easing.linear;
                }
                let relative = opts.relative;
                for (let name in props) {
                    let value = props[name];
                    let easing = undefined, progress = undefined;
                    if (value.value !== undefined && (value.easing || value.progress)) {
                        if (typeof value.easing === 'string') {
                            easing = easing[value.easing];
                            !easing && console.error("invalid easing name " + value.easing);
                        }
                        else {
                            easing = value.easing;
                        }
                        progress = value.progress;
                        value = value.value;
                    }
                    if ((typeof value != 'number') && (!value.lerp || relative && !value.add && !value.multiply || !value.clone)) {
                        console.warn("Can not animate " + name + " property, because it do not have [lerp, (addition|multiply), clone] function.");
                        continue;
                    }
                    let prop = Object.create(null);
                    prop.value = value;
                    prop.easing = easing;
                    prop.progress = progress;
                    this._props[name] = prop;
                }
                this._originProps = props;
            }
            clone() {
                let action = new TweenAction(this.duration, this._originProps, this._opts);
                return action;
            }
            startWithTarget(target) {
                super.startWithTarget(target);
                let relative = !!this._opts.relative;
                let props = this._props;
                for (let name in props) {
                    let value = target[name];
                    let prop = props[name];
                    if (typeof value === 'number') {
                        prop.start = value;
                        prop.current = value;
                        prop.end = relative ? value + prop.value : prop.value;
                    }
                    else {
                        prop.start = value.clone();
                        prop.current = value.clone();
                        prop.end = relative ? (value.addition || value.multiply).call(value, prop.value) : prop.value;
                    }
                }
            }
            update(t) {
                let opts = this._opts;
                let easingTime = t;
                if (opts.easing)
                    easingTime = opts.easing(t);
                let target = this.target;
                if (!target)
                    return;
                let props = this._props;
                let progress = opts.progress;
                for (let name in props) {
                    let prop = props[name];
                    let time = prop.easing ? prop.easing(t) : easingTime;
                    let current = prop.current = (prop.progress || progress)(prop.start, prop.end, prop.current, time);
                    target[name] = current;
                }
                let onUpdate = opts.onUpdate;
                if (onUpdate) {
                    onUpdate(target, t);
                }
            }
            progress(start, end, current, t) {
                if (typeof start === 'number') {
                    current = start + (end - start) * t;
                }
                else {
                    current = start.lerp(end, t, current);
                }
                return current;
            }
            reverse() {
                let props = Object.create(null);
                let originProps = this._props;
                for (let key in originProps) {
                    props[key] = originProps[key].start;
                }
                let action = new TweenAction(this.elapsed, props, this._opts);
                return action;
            }
        }
        __reflect(TweenAction.prototype, "TweenAction", ["actions.IAction"]);
        class Tween {
            constructor(target) {
                this._finalAction = null;
                this.initWith(target);
            }
            get tag() {
                return this._tag;
            }
            get originalTarget() {
                return this._target;
            }
            initWith(target) {
                this._actions = [];
                this._finalAction = null;
                this._target = target;
                this._tag = "none";
                if (!target.__signActionId) {
                    target.__signActionId = Tween._gid++;
                }
            }
            then(other) {
                if (!Tween.isTween(other)) {
                    this._actions.push(other.clone());
                }
                else {
                    this._actions.push(other._union());
                }
                return this;
            }
            target(target) {
                this._target = target;
                return this;
            }
            start() {
                let target = this._target;
                if (!target) {
                    console.warn('Please set target to tween first');
                }
                if (this._finalAction) {
                    ActionMgr.removeAction(this._finalAction);
                }
                this._finalAction = this._union();
                if (target.__signActionId === undefined) {
                    target.__signActionId = ++_tweenID;
                }
                this._finalAction.tag = this._tag;
                ActionMgr.addAction(this._finalAction, target, false);
            }
            stop() {
                if (this._finalAction) {
                    ActionMgr.removeAction(this._finalAction);
                }
                return this;
            }
            setTag(tag) {
                this._tag = tag;
                return this;
            }
            clone(target) {
                let action = this._union();
                return new Tween(target).then(action.clone());
            }
            union() {
                let action = this._union();
                this._actions.length = 0;
                this._actions.push(action);
                return this;
            }
            _union() {
                var action;
                if (this._actions.length === 1) {
                    action = this._actions[0];
                }
                else {
                    action = new SequenceAction(...this._actions);
                }
                return action;
            }
            _wrapInternalAction(action) {
                this._actions.push(action);
                return this;
            }
            release() {
                this._actions.length = 0;
                this._finalAction = null;
                this._target = null;
            }
            /**
             * 添加一个对属性进行相对值计算的 action
             * @param duration 动作持续时间
             * @param props 要变更的属性 {location:Type.Vector(100,1001,100)} 或 {location:{value:Type.Vector(100,1001,100),easing:"ease",progress:"()=>{}"}}
             * @param opts 参数
             * @returns
             */
            to(duration, props, opts) {
                opts = opts ? opts : {};
                opts.relative = false;
                return this._wrapInternalAction(new TweenAction(duration, props, opts));
            }
            by(duration, props, opts) {
                opts = opts ? opts : {};
                opts.relative = true;
                return this._wrapInternalAction(new TweenAction(duration, props, opts));
            }
            set(props) {
                return this._wrapInternalAction(new actions_1.SetAction(props));
            }
            delay(d) {
                return this._wrapInternalAction(new DelayAction(d));
            }
            call(callBack, selecttarget, data) {
                return this._wrapInternalAction(new CallFuncAction(callBack, selecttarget, data));
            }
            /**
             * 添加一个队列Action
             * @param actions
             * @returns
             */
            sequence(action, ...args) {
                args.unshift(action);
                if (args.length <= 1) {
                    args.push(this._actions.pop());
                }
                let actions = [];
                args.forEach((value) => {
                    if (value instanceof Tween) {
                        actions.push(value._union());
                    }
                    else {
                        actions.push(value);
                    }
                });
                return this._wrapInternalAction(new SequenceAction(...actions));
            }
            /**
             * 添加一个并列Action
             * @param action
             * @param actions
             * @returns
             */
            parallel(...args) {
                let actions = [];
                args.forEach((value) => {
                    if (value instanceof Tween) {
                        actions.push(value._union());
                    }
                    else {
                        actions.push(value);
                    }
                });
                return this._wrapInternalAction(new SpawnAction(...actions));
            }
            repeat(repeatTimes, args) {
                if (!args) {
                    args = this._actions.pop();
                }
                if (!args) {
                    //没有任何Action
                    return this;
                }
                let action;
                if (args instanceof Tween) {
                    action = args._union();
                }
                else {
                    action = args;
                }
                return this._wrapInternalAction(new actions.RepeatAction(action, repeatTimes));
            }
            repeatForever(args) {
                if (!args) {
                    let prev = this._actions.pop();
                    if (prev instanceof ActionInterval) {
                        args = prev;
                    }
                    else {
                        this._actions.push(prev);
                    }
                }
                if (!args) {
                    //没有任何Action
                    return this;
                }
                let action;
                if (args instanceof Tween) {
                    action = args._union();
                }
                else {
                    action = args;
                }
                return this._wrapInternalAction(new actions.RepeatForeverAction(action));
            }
            /**
             * 使用贝塞尔曲线移动到目标位置
             * @param duration 动作持续时间
             * @param c1 控制点1
             * @param c2 控制点2
             * @param to 要移动的目标点
             * @param opts
             * @returns
             */
            bezierTo(duration, c1, c2, to, opts) {
                let c0x = c1.x;
                let c0y = c1.y;
                let c0z = c1.z;
                let c1x = c2.x;
                let c1y = c2.y;
                let c1z = c2.z;
                opts = opts ? opts : {};
                opts.progress = function (start, end, current, t) {
                    current.x = actions.utils.Bezier.bezier(start.x, c0x, c1x, end.x, t);
                    current.y = actions.utils.Bezier.bezier(start.y, c0y, c1y, end.y, t);
                    current.z = actions.utils.Bezier.bezier(start.z, c0z, c1z, end.z, t);
                    return current;
                };
                return this.to(duration, { "position": to }, opts);
            }
            bezierBy(duration, c1, c2, to, opts) {
                let c0x = c1.x;
                let c0y = c1.y;
                let c0z = c1.z;
                let c1x = c2.x;
                let c1y = c2.y;
                let c1z = c2.z;
                opts = opts ? opts : {};
                opts.progress = function (start, end, current, t) {
                    let sx = start.x, sy = start.y, sz = start.z;
                    current.x = actions.utils.Bezier.bezier(sx, c0x + sx, c1x + sx, end.x, t);
                    current.y = actions.utils.Bezier.bezier(sy, c0y + sy, c1y + sy, end.y, t);
                    current.z = actions.utils.Bezier.bezier(sz, c0z + sz, c1z + sz, end.z, t);
                    return current;
                };
                return this.by(duration, { "position": to }, opts);
            }
            static isTween(obj) {
                return obj['_union'];
            }
        }
        Tween._gid = 1;
        tweens.Tween = Tween;
        __reflect(Tween.prototype, "actions.tweens.Tween");
    })(tweens = actions_1.tweens || (actions_1.tweens = {}));
})(actions || (actions = {}));
var actions;
(function (actions_2) {
    function repeat(times, action) {
        return new actions_2.RepeatAction(action, times);
    }
    actions_2.repeat = repeat;
    function repeatForever(action) {
        return new actions_2.RepeatForeverAction(action);
    }
    actions_2.repeatForever = repeatForever;
    function delay(time) {
        return new actions_2.DelayAction(time);
    }
    actions_2.delay = delay;
    function call(func, thisArg, ...data) {
        return new actions_2.CallFunAction(func, thisArg, ...data);
    }
    actions_2.call = call;
    function spawn(...actions) {
        return new actions_2.SpawnAction(...actions);
    }
    actions_2.spawn = spawn;
    function sequence(...actions) {
        return new actions_2.SequenceAction(...actions);
    }
    actions_2.sequence = sequence;
    function speed(speed, action) {
        return new actions_2.FlexSpeedAction(action, speed);
    }
    actions_2.speed = speed;
    function tween(target) {
        return new actions_2.tweens.Tween(target);
    }
    actions_2.tween = tween;
})(actions || (actions = {}));
globalThis.actions = actions;

export default actions;
//# sourceMappingURL=actions.js.map