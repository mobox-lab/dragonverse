/**
 * GToolkit.
 * General Toolkit deep binding MW Ts.
 * @desc ---
 * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
 * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
 * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
 * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
 * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
 * @author G.S.C. Gtk Standards Committee. Gtk 标准委员会.
 * @author LviatYi
 * @author minjia.zhang
 * @author zewei.zhang
 * @author yuanming.hu
 * @see https://github.com/LviatYi/MetaWorldNPT/tree/main/MetaWorldNPT/JavaScripts/util
 * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
 * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
 */
class GToolkit {
    constructor() {
        /**
         * 默认 随机函数.
         * @type {() => number}
         */
        this.defaultRandomFunc = Math.random;
        //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
        //#region Member
        this._characterDescriptionLockers = new Set();
        this._patchHandlerPool = new Map();
        this._waitHandlerPool = new Map();
        this._globalOnlyOnBlurDelegate = undefined;
        //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
        //#region MW
        //#region Constant
        /**
         * Guid of Root GameObject.
         */
        this.ROOT_GAME_OBJECT_GUID = "SceneRoot";
        /**
         * Guid of Root GameObject (old).
         */
        this.ROOT_GAME_OBJECT_GUID_BACKUP = "ComponentRoot";
        /**
         * Tag of Root GameObject.
         * @type {string}
         */
        this.ROOT_GAME_OBJECT_TAG_CUSTOM = "SceneRootTagByGtk";
        /**
         * 全透明图片 GUID.
         * @type {string}
         */
        this.IMAGE_FULLY_TRANSPARENT_GUID = "168495";
        /**
         * 纯黑圆形遮罩 GUID.
         */
        this.IMAGE_CIRCLE_MASK_GUID = "212681";
        /**
         * 白色方块 GUID.
         * @type {string}
         */
        this.IMAGE_WHITE_SQUARE_GUID = "114028";
        /**
         * mw 导出颜色字符串正则.
         * @type {RegExp}
         * @private
         */
        this.REGEX_MW_EXPORT_COLOR_STR = /(?=.*R)(?=.*G)(?=.*B)\(([RGBA]=\d*(\.\d*)?,?)+\)/g;
        /**
         * mw 导出颜色值正则.
         * @type {RegExp}
         * @private
         */
        this.REGEX_MW_EXPORT_COLOR_VALUE_STR = /([RGBA])=(\d*(\.\d*)?)/g;
        /**
         * 十六进制颜色字符串正则.
         * @type {RegExp}
         * @private
         */
        this.REGEX_HEX_COLOR_STR = /^#?[\dA-Fa-f]+$/g;
        /**
         * mw 配置颜色字符串正则.
         * @type {RegExp}
         * @private
         */
        this.REGEX_MW_ARRAY_COLOR_STR = /^[.|\d]+$/g;
        /**
         * 该平台是否 use mouse 缓存.
         * @type {boolean}
         * @private
         */
        this._useMouse = undefined;
        //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
    }
    //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
    /**
     * Is Primitive.
     * @param value
     */
    isPrimitiveType(value) {
        return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "symbol";
    }
    /**
     * Is number.
     * @param value
     */
    isNumber(value) {
        return typeof value === "number";
    }
    /**
     * Is string.
     * @param value
     */
    isString(value) {
        return typeof value === "string";
    }
    /**
     * Is boolean.
     * @param value
     */
    isBoolean(value) {
        return typeof value === "boolean";
    }
    /**
     * Is object.
     * @param value
     */
    isObject(value) {
        return typeof value === "object";
    }
    /**
     * 对 instance 进行强制类型推断.
     * @param instance 对象
     * @param method 对象方法名
     * @returns boolean
     */
    is(instance, method) {
        if (!instance)
            return false;
        if (typeof method === "string") {
            return method in instance;
        }
        return method(instance);
    }
    /**
     * Ts 枚举值.
     * traverse values in enum.
     * @param {T} enumType
     * @return {ValueTypeInEnum<T>[]}
     */
    enumVals(enumType) {
        return Object
            .entries(enumType)
            .filter(([key, value]) => isNaN(Number(key)))
            .map(([key, value]) => value);
    }
    /**
     * is the array or string empty.
     * define empty is undefined or null or [""].
     * @param textOrArray str or array.
     */
    isNullOrEmpty(textOrArray) {
        return this.isNullOrUndefined(textOrArray) ||
            (typeof textOrArray === "string" ? (textOrArray === "") : (textOrArray.length === 0));
    }
    /**
     * is the value null or undefined.
     * @param value
     */
    isNullOrUndefined(value) {
        return value == undefined;
    }
    /**
     * return the safe index.
     * @param index
     * @param arr
     * @param safeStrategy 索引越界时的安全策略.
     *      - "cut" default. 截断至合法索引.
     *      - "cycle" 循环. 非法时对值取余.
     * @return 当数组为空时返回 -1. 否则按策略返回合法索引.
     */
    safeIndex(index, arr, safeStrategy = "cut") {
        if (this.isNullOrEmpty(arr))
            return -1;
        if (index < 0)
            switch (safeStrategy) {
                case "cycle":
                    return (arr.length + index % arr.length) % arr.length;
                case "cut":
                default:
                    return 0;
            }
        if (index >= arr.length)
            switch (safeStrategy) {
                case "cycle":
                    return index % arr.length;
                case "cut":
                default:
                    return arr.length - 1;
            }
        return index;
    }
    /**
     * return item by index who maybe unsafe.
     * @param index
     * @param arr
     * @param safeStrategy 索引越界时的安全策略.
     *      - "cut" default. 截断至合法索引.
     *      - "cycle" 循环. 非法时对值取余.
     * @return 当数组为空时返回 null. 否则按策略返回合法元素.
     */
    safeIndexItem(index, arr, safeStrategy = "cut") {
        let safeIndex = this.safeIndex(index, arr, safeStrategy);
        return safeIndex === -1 ? null : arr[safeIndex];
    }
    /**
     * remove item from array.
     * @param array
     * @param item
     * @param {boolean} holdOrder hold order after remove.
     */
    remove(array, item, holdOrder = true) {
        if (!array)
            return;
        const index = array.indexOf(item);
        if (index > -1) {
            if (holdOrder) {
                array.splice(index, 1);
            }
            else {
                array[index] = array[array.length - 1];
                array.pop();
            }
            return true;
        }
        return false;
    }
    /**
     * remove item from array by index.
     * @desc sequence not maintained.
     * @param {T[]} array
     * @param {number} index
     */
    removeByIndex(array, index) {
        if (index < 0 || index > array.length) {
            return false;
        }
        array[index] = array[array.length - 1];
        --array.length;
        return true;
    }
    /**
     * build an advanced switch.
     */
    switch() {
        return new Switcher();
    }
    /**
     * fold data.
     * @param data
     * @param foldCount
     * @param func
     */
    fold(data, foldCount, func) {
        const result = [];
        for (let i = 0; i < data.length; i += foldCount) {
            result.push(func(data.slice(i, i + foldCount)));
        }
        return result;
    }
    /**
     * unfold data.
     * @param data
     * @param foldCount
     * @param func
     */
    unfold(data, foldCount, func) {
        const result = [];
        for (const element of data) {
            result.push(...func(element));
        }
        return result;
    }
    /**
     * confirm get value from map with key.
     * @param {Map<K, V>} map
     * @param {K} key
     * @param {()=>V} generate
     * @return {V}
     */
    tryGet(map, key, generate) {
        let result = map.get(key);
        if (result === undefined) {
            result = typeof generate === "function" ?
                generate() :
                generate;
            map.set(key, result);
        }
        return result;
    }
    /**
     * do callback once when predicate return true.
     * @param predicate
     * @param callback
     * @param interval test predicate interval. ms.
     *      - 100 default.
     * @param instant test predicate at once.
     * @param timeout timeout. stop predicate test after timeout. ms.
     *      - 0 default. no timeout.
     * @param onError on error callback.
     * @param onTimeout on timeout callback.
     * @return interval hold id.
     */
    doWhenTrue(predicate, callback, interval = 100, instant = true, timeout = 0, onError = undefined, onTimeout = undefined) {
        const startTime = Date.now();
        let holdId = null;
        const callbackWithCatch = () => {
            try {
                callback();
            }
            catch (e) {
                try {
                    onError && onError();
                }
                catch (e) {
                    mw.console.error("GToolkit: error occurs in onError callback.");
                    mw.console.error(e);
                    mw.console.error(e.stack);
                }
            }
            finally {
                holdId && clearInterval(holdId);
            }
        };
        if (instant && predicate()) {
            callbackWithCatch();
            return null;
        }
        holdId = mw.setInterval(() => {
            if (timeout > 0 && Date.now() - startTime > timeout) {
                clearInterval(holdId);
                onTimeout && onTimeout();
                return;
            }
            if (!predicate())
                return;
            callbackWithCatch();
        }, interval);
        return holdId;
    }
    /**
     * do callback persistently until predicate return true.
     * @param predicate
     * @param callback
     * @param interval ms. test predicate interval.
     *      100 default.
     * @param instant test predicate at once.
     * @param timeout timeout. stop predicate test after timeout. ms.
     *      - 0 default. no timeout.
     * @param onError on error callback.
     * @param onTimeout on timeout callback.
     * @return interval hold id.
     */
    doUntilTrue(predicate, callback, interval = 100, instant = true, timeout = 0, onError = undefined, onTimeout = undefined) {
        const startTime = Date.now();
        let holdId = null;
        const callbackWithCatch = () => {
            try {
                callback();
            }
            catch (e) {
                try {
                    onError && onError();
                }
                catch (e) {
                    mw.console.error("GToolkit: error occurs in onError callback.");
                    mw.console.error(e);
                    mw.console.error(e.stack);
                }
            }
            finally {
                holdId && clearInterval(holdId);
            }
        };
        if (instant) {
            if (predicate())
                return null;
            else
                callbackWithCatch();
        }
        holdId = mw.setInterval(() => {
            if (timeout > 0 && Date.now() - startTime > timeout) {
                clearInterval(holdId);
                onTimeout && onTimeout();
                return;
            }
            if (predicate()) {
                clearInterval(holdId);
                return;
            }
            callbackWithCatch();
        }, interval);
        return holdId;
    }
    /**
     * do a delayed batch operation who wait for data.
     * @param {TArg} data
     * @param {(data: TArg[]) => void} patchCallback
     *      - do not use an anonymous function here.
     * @param {number} waitTime=undefined 󰅐wait time. ms.
     *      if first register the patchCallback, the waitTime will be 100 ms.
     *      else the waitTime will use last waitTime.
     * @param {boolean} reTouch=false reclock when data added.
     *      it allows a single instance to store and manage multiple data batch queues based on different tags.
     * @param {boolean} instantly=false do patch when instantly.
     * @return {number} timer id.
     */
    patchDo(data, patchCallback, waitTime = undefined, reTouch = false, instantly = false) {
        let existPatch = this.tryGet(this._patchHandlerPool, patchCallback, () => ({
            timerId: undefined,
            data: [],
            delayDo: () => {
                if (existPatch.timerId !== undefined) {
                    mw.clearTimeout(existPatch.timerId);
                }
                this._patchHandlerPool.delete(patchCallback);
                patchCallback(existPatch.data);
            },
            lastWaitDuration: waitTime,
        }));
        existPatch.data.push(data);
        if (instantly) {
            existPatch.delayDo();
        }
        else if (existPatch.timerId === undefined || reTouch) {
            if (existPatch.timerId !== undefined)
                mw.clearTimeout(existPatch.timerId);
            if (waitTime !== undefined)
                existPatch.lastWaitDuration = waitTime;
            existPatch.timerId = mw.setTimeout(existPatch.delayDo, existPatch.lastWaitDuration ?? 0.1e3);
        }
        return existPatch.timerId;
    }
    /**
     * do a delayed batch operation who wait for data.
     * @param {TArg} data
     * @param {(data: TArg) => void} waitCallback
     *      - do not use an anonymous function here.
     * @param {number} waitTime=undefined 󰅐wait time. ms.
     *      if first register the patchCallback, the waitTime will be 100 ms.
     *      else the waitTime will use last waitTime.
     * @param {boolean} reTouch=true reclock when data added.
     *      it allows a single instance to store and manage multiple data batch queues based on different tags.
     * @param {boolean} instantly=false do patch when instantly.
     * @return {number} timer id.
     */
    waitDo(data, waitCallback, waitTime = undefined, reTouch = true, instantly = false) {
        let existPatch = this.tryGet(this._waitHandlerPool, waitCallback, () => ({
            timerId: undefined,
            data: undefined,
            delayDo: () => {
                if (existPatch.timerId !== undefined) {
                    mw.clearTimeout(existPatch.timerId);
                }
                this._waitHandlerPool.delete(waitCallback);
                waitCallback(existPatch.data);
            },
            lastWaitDuration: waitTime,
        }));
        existPatch.data = data;
        if (instantly) {
            existPatch.delayDo();
        }
        else if (existPatch.timerId === undefined || reTouch) {
            if (existPatch.timerId !== undefined)
                mw.clearTimeout(existPatch.timerId);
            if (waitTime !== undefined)
                existPatch.lastWaitDuration = waitTime;
            existPatch.timerId = mw.setTimeout(existPatch.delayDo, existPatch.lastWaitDuration ?? 1e3);
        }
        return existPatch.timerId;
    }
    /**
     * whether the two times are equal.
     * @param {number} lhs
     * @param {number} rhs
     * @param {GtkTypes.TimeFormatDimensionFlagsLike} precision
     * @return {boolean}
     */
    isSameTime(lhs, rhs, precision = GtkTypes.Tf.D) {
        if (precision === GtkTypes.Tf.Ms)
            return lhs === rhs;
        let lhsDate = new Date(lhs);
        let rhsDate = new Date(rhs);
        switch (precision) {
            case GtkTypes.Tf.Y:
                return lhsDate.getFullYear() === rhsDate.getFullYear();
            case GtkTypes.Tf.Mon:
                return lhsDate.getFullYear() === rhsDate.getFullYear() &&
                    lhsDate.getMonth() === rhsDate.getMonth();
            case GtkTypes.Tf.D:
                return lhsDate.getFullYear() === rhsDate.getFullYear() &&
                    lhsDate.getMonth() === rhsDate.getMonth() &&
                    lhsDate.getDate() === rhsDate.getDate();
            case GtkTypes.Tf.H:
                return lhsDate.getFullYear() === rhsDate.getFullYear() &&
                    lhsDate.getMonth() === rhsDate.getMonth() &&
                    lhsDate.getDate() === rhsDate.getDate() &&
                    lhsDate.getHours() === rhsDate.getHours();
            case GtkTypes.Tf.M:
                return lhsDate.getFullYear() === rhsDate.getFullYear() &&
                    lhsDate.getMonth() === rhsDate.getMonth() &&
                    lhsDate.getDate() === rhsDate.getDate() &&
                    lhsDate.getHours() === rhsDate.getHours() &&
                    lhsDate.getMinutes() === rhsDate.getMinutes();
            case GtkTypes.Tf.S:
                return lhsDate.getFullYear() === rhsDate.getFullYear() &&
                    lhsDate.getMonth() === rhsDate.getMonth() &&
                    lhsDate.getDate() === rhsDate.getDate() &&
                    lhsDate.getHours() === rhsDate.getHours() &&
                    lhsDate.getMinutes() === rhsDate.getMinutes() &&
                    lhsDate.getSeconds() === rhsDate.getSeconds();
            default:
                return false;
        }
    }
    /**
     * 获取所有成员 key.
     * @param obj 指定实例.
     * @param exceptConstructor 是否 排除构造函数.
     * @param exceptObject 是否 排除 Js Object.
     */
    getAllMember(obj, exceptConstructor = true, exceptObject = true) {
        const props = [];
        let focus = obj;
        do {
            if (exceptObject && focus === Object.prototype) {
                break;
            }
            props.push(...Object.getOwnPropertyNames(focus).filter(item => !(exceptConstructor && item === "constructor")));
        } while (focus = Object.getPrototypeOf(focus));
        return props;
    }
    /**
     * angle to radius.
     * @param angle
     */
    radius(angle) {
        return angle / 180 * Math.PI;
    }
    /**
     * radius to angle.
     * @param radius
     */
    angle(radius) {
        return radius / Math.PI * 180;
    }
    /**
     * random in range [min,max).
     * @param min default 0.
     * @param max default min + 1.
     * @param integer return a integer.
     */
    random(min = undefined, max = undefined, integer = false) {
        if (min === undefined) {
            min = 0;
        }
        if (max === undefined) {
            max = min + 1;
        }
        let result = Math.random() * (max - min) + min;
        return integer ? result | 0 : result;
    }
    /**
     * random with weight.
     * @param weight
     * @param total total weight. add last weight as total-sum(weight)
     * @return number [0,weight.length) .
     */
    randomWeight(weight, total = undefined) {
        const stepWeight = new Array(weight.length);
        for (let i = 0; i < weight.length; i++) {
            stepWeight[i] = (i === 0 ? 0 : stepWeight[i - 1]) + weight[i];
        }
        if (total !== undefined && total > stepWeight[stepWeight.length - 1]) {
            stepWeight.push(total);
        }
        const r = this.random(0, stepWeight[stepWeight.length - 1]);
        let start = 0;
        let end = stepWeight.length;
        while (start < end) {
            let mid = ((start + end) / 2) | 0;
            if (r < stepWeight[mid]) {
                end = mid;
            }
            else {
                start = mid + 1;
            }
        }
        return start;
    }
    /**
     * random in array.
     * return null when array invalid or length is zero.
     * @param array
     */
    randomArrayItem(array) {
        if (!array || array.length === 0)
            return null;
        return array[this.random(0, array.length, true)];
    }
    /**
     * random shuffle the order from 0 to count.
     * Fisher–Yates.
     * @param count
     */
    randomShuffleOrder(count) {
        const result = new Array(count);
        for (let i = 0; i < count; i++) {
            result[i] = i;
        }
        for (let i = count - 1; i > 0; i--) {
            const j = this.random(0, i, true);
            result[i] = result[i] ^ result[j];
            result[j] = result[i] ^ result[j];
            result[i] = result[i] ^ result[j];
        }
        return result;
    }
    /**
     * random shuffle the array.
     * Fisher–Yates.
     * @param items
     */
    randomShuffleArray(items) {
        if (this.isNullOrEmpty(items))
            return [];
        const count = items.length;
        const result = [...items];
        for (let i = count - 1; i > 0; i--) {
            const j = this.random(0, i, true);
            [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
    }
    /**
     * Get a random generator.
     * @param {number | number[]} length length or scale.
     * @return {RandomGenerator}
     */
    randomGenerator(length = 3) {
        return new RandomGenerator().random(length, this.defaultRandomFunc);
    }
    /**
     * Generate a random point located on the surface of a unit sphere in an arbitrary number of dimensions,
     * by Box-Muller transform and normalization.
     * @param dimension
     * @param randomFunc
     */
    randomDimensionSphere(dimension = 2, randomFunc = undefined) {
        if (dimension < 0 || dimension != (dimension | 0))
            return [];
        if (randomFunc === undefined) {
            randomFunc = this.defaultRandomFunc;
        }
        if (dimension === 1) {
            return randomFunc() >= 0.5 ? [1] : [-1];
        }
        if (dimension === 2) {
            const angle = Math.random() * 2 * Math.PI;
            return [Math.cos(angle), Math.sin(angle)];
        }
        const ans = new Array(dimension);
        let d2 = Math.floor(dimension >> 1) << 1;
        let r2 = 0;
        for (let i = 0; i < d2; i += 2) {
            const rr = -2.0 * Math.log(randomFunc());
            const r = Math.sqrt(rr);
            const theta = 2.0 * Math.PI * randomFunc();
            r2 += rr;
            ans[i] = r * Math.cos(theta);
            ans[i + 1] = r * Math.sin(theta);
        }
        if (dimension % 2) {
            const x = Math.sqrt(-2.0 * Math.log(randomFunc())) * Math.cos(2.0 * Math.PI * randomFunc());
            ans[dimension - 1] = x;
            r2 += Math.pow(x, 2);
        }
        const h = 1.0 / Math.sqrt(r2);
        for (let i = 0; i < dimension; ++i) {
            ans[i] *= h;
        }
        return ans;
    }
    /**
     * 格式化 Timestamp 至 00:00.
     *
     * @param timestamp
     * @param option 选择需显示的时间维度.
     */
    formatTimeFromTimestamp(timestamp, option = GtkTypes.TimeFormatDimensionFlags.Second |
        GtkTypes.TimeFormatDimensionFlags.Minute) {
        const date = new Date(timestamp);
        let result = "";
        if ((option & GtkTypes.TimeFormatDimensionFlags.Hour) > 0) {
            const hour = date.getHours().toString().padStart(2, "0");
            if (result.length > 0) {
                result += ":";
            }
            result += hour;
        }
        if ((option & GtkTypes.TimeFormatDimensionFlags.Minute) > 0) {
            const minutes = date.getMinutes().toString().padStart(2, "0");
            if (result.length > 0) {
                result += ":";
            }
            result += minutes;
        }
        if ((option & GtkTypes.TimeFormatDimensionFlags.Second) > 0) {
            const seconds = date.getSeconds().toString().padStart(2, "0");
            if (result.length > 0) {
                result += ":";
            }
            result += seconds;
        }
        return result;
    }
    /**
     * 时间转换.
     * 支持的时间单位范围：[毫秒,天]
     * @param val 原值.
     * @param from 原值时间维度.
     * @param to 目标时间维度.
     * @return {null} 入参在不支持的范围内时.
     */
    timeConvert(val, from, to) {
        if (from === to)
            return val;
        if (this.hammingWeight(from) !== 1 || this.hammingWeight(to) !== 1)
            return null;
        if ((0x1 << this.bitFirstOne(from)) > GtkTypes.TimeFormatDimensionFlags.Day ||
            (0x1 << this.bitFirstOne(to)) > GtkTypes.TimeFormatDimensionFlags.Day) {
            return null;
        }
        while (from !== to) {
            if (from > to) {
                switch (from) {
                    case GtkTypes.TimeFormatDimensionFlags.Second:
                        val *= GToolkit.MillisecondInSecond;
                        break;
                    case GtkTypes.TimeFormatDimensionFlags.Minute:
                        val *= GToolkit.SecondInMinute;
                        break;
                    case GtkTypes.TimeFormatDimensionFlags.Hour:
                        val *= GToolkit.MinuteInHour;
                        break;
                    case GtkTypes.TimeFormatDimensionFlags.Day:
                        val *= GToolkit.HourInDay;
                        break;
                }
                from >>= 0x1;
            }
            else {
                switch (from) {
                    case GtkTypes.TimeFormatDimensionFlags.Millisecond:
                        val /= GToolkit.MillisecondInSecond;
                        break;
                    case GtkTypes.TimeFormatDimensionFlags.Second:
                        val /= GToolkit.SecondInMinute;
                        break;
                    case GtkTypes.TimeFormatDimensionFlags.Minute:
                        val /= GToolkit.MinuteInHour;
                        break;
                    case GtkTypes.TimeFormatDimensionFlags.Hour:
                        val /= GToolkit.HourInDay;
                        break;
                }
                from <<= 0x1;
            }
        }
        return val;
    }
    /**
     * Clamp.
     * @param {number} val
     * @param {number} min=0
     * @param {number} max=1
     * @return {number}
     */
    clamp(val, min = 0, max = 1) {
        return Math.min(max, Math.max(min, val));
    }
    /**
     * 汉明重量.
     * num 作为二进制时 1 的个数.
     * @param num
     */
    hammingWeight(num) {
        let result = 0;
        let handle = 0;
        while ((0x1 << handle) <= num) {
            if ((num & 0x1 << handle) > 0) {
                ++result;
            }
            ++handle;
        }
        return result;
    }
    /**
     * num 的二进制形式中第一个 1 的位置.
     * @param num
     * @return {number} 位置.
     *      {-1} 时入参不合法.
     */
    bitFirstOne(num) {
        if ((num | 0) !== num)
            return -1;
        let handle = 0;
        while ((0x1 << handle) <= num)
            ++handle;
        return handle - 1;
    }
    /**
     * num 的二进制形式中指定数位是否为 1.
     * @param num
     * @param bit 从右向左数第 bit 位.
     */
    bitIn(num, bit) {
        return (num & (0x1 << bit)) > 0;
    }
    //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
    /**
     * 导出颜色字符串统一化.
     * @param {string} str
     * @param {boolean} fallback=false 是否 值不合法时 回退至透明.
     * @returns {mw.LinearColor | undefined}
     */
    catchMwExportColor(str, fallback = false) {
        if (this.isNullOrEmpty(str))
            return fallback ? new mw.LinearColor(0, 0, 0, 0) : undefined;
        str = str.replace(/\s/g, "");
        if (this.isNullOrEmpty(str))
            return fallback ? new mw.LinearColor(0, 0, 0, 0) : undefined;
        let result = this.tryCatchHex(str);
        if (result)
            return this.colorLikeToMwColor(result);
        result = this.tryCatchMwArray(str);
        if (result)
            return this.colorLikeToMwColor(result);
        result = this.tryCatchMwExport(str);
        if (result)
            return this.colorLikeToMwColor(result);
        return fallback ? new mw.LinearColor(0, 0, 0, 0) : undefined;
    }
    /**
     * 尝试捕获 mw 导出颜色字符串.
     * @param {string} str
     * @returns {IColor | undefined}
     */
    tryCatchMwExport(str) {
        this.REGEX_MW_EXPORT_COLOR_STR.lastIndex = 0;
        if (this.REGEX_MW_EXPORT_COLOR_STR.test(str)) {
            let ret = { r: 0, g: 0, b: 0, a: 0 };
            for (let regArray of this.REGEX_MW_EXPORT_COLOR_VALUE_STR[Symbol.matchAll](str)) {
                let v = Number(regArray[2]);
                if (Number.isNaN(v))
                    continue;
                switch (regArray[1].toUpperCase()) {
                    case "R":
                        ret.r = v;
                        break;
                    case "G":
                        ret.g = v;
                        break;
                    case "B":
                        ret.b = v;
                        break;
                    case "A":
                        ret.a = v;
                        break;
                }
            }
            if (ret.r === undefined)
                ret.r = 0;
            if (ret.g === undefined)
                ret.g = 0;
            if (ret.b === undefined)
                ret.b = 0;
            return ret;
        }
        else {
            return undefined;
        }
    }
    /**
     * 尝试捕获十六进制颜色字符串.
     * @param {string} str
     * @returns {IColor | undefined}
     */
    tryCatchHex(str) {
        this.REGEX_HEX_COLOR_STR.lastIndex = 0;
        if (this.REGEX_HEX_COLOR_STR.test(str)) {
            let ret = { r: 0, g: 0, b: 0, a: 0 };
            let strPure = str.replace("#", "");
            if (strPure.length === 3) {
                // to 6
                strPure = strPure.split("").map(item => `${item}${item}`).join();
            }
            else if (strPure.length === 4) {
                // to 8
                strPure = strPure.split("").map(item => `${item}${item}`).join();
            }
            else if (strPure.length !== 6 && strPure.length !== 8) {
                if (strPure.length <= 6) {
                    strPure = strPure + new Array(6 - strPure.length).fill("0").join("");
                }
                else {
                    // 这**绝对是来捣乱的
                    return undefined;
                }
            }
            ret.r = parseInt(strPure.slice(0, 2), 16);
            ret.g = parseInt(strPure.slice(2, 4), 16);
            ret.b = parseInt(strPure.slice(4, 6), 16);
            ret.a = parseInt(strPure.slice(6, 8), 16);
            if (Number.isNaN(ret.a))
                ret.a = undefined;
            return ret;
        }
        else {
            return undefined;
        }
    }
    /**
     * 尝试捕获 mw 配置颜色字符串.
     * @param {string} str
     * @returns {IColor | undefined}
     */
    tryCatchMwArray(str) {
        this.REGEX_MW_ARRAY_COLOR_STR.lastIndex = 0;
        if (this.REGEX_MW_ARRAY_COLOR_STR.test(str)) {
            let elements = str.split("|").map(item => Number(item)).filter(item => !isNaN(item));
            if (elements.length < 3) {
                return undefined;
            }
            return { r: elements[0], g: elements[1], b: elements[2], a: elements[3] };
        }
        else {
            return undefined;
        }
    }
    colorLikeToMwColor(colorLike) {
        if (colorLike.r > 1 || colorLike.g > 1 || colorLike.b > 1 || (colorLike.a ?? 0) > 1) {
            return new mw.LinearColor(colorLike.r / 255, colorLike.g / 255, colorLike.b / 255, colorLike?.a / 255 ?? 1);
        }
        return new mw.LinearColor(colorLike.r, colorLike.g, colorLike.b, colorLike?.a ?? 1);
    }
    /**
     * return a vector whose value is vec + v.
     * @param {V} vec
     * @param {number | V} v
     * @param {V} outer return new vector when undefined.
     * @return {V}
     */
    vectorAdd(vec, v, outer = undefined) {
        if (!outer) {
            outer = vec.clone();
        }
        if (this.isNumber(v)) {
            outer.x += v;
            outer.y += v;
            if ("z" in outer)
                outer.z += v;
            if ("w" in outer)
                outer.w += v;
        }
        else
            outer.add(v);
        return outer;
    }
    /**
     * return a vector whose value is vec - v.
     * @param {V} vec
     * @param {number | V} v
     * @param {V} outer return new vector when undefined.
     * @return {V}
     */
    vectorSub(vec, v, outer = undefined) {
        if (!outer) {
            outer = vec.clone();
        }
        if (this.isNumber(v)) {
            outer.x -= v;
            outer.y -= v;
            if ("z" in outer)
                outer.z -= v;
            if ("w" in outer)
                outer.w -= v;
        }
        else
            outer.subtract(v);
        return outer;
    }
    /**
     *
     * return a vector whose value is vec * v.
     * @param {V} vec
     * @param {number | V} v
     * @param {V} outer return new vector when undefined.
     * @return {V}
     */
    vectorMul(vec, v, outer = undefined) {
        if (!outer) {
            outer = vec.clone();
        }
        if (this.isNumber(v)) {
            outer.x *= v;
            outer.y *= v;
            if ("z" in outer)
                outer.z *= v;
            if ("w" in outer)
                outer.w *= v;
        }
        else
            outer.multiply(v);
        return outer;
    }
    /**
     *
     * return a vector whose value is vec / v.
     * @param {V} vec
     * @param {number | V} v
     * @param {V} outer return new vector when undefined.
     * @return {V}
     */
    vectorDiv(vec, v, outer = undefined) {
        if (!outer) {
            outer = vec.clone();
        }
        if (this.isNumber(v)) {
            outer.x /= v;
            outer.y /= v;
            if ("z" in outer)
                outer.z /= v;
            if ("w" in outer)
                outer.w /= v;
        }
        else
            outer.divide(v);
        return outer;
    }
    /**
     * clone a new vector with a new x.
     * @param vec origin vector.
     * @param val new value.
     */
    newWithX(vec, val) {
        if (vec instanceof mw.Vector) {
            return new mw.Vector(val, vec.y, vec.z);
        }
        else if (vec instanceof mw.Rotation) {
            return new mw.Rotation(val, vec.y, vec.z);
        }
        else if (vec instanceof mw.Vector2) {
            return new mw.Vector2(val, vec.y);
        }
    }
    /**
     * clone a new vector with a new y.
     * @param vec origin vector.
     * @param val new value.
     */
    newWithY(vec, val) {
        if (vec instanceof mw.Vector) {
            return new mw.Vector(vec.x, val, vec.z);
        }
        else if (vec instanceof mw.Rotation) {
            return new mw.Rotation(vec.x, val, vec.z);
        }
        else if (vec instanceof mw.Vector2) {
            return new mw.Vector2(vec.x, val);
        }
    }
    /**
     * clone a new vector with a new z.
     * @param vec origin vector.
     * @param val new value.
     */
    newWithZ(vec, val) {
        if (vec instanceof mw.Vector) {
            return new mw.Vector(vec.x, vec.y, val);
        }
        else if (vec instanceof mw.Rotation) {
            return new mw.Rotation(vec.x, vec.y, val);
        }
    }
    /**
     * 计算向量 a 至 b 之间的四元数.
     * @param lhs
     * @param rhs
     * @param fallbackAxis 回退轴. 当 lhs 与 rhs 共线时使用.
     */
    quaternionBetweenVector(lhs, rhs, fallbackAxis = undefined) {
        if (this.equal(lhs, rhs, GToolkit.SIMPLE_EPSILON)) {
            return mw.Quaternion.identity;
        }
        let axis = mw.Vector.cross(lhs, rhs);
        if (Math.abs(axis.length) < GToolkit.SIMPLE_EPSILON) {
            if (fallbackAxis !== undefined) {
                if (mw.Vector.dot(fallbackAxis, lhs) !== 0) {
                    axis = fallbackAxis;
                }
                else {
                    mw.console.warn("fallback Axis is not valid.");
                }
            }
            if (axis.length === 0) {
                axis = mw.Vector.cross(lhs, mw.Vector.right);
            }
            if (axis.length === 0) {
                axis = mw.Vector.cross(lhs, mw.Vector.up);
            }
        }
        const angle = mw.Vector.angle3D(lhs, rhs);
        return mw.Quaternion.fromAxisAngle(axis.normalized, this.radius(angle));
    }
    /**
     * //TODO_LviatYi [待补完]
     * 等值判断.
     * @param lhs
     * @param rhs
     * @param epsilon 精度误差.
     * @alpha
     */
    equal(lhs, rhs, epsilon = GtkTypes.Epsilon.Normal) {
        if (this.isNumber(lhs)) {
            return Math.abs(lhs - rhs) < epsilon;
        }
        if (lhs instanceof mw.Vector && rhs instanceof mw.Vector) {
            if (typeof epsilon === "number") {
                return this.equal(lhs.x, rhs.x, epsilon) &&
                    this.equal(lhs.y, rhs.y, epsilon) &&
                    this.equal(lhs.z, rhs.z, epsilon);
            }
            else if (epsilon instanceof mw.Vector) {
                return this.equal(lhs.x, rhs.x, epsilon.x) &&
                    this.equal(lhs.y, rhs.y, epsilon.y) &&
                    this.equal(lhs.z, rhs.z, epsilon.z);
            }
        }
        return false;
    }
    /**
     * Manhattan Distance.
     * 曼哈顿距离.
     * 当 b 为 null 时 将 a 视为向量. 并计算其长度平方.
     */
    manhattanDistance(a, b = null) {
        let result = 0;
        if (a instanceof Array) {
            if (b && a.length !== b.length)
                return result;
            for (let i = 0; i < a.length; i++) {
                result += Math.abs(a[i] - (b ? b[i] : 0));
            }
            return result;
        }
        else {
            result = Math.abs(a.x - (b ? b.x : 0)) +
                Math.abs(a.y - (b ? b.y : 0));
            if ("z" in a) {
                result += Math.abs(a.z - (b ? b.z : 0));
            }
            return result;
        }
    }
    /**
     * Squared Euclid Distance.
     * 两点欧几里得距离的平方.
     * 当 b 为 null 时 将 a 视为向量. 并计算其长度平方.
     * @param a
     * @param b
     */
    squaredEuclideanDistance(a, b = null) {
        let result = 0;
        if (a instanceof Array) {
            if (b && a.length !== b.length)
                return result;
            for (let i = 0; i < a.length; i++) {
                result += Math.pow(a[i] - (b ? b[i] : 0), 2);
            }
            return result;
        }
        else {
            result = Math.pow(a.x - (b ? b.x : 0), 2) +
                Math.pow(a.y - (b ? b.y : 0), 2);
            if ("z" in a) {
                result += Math.pow(a.z - (b ? b.z : 0), 2);
            }
            return result;
        }
    }
    /**
     * Euclid Distance.
     * 欧几里得距离.
     * 当 b 为 null 时 将 a 视为向量. 并计算其长度.
     * @param a
     * @param b
     */
    euclideanDistance(a, b = null) {
        return Math.sqrt(this.squaredEuclideanDistance(a, b));
    }
    /**
     * 将 origin 向量围绕 axis 轴旋转 angle 角度.
     * @param origin 初始向量.
     * @param axis
     * @param angle
     */
    rotateVector(origin, axis, angle) {
        const quaternion = mw.Quaternion.fromAxisAngle(axis.normalized, this.radius(angle));
        return quaternion.toRotation().rotateVector(origin);
    }
    /**
     * 屏幕坐标系 转 UI 坐标系.
     * @param location
     * @param parent=undefined 指定的父级 Widget.
     *      - undefined 使用 UIService.canvas 作为父级.
     *      - 全无效时使用 zero.
     */
    screenToUI(location, parent) {
        return location
            .clone()
            .subtract(parent
            ?.cachedGeometry
            ?.getAbsolutePosition() ??
            UIService?.canvas
                ?.cachedGeometry
                ?.getAbsolutePosition() ??
            mw.Vector2.zero)
            .divide(mw.getViewportScale());
    }
    /**
     * 泛型获取 GameObject.
     * @param guid
     */
    getGameObjectByGuid(guid) {
        return (mw.GameObject.findGameObjectById(guid) ?? null);
    }
    /**
     * 获取 GameObject 及其子 GameObject 下的所有指定脚本.
     * @param object
     * @param scriptCls
     * @param traverse 遍历深度. 从 1 计数.
     *      0 default. 无限遍历.
     */
    getComponent(object, scriptCls, traverse = 0) {
        if (!object)
            return [];
        const result = [];
        let traversed = 0;
        let stack = [object];
        let cache = [];
        do {
            for (const go of stack) {
                cache.push(...go.getChildren());
                result.push(...go.getComponents(scriptCls));
            }
            stack = cache;
            cache = [];
            ++traversed;
        } while (stack.length > 0 && (traverse === 0 || (traversed < traverse)));
        return result;
    }
    /**
     * 获取 GameObject 及其子 GameObject 下的首个指定脚本.
     * @param object
     * @param scriptCls
     * @param traverse 遍历深度. 从 1 计数.
     *      0 default. 无限遍历.
     */
    getFirstComponent(object, scriptCls, traverse = 0) {
        if (!object)
            return null;
        let traversed = 0;
        let stack = [object];
        let cache = [];
        do {
            for (const go of stack) {
                cache.push(...go.getChildren());
                const script = go.getComponent(scriptCls);
                if (script)
                    return script;
            }
            stack = cache;
            cache = [];
            ++traversed;
        } while (stack.length > 0 && (traverse === 0 || (traversed < traverse)));
        return null;
    }
    /**
     * 获取 GameObject 及其子 GameObject 下的所有指定脚本.
     * @param object
     * @param method
     * @param traverse 遍历深度. 从 1 计数.
     *      0 default. 无限遍历.
     */
    getComponentIs(object, method, traverse = 0) {
        if (!object)
            return [];
        const result = [];
        let traversed = 0;
        let stack = [object];
        let cache = [];
        do {
            for (const go of stack) {
                cache.push(...go.getChildren());
                result.push(...go.getComponents()
                    .filter(script => this.is(script, method))
                    .map((value) => value));
            }
            stack = cache;
            cache = [];
            ++traversed;
        } while (stack.length > 0 && (traverse === 0 || (traversed < traverse)));
        return result;
    }
    /**
     * 获取 GameObject 及其子 GameObject 下的首个指定脚本.
     * @param object
     * @param method
     * @param traverse 遍历深度. 从 1 计数.
     *      0 default. 无限遍历.
     */
    getFirstComponentIs(object, method, traverse = 0) {
        if (!object)
            return null;
        let traversed = 0;
        let stack = [object];
        let cache = [];
        do {
            for (const go of stack) {
                cache.push(...go.getChildren());
                const script = go.getComponents().find((s) => {
                    return this.is(s, method);
                });
                if (script)
                    return script;
            }
            stack = cache;
            cache = [];
            ++traversed;
        } while (stack.length > 0 && (traverse === 0 || (traversed < traverse)));
        return null;
    }
    /**
     * 获取 GameObject 及其子 GameObject 下的所有同名 GameObject.
     * @param object
     * @param name
     */
    getGameObject(object, name) {
        if (!object)
            return [];
        const result = [];
        let p = object;
        let stack = [p];
        while (stack.length > 0) {
            p = stack.shift();
            stack.push(...p.getChildren());
            result.push(...p.getChildren()
                .filter(g => g.name === name));
        }
        return result;
    }
    /**
     * 获取 GameObject 及其子 GameObject 下的首个同名 GameObject.
     * @param object
     * @param name
     */
    getFirstGameObject(object, name) {
        if (!object)
            return null;
        let p = object;
        let stack = [p];
        while (stack.length > 0) {
            p = stack.shift();
            stack.push(...p.getChildren());
            const result = p.getChildren().find((g) => {
                return g.name === name;
            });
            if (result)
                return result;
        }
        return null;
    }
    /**
     * 获取 GameObject 指定层数的所有子 GameObject.
     * @param object
     * @param traverse 遍历深度. 从 1 计数.
     *      - default undefined.
     *      - null 或 undefined 无限遍历.
     */
    getChildren(object, traverse = undefined) {
        if (!object)
            return [];
        let result = [...object.getChildren()];
        let p = 0;
        let traversed = 1;
        while (p < result.length && (this.isNullOrUndefined(traverse) || traversed < traverse)) {
            const currLength = result.length;
            for (; p < currLength; ++p) {
                result.push(...result[p].getChildren());
            }
            ++traversed;
        }
        return result;
    }
    /**
     * 获取场景中的根 GameObject.
     */
    getRootGameObject() {
        if (this._rootObj)
            return this._rootObj;
        this._rootObj = mw.GameObject.findGameObjectById(this.ROOT_GAME_OBJECT_GUID);
        if (!this._rootObj)
            this._rootObj = mw.GameObject.findGameObjectById(this.ROOT_GAME_OBJECT_GUID_BACKUP);
        if (!this._rootObj)
            this._rootObj = mw.GameObject.findGameObjectsByTag(this.ROOT_GAME_OBJECT_TAG_CUSTOM)[0];
        return this._rootObj;
    }
    /**
     * 在场景中的根 GameObject 上挂载脚本.
     */
    addRootScript(scriptCls) {
        let root = this.getRootGameObject();
        if (!root)
            root = mw.GameObject.spawn("Anchor", {
                replicates: false,
            });
        return root?.addComponent(scriptCls) ?? undefined;
    }
    /**
     * 在场景中的根 GameObject 上获取脚本.
     * @param {Constructor<T>} scriptCls
     * @return {T | null}
     */
    getRootScript(scriptCls) {
        return this.getRootGameObject()?.getComponent(scriptCls) ?? null;
    }
    /**
     * 在场景中的根 GameObject 上获取所有脚本.
     * @param {Constructor<T>} scriptCls
     * @return {T[] | null}
     */
    getRootScripts(scriptCls) {
        return this.getRootGameObject()?.getComponents(scriptCls) ?? null;
    }
    /**
     * 角色 性别.
     */
    gender(character) {
        let type = character.getDescription()
            .advance
            .base
            .characterSetting.somatotype;
        if (type === mw.SomatotypeV2.AnimeMale ||
            type === mw.SomatotypeV2.LowpolyAdultMale ||
            type === mw.SomatotypeV2.RealisticAdultMale ||
            type === mw.SomatotypeV2.CartoonyMale) {
            return GtkTypes.GenderTypes.Male;
        }
        else if (type === mw.SomatotypeV2.AnimeFemale ||
            type === mw.SomatotypeV2.LowpolyAdultFemale ||
            type === mw.SomatotypeV2.RealisticAdultFemale ||
            type === mw.SomatotypeV2.CartoonyFemale) {
            return GtkTypes.GenderTypes.Female;
        }
        else {
            return GtkTypes.GenderTypes.Helicopter;
        }
    }
    /**
     * GameObject 是否为 Character.
     * @param obj
     */
    isCharacter(obj) {
        return (obj instanceof mw.Character) && obj.player !== null;
    }
    /**
     * 是否 playerId gameObjectId 或 obj 指向自己.
     * @scope 仅客户端.
     * @param idOrObj
     */
    isSelfCharacter(idOrObj) {
        if (!SystemUtil.isClient()) {
            return false;
        }
        const self = Player.localPlayer;
        if (typeof idOrObj === "number") {
            return self.playerId === idOrObj;
        }
        else if (typeof idOrObj === "string") {
            return self.character.gameObjectId === idOrObj;
        }
        else {
            return this.isCharacter(idOrObj) && idOrObj.player === self;
        }
    }
    /**
     * playerId userId 与 player 归一化 player.
     * @param player
     */
    queryPlayer(player) {
        if (typeof player === "number" || typeof player === "string") {
            return Player.getPlayer(player);
        }
        return player;
    }
    /**
     * 获取角色胶囊体 下圆心坐标.
     * @param character
     */
    getCharacterCapsuleLowerCenter(character) {
        return character.worldTransform.position.add(this.getCharacterCapsuleLowerCenterRelative(character));
    }
    /**
     * 获取角色胶囊体 下圆心相对坐标.
     * @param character
     */
    getCharacterCapsuleLowerCenterRelative(character) {
        let pVec = this.getCharacterCapsuleLowerCenterVector(character).multiply(character.worldTransform.scale.z);
        pVec = character.localTransform.rotation.rotateVector(pVec);
        return pVec;
    }
    /**
     * 获取角色胶囊体 下圆心 相对于角色位置 向量.
     * 主管的 不受角色属性影响.
     * @param character
     */
    getCharacterCapsuleLowerCenterVector(character) {
        const rectHalfHeight = character.collisionExtent.z - character.collisionExtent.x;
        return mw.Vector.down.multiply(rectHalfHeight);
    }
    /**
     * 获取角色胶囊体 底部点.
     * @param character
     */
    getCharacterCapsuleBottomPoint(character) {
        let pVec = mw.Vector.down.multiply(character.collisionExtent.z * character.worldTransform.scale.z);
        pVec = character.localTransform.rotation.rotateVector(pVec);
        return character.worldTransform.position.add(pVec);
    }
    /**
     * 获取角色胶囊体 底部点.
     * @param character
     */
    getCharacterCapsuleBottomPointRelative(character) {
        let pVec = mw.Vector.down.multiply(character.collisionExtent.z * character.worldTransform.scale.z);
        pVec = character.localTransform.rotation.rotateVector(pVec);
        return pVec;
    }
    /**
     * 安全设置 Character Description.
     * @param character
     * @param description
     * @return set interval character state.
     */
    safeSetDescription(character, description) {
        if (!character || this.isNullOrEmpty(character?.gameObjectId))
            return false;
        if (this._characterDescriptionLockers.has(character.gameObjectId))
            return false;
        this._characterDescriptionLockers.add(character.gameObjectId);
        character
            .asyncReady()
            .then(() => {
            this.doWhenTrue(() => character.isDescriptionReady, () => {
                character.setDescription([description]);
                this._characterDescriptionLockers.delete(character.gameObjectId);
            });
        });
        return true;
    }
    /**
     * 设置 Button Guid.
     * 默认将 normalImageGuid 传播至:
     *   normalImageGuid
     *   pressedImageGuid
     *   disableImageGuid
     * @param button
     * @param normalGuid
     * @param pressedGuid
     * @param disableGuid
     */
    setButtonGuid(button, normalGuid, pressedGuid = undefined, disableGuid = undefined) {
        if (!pressedGuid) {
            pressedGuid = normalGuid;
        }
        if (!disableGuid) {
            disableGuid = normalGuid;
        }
        button.normalImageGuid = normalGuid;
        button.pressedImageGuid = pressedGuid;
        button.disableImageGuid = disableGuid;
    }
    /**
     * 尝试设置 UI 可见性.
     * 当不需改变时不设置.
     *
     * @param ui
     * @param visibility
     *  当为 boolean 时 将按照常用策略将 true 映射为 {@link mw.SlateVisibility.Visible} 或 {@link mw.SlateVisibility.SelfHitTestInvisible}.
     * @param syncEnable 是否同步设置 enable.
     *      true default. 当 ui 为 {@link mw.Button} 或 {@link mw.StaleButton} 时 将根据 visibility 同步设置 enable.
     * @return 返回是否发生实际更改.
     */
    trySetVisibility(ui, visibility, syncEnable = true) {
        ui = ui instanceof mw.Widget ? ui : ui.uiObject;
        if (typeof visibility === "boolean") {
            if (ui instanceof mw.Button || ui instanceof mw.StaleButton) {
                visibility = visibility ? mw.SlateVisibility.Visible : mw.SlateVisibility.Hidden;
            }
            else {
                visibility = visibility ? mw.SlateVisibility.SelfHitTestInvisible : mw.SlateVisibility.Hidden;
            }
        }
        if (syncEnable && (ui instanceof mw.Button || ui instanceof mw.StaleButton)) {
            ui.enable = visibility === mw.SlateVisibility.Visible;
        }
        if (ui.visibility === visibility) {
            return false;
        }
        ui.visibility = visibility;
        return true;
    }
    /**
     * 尝试设置 UI 文本性.
     * @desc 使用 LviatYi 等提供的 UIScriptHeader_Template. 将提供自动比较.
     * @param {mw.Text} ui
     * @param {string} text
     * @return {boolean}
     */
    trySetText(ui, text) {
        if (ui.text === text)
            return false;
        ui.text = text;
        return true;
    }
    /**
     * 是否 给定平台绝对坐标 在 UI 控件内.
     * @param ui
     * @param position
     */
    isPlatformAbsoluteInWidget(position, ui) {
        const absPos = ui.cachedGeometry.getAbsolutePosition();
        const absSize = ui.cachedGeometry.getAbsoluteSize();
        return position.x >= absPos.x &&
            position.x <= absPos.x + absSize.x &&
            position.y >= absPos.y &&
            position.y <= absPos.y + absSize.y;
    }
    /**
     * 获取 UI 空间下 控件的 计算后坐标.
     * @desc 计算后大小将考虑父子关系的坐标.
     * @param {Widget} ui
     * @return {mw.Vector2}
     */
    getUiResolvedPosition(ui) {
        return absoluteToLocal(UIService.canvas.cachedGeometry, ui.cachedGeometry.getAbsolutePosition());
    }
    /**
     * 获取 UI 空间下 控件的 计算后大小.
     * @desc 计算后大小将考虑父子关系的缩放.
     * @param {Widget} ui
     */
    getUiResolvedSize(ui) {
        return ui
            .cachedGeometry
            .getAbsoluteSize()
            .divide(getViewportScale());
    }
    /**
     * 获取 uiScript 构成的列表中 最上层 uiScript.
     * @desc 仅当
     * @param uis
     */
    getTopUi(uis) {
        if (this.isNullOrEmpty(uis))
            return null;
        let topUi = uis[0];
        if (!(topUi?.uiObject ?? null))
            return null;
        for (let i = 1; i < uis.length; ++i) {
            const ui = uis[i];
            if (!(ui?.uiObject ?? null))
                continue;
            if (ui.layer > topUi.layer ||
                (ui.uiObject["slot"]?.zOrder ?? -1) > (topUi.uiObject["slot"]?.zOrder ?? -1))
                topUi = ui;
        }
        return topUi ?? null;
    }
    compareWidgetStack(lhs, rhs) {
        const root = UIService.canvas;
        let rootLhs;
        let rootRhs;
        let pl = lhs;
        let pr = rhs;
        let lastPl;
        let lastPr;
        while (pl && pr) {
            if (pl === pr) {
                return this.compareSameParentWidgetStack(lastPl, lastPr) *
                    (!rootLhs && !rootRhs ? 1 : -1);
            }
            lastPl = pl;
            lastPr = pr;
            if (pl.parent && pl.parent !== root)
                pl = pl.parent;
            else if (!rootLhs) {
                if (pl.parent !== root)
                    return this.isWidgetAttachOnRoot(pr) ? -1 : 0;
                rootLhs = pl;
                pl = rhs;
            }
            if (pr.parent && pr.parent !== root)
                pr = pr.parent;
            else if (!rootRhs) {
                if (pr.parent !== root)
                    return this.isWidgetAttachOnRoot(pl) ? -1 : 0;
                rootRhs = pr;
                pr = lhs;
            }
            if (rootLhs && rootRhs) {
                // UIService layer manager needed.
                return rootLhs.zOrder - rootRhs.zOrder;
            }
        }
        return 0;
    }
    /**
     * Compare widget stack who has same parent.
     * @param {mw.Widget} lhs
     * @param {mw.Widget} rhs
     * @return {number}
     */
    compareSameParentWidgetStack(lhs, rhs) {
        if (lhs.zOrder !== rhs.zOrder)
            return lhs.zOrder - rhs.zOrder;
        return this.getWidgetIndexInParent(lhs) - this.getWidgetIndexInParent(rhs);
    }
    /**
     * Check if widget is attached on root.
     * 检查是否 Widget 挂在在指定的 root 上
     * @param {mw.Widget} widget
     * @param {mw.Widget} root=undefined
     *      - undefined: 默认指向 {@link UIService.canvas}
     * @return {boolean}
     */
    isWidgetAttachOnRoot(widget, root = undefined) {
        if (!widget)
            return false;
        if (!root)
            root = UIService.canvas;
        let p = widget;
        while (p) {
            if (p === root)
                return true;
            p = p.parent;
        }
        return false;
    }
    /**
     * Get widget index in parent.
     * @param {mw.Widget} widget
     * @return {number}
     *     - -1: widget is not attached on parent.
     */
    getWidgetIndexInParent(widget) {
        if (!widget.parent) {
            return -1;
        }
        return widget.parent["get"]()?.GetChildIndex(widget["get"]()) ?? -1;
    }
    /**
     * 获取 Ui 指定层数的所有子 Ui.
     * @param object
     * @param traverse 遍历深度. 从 1 计数.
     *      - default 1.
     *      - null 或 undefined 无限遍历.
     */
    getUiChildren(object, traverse = 1) {
        if (!object)
            return [];
        let result = [];
        for (let i = 0; i < object.getChildrenCount(); ++i)
            result.push(object.getChildAt(i));
        let p = 0;
        let traversed = 1;
        while (p < result.length && (this.isNullOrUndefined(traverse) || traversed < traverse)) {
            const currLength = result.length;
            for (; p < currLength; ++p) {
                for (let i = 0; i < result[p].getChildrenCount(); ++i)
                    result.push(result[p].getChildAt(i));
            }
            ++traversed;
        }
        return result;
    }
    /**
     * 使用 x,y 而非 Vector2 直接设定 UI 位置.
     * @param {Widget} ui
     * @param {number} x
     * @param {number} y
     */
    setUiPosition(ui, x, y) {
        try {
            ui["get"]()["SetPosition"](x, y);
        }
        catch (e) {
            ui.position = new mw.Vector2(x, y);
        }
    }
    setUiPositionX(ui, x) {
        this.setUiPosition(ui, x, ui.position.y);
    }
    setUiPositionY(ui, y) {
        this.setUiPosition(ui, ui.position.x, y);
    }
    /**
     * 使用 x,y 而非 Vector2 直接设定 UI 大小.
     * @param {Widget} ui
     * @param {number} x
     * @param {number} y
     */
    setUiSize(ui, x, y) {
        try {
            ui["get"]()["SetSize"](x, y);
        }
        catch (_) {
            ui.size = new mw.Vector2(x, y);
        }
    }
    setUiSizeX(ui, x) {
        this.setUiSize(ui, x, ui.size.y);
    }
    setUiSizeY(ui, y) {
        this.setUiSize(ui, ui.size.x, y);
    }
    /**
     * 使用 x,y 而非 Vector2 直接设定 UI 缩放.
     * @param {Widget} ui
     * @param {number} x
     * @param {number} y
     */
    setUiScale(ui, x, y) {
        try {
            if (!ui["_setRenderScale"]) {
                ui["_setRenderScale"] = new mw.Vector2(x, y)["toUEVector2D"]();
            }
            else {
                ui["_setRenderScale"].X = x;
                ui["_setRenderScale"].Y = y;
            }
            ui["w"]["SetRenderScale"](ui["_setRenderScale"]);
        }
        catch (_) {
            ui.renderScale = new mw.Vector2(x, y);
        }
    }
    setUiScaleX(ui, x) {
        this.setUiScale(ui, x, ui.renderScale.y);
    }
    setUiScaleY(ui, y) {
        this.setUiScale(ui, ui.renderScale.x, y);
    }
    /**
     * UI 坐标系下 Viewport 全尺寸.
     * @return {mw.Vector2}
     */
    getUiVirtualFullSize() {
        return getViewportWidgetGeometry()
            ?.getAbsoluteSize()
            ?.divide(getViewportScale());
    }
    /**
     * Viewport 纵横比. x/y.
     * @return {number}
     */
    getViewportRatio() {
        const s = getViewportSize();
        return s.x / s.y;
    }
    /**
     * 获取 窗口失焦回调.
     * @desc WindowUtil.onDefocus 的多次调用将生成多次回调.
     * @return {Delegate.SimpleDelegate<void>}
     */
    getOnWindowsBlurDelegate() {
        if (!this._globalOnlyOnBlurDelegate) {
            this._globalOnlyOnBlurDelegate = new Delegate.SimpleDelegate();
            WindowUtil.onDefocus.add(() => this._globalOnlyOnBlurDelegate.invoke());
        }
        return this._globalOnlyOnBlurDelegate;
    }
    /**
     * 垂直地形侦测.
     * 从起始点创建一条垂直向下的射线 返回命中到任何其他物体的命中点信息.
     * @param startPoint 起始点.
     * @param length 侦测距离.
     * @param self 自身 不参与检测.
     * @param ignoreObjectGuids 忽略物体 Guid.
     * @param debug 是否 绘制调试线.
     * @return hitPoint 命中首个点的命中信息 当未命中时返回 null.
     */
    detectVerticalTerrain(startPoint, length = 1000, self = undefined, ignoreObjectGuids = [], debug = false) {
        return QueryUtil.lineTrace(startPoint, this.newWithZ(startPoint, startPoint.z - length), false, debug, self ? [self.gameObjectId, ...ignoreObjectGuids] : [...ignoreObjectGuids], false, false)[0] ?? undefined;
    }
    /**
     * 垂直地形采样.
     * 从起始平台创建一条垂直向下的射线 返回命中到任何其他物体的命中点位置.
     * @param {IPoint2} startPoint
     * @param {number} platform
     * @param {number} length
     * @param {string[]} ignores
     * @param {boolean} ignoreByType
     * @param {boolean} traceSkeletonOnly
     * @param {mw.GameObject} self
     * @param {boolean} down
     * @param {boolean} debug
     * @return {mw.HitResult[] | undefined}
     */
    sampleVerticalTerrain(startPoint, platform, length, down = true, ignores = undefined, ignoreByType = false, traceSkeletonOnly = false, self = undefined, debug = false) {
        return QueryUtil.lineTrace(new Vector(startPoint.x, startPoint.y, platform), new Vector(startPoint.x, startPoint.y, platform + (down ? (-length) : length)), true, debug, ignores, ignoreByType, traceSkeletonOnly, self) ?? undefined;
    }
    /**
     * 忽略自身的 GameObject 垂直地形侦测.
     * @param self
     * @param length
     * @param ignoreObjectGuids
     * @param debug
     */
    detectGameObjectVerticalTerrain(self, length = 1000, ignoreObjectGuids = [], debug = false) {
        if (!self)
            return null;
        return this.detectVerticalTerrain(self.worldTransform.position, length, self, ignoreObjectGuids, debug);
    }
    /**
     * 角色正下方地形侦测.
     * 从 角色角色胶囊体 下圆心 创建一条垂直向下的射线 返回命中到任何其他物体的命中点信息.
     * @param length 最大探测距离.
     * @param ignoreObjectGuids 忽略物体 Guid.
     * @param debug 是否 绘制调试线.
     * @return hitPoint 命中首个点的命中信息 当未命中时返回 null.
     */
    detectCurrentCharacterTerrain(length = 1000, ignoreObjectGuids = [], debug = false) {
        if (!SystemUtil.isClient()) {
            return null;
        }
        const character = Player.localPlayer.character;
        const result = this.detectVerticalTerrain(this.getCharacterCapsuleLowerCenter(character), length, character, ignoreObjectGuids);
        if (debug && result) {
            this.drawRay(result.position, result.impactNormal, 100);
        }
        return result;
    }
    /**
     * 计算角色在地形上运动时的倾倒角.
     * 返回值为以正交系轴为参考.
     * @param character
     * @param ignoreObjectGuids 忽略物体 Guid.
     * @return [pitch, roll] 旋转角度.
     */
    calCentripetalAngle(character, ignoreObjectGuids = []) {
        const hitInfo = this.detectCurrentCharacterTerrain(undefined, ignoreObjectGuids, false);
        if (hitInfo) {
            const terrainNormal = hitInfo.impactNormal;
            const transform = character.worldTransform;
            const currUnitRight = mw.Vector.projectOnPlane(transform.getRightVector(), mw.Vector.up);
            const currUnitForward = mw.Vector.projectOnPlane(transform.getForwardVector(), mw.Vector.up);
            const currUnitUp = mw.Vector.cross(currUnitForward, currUnitRight);
            const sidePlaneNormal = currUnitRight;
            const frontPlaneNormal = currUnitForward;
            const projSide = mw.Vector.projectOnPlane(terrainNormal, sidePlaneNormal);
            const projFront = mw.Vector.projectOnPlane(terrainNormal, frontPlaneNormal);
            let pitch = mw.Vector.angle3D(currUnitUp, projSide);
            let roll = mw.Vector.angle3D(currUnitUp, projFront);
            pitch *= mw.Vector.angle3D(currUnitForward, projSide) > 90 ? -1 : 1;
            roll *= mw.Vector.angle3D(currUnitRight, projFront) > 90 ? -1 : 1;
            return [pitch, roll];
        }
        else
            return null;
    }
    /**
     * 绘制 Debug 用射线.
     * @param startPoint
     * @param direction
     * @param distance
     */
    drawRay(startPoint, direction, distance = 3000) {
        QueryUtil.lineTrace(startPoint, startPoint.clone().add(direction.clone().normalize().multiply(distance)), true, true);
    }
    /**
     * 是否 两点之间存在合法路径.
     * @param origin
     * @param dest
     */
    hasValidPath(origin, dest) {
        return Navigation.findPath(origin, dest).length > 0;
    }
    /**
     * KV 方式查询 ModuleData.
     * @param {string} moduleDataName
     * @param {string} userId
     * @param {string} defaultValue
     * @return {Promise<string>}
     */
    async queryModuleData(moduleDataName, userId, defaultValue = {}) {
        const data = await DataStorage.asyncGetData(this.getModuleDataKey(userId, moduleDataName));
        if (data.code !== mw.DataStorageResultCode.Success)
            return Promise.reject(`Query failed. error code: ${data.code}.`);
        if (this.isNullOrUndefined(data.data))
            return defaultValue;
        else
            return data.data;
    }
    /**
     * KV 方式更新 ModuleData.
     * @param {string} moduleDataName
     * @param {string} userId
     * @param {string} value
     * @return {Promise<boolean>}
     */
    async updateModuleData(moduleDataName, userId, value) {
        const data = await DataStorage.asyncSetData(this.getModuleDataKey(userId, moduleDataName), value);
        if (data !== mw.DataStorageResultCode.Success) {
            mw.console.warn(`update other game module data failed. error code: ${data}`);
            return false;
        }
        return true;
    }
    /**
     * 获取 ModuleData Key.
     * @param {string} userId
     * @param {string} moduleDataName
     * @return {string}
     */
    getModuleDataKey(userId, moduleDataName) {
        return `${userId}_SubData_${moduleDataName}`;
    }
    /**
     * 获取当前游戏版本.
     */
    getEditorVersion() {
        let version = mw.SystemUtil.getFullEditorVersion();
        if (version.startsWith("v") || version.startsWith("V")) {
            version = version.substring(1);
        }
        const versions = version.split(".");
        return new EditorVersion(Number(versions[1] ?? 0), Number(versions[3] ?? 0), Number(versions[4] ?? 0));
    }
    /**
     * 是否 当前平台默认使用鼠标.
     * @return {boolean}
     */
    get useMouse() {
        if (this._useMouse === undefined) {
            switch (mw.SystemUtil.currentPlatform) {
                case mw.RuntimePlatform.Windows:
                case mw.RuntimePlatform.Linux:
                case mw.RuntimePlatform.MacOS:
                    this._useMouse = true;
                    break;
                case mw.RuntimePlatform.Android:
                case mw.RuntimePlatform.iOS:
                default:
                    this._useMouse = false;
                    break;
            }
        }
        return this._useMouse;
    }
}
//#region Pure Js
//#region Constant
/**
 * 角度限制常数.
 * @private
 */
GToolkit.DEFAULT_ANGLE_CLAMP = [-180, 180];
/**
 * 圆周角.
 * @private
 */
GToolkit.CIRCLE_ANGLE = 360;
/**
 * 简略精度.
 * @private
 */
GToolkit.SIMPLE_EPSILON = 1e-6;
/**
 * 全高清分辨率.
 * @private
 */
GToolkit.FULL_HD = { x: 1920, y: 1080 };
/**
 * 全高清分辨率比例.
 * @private
 */
GToolkit.FULL_HD_RATIO = GToolkit.FULL_HD.x / GToolkit.FULL_HD.y;
/**
 * 1 天 24 小时.
 * @private
 */
GToolkit.HourInDay = 24;
/**
 * 1 小时 60 分钟.
 * @private
 */
GToolkit.MinuteInHour = 60;
/**
 * 1 分钟 60 秒.
 * @private
 */
GToolkit.SecondInMinute = 60;
/**
 * 1 秒 1000 毫秒.
 * @private
 */
GToolkit.MillisecondInSecond = 1e3;
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
//#region Types
var GtkTypes;
(function (GtkTypes) {
    (function (TimeFormatDimensionFlags) {
        /**
         * 毫秒.
         */
        TimeFormatDimensionFlags[TimeFormatDimensionFlags["Millisecond"] = 2] = "Millisecond";
        /**
         * 秒.
         */
        TimeFormatDimensionFlags[TimeFormatDimensionFlags["Second"] = 4] = "Second";
        /**
         * 分.
         */
        TimeFormatDimensionFlags[TimeFormatDimensionFlags["Minute"] = 8] = "Minute";
        /**
         * 时.
         */
        TimeFormatDimensionFlags[TimeFormatDimensionFlags["Hour"] = 16] = "Hour";
        /**
         * 日.
         */
        TimeFormatDimensionFlags[TimeFormatDimensionFlags["Day"] = 32] = "Day";
        /**
         * 月.
         */
        TimeFormatDimensionFlags[TimeFormatDimensionFlags["Month"] = 64] = "Month";
        /**
         * 年.
         */
        TimeFormatDimensionFlags[TimeFormatDimensionFlags["Year"] = 128] = "Year";
    })(GtkTypes.TimeFormatDimensionFlags || (GtkTypes.TimeFormatDimensionFlags = {}));
    (function (Tf) {
        /**
         * 毫秒.
         */
        Tf[Tf["Ms"] = 2] = "Ms";
        /**
         * 秒.
         */
        Tf[Tf["S"] = 4] = "S";
        /**
         * 分.
         */
        Tf[Tf["M"] = 8] = "M";
        /**
         * 时.
         */
        Tf[Tf["H"] = 16] = "H";
        /**
         * 日.
         */
        Tf[Tf["D"] = 32] = "D";
        /**
         * 月.
         */
        Tf[Tf["Mon"] = 64] = "Mon";
        /**
         * 年.
         */
        Tf[Tf["Y"] = 128] = "Y";
    })(GtkTypes.Tf || (GtkTypes.Tf = {}));
    (function (GenderTypes) {
        /**
         * 武装直升机.
         */
        GenderTypes[GenderTypes["Helicopter"] = 0] = "Helicopter";
        /**
         * 女性.
         */
        GenderTypes[GenderTypes["Female"] = 1] = "Female";
        /**
         * 男性.
         */
        GenderTypes[GenderTypes["Male"] = 2] = "Male";
    })(GtkTypes.GenderTypes || (GtkTypes.GenderTypes = {}));
    (function (Epsilon) {
        /**
         * 正常.
         * @type {Epsilon.Normal}
         */
        Epsilon[Epsilon["Normal"] = 0.000001] = "Normal";
        /**
         * 低精度.
         * @type {Epsilon.Low}
         */
        Epsilon[Epsilon["Low"] = 0.0001] = "Low";
        /**
         * 高精度.
         * @type {Epsilon.High}
         */
        Epsilon[Epsilon["High"] = 1e-8] = "High";
        /**
         * 超高精度.
         * @type {Epsilon.ExtraHigh}
         */
        Epsilon[Epsilon["ExtraHigh"] = 1e-12] = "ExtraHigh";
        /**
         *
         * @type {Epsilon.Scientific}
         */
        Epsilon[Epsilon["Scientific"] = 1e-16] = "Scientific";
    })(GtkTypes.Epsilon || (GtkTypes.Epsilon = {}));
    (function (Interval) {
        Interval[Interval["None"] = 0] = "None";
        Interval[Interval["Hz144"] = 6.944444444444445] = "Hz144";
        Interval[Interval["Hz120"] = 8.333333333333334] = "Hz120";
        Interval[Interval["Hz90"] = 11.11111111111111] = "Hz90";
        Interval[Interval["Hz60"] = 16.666666666666668] = "Hz60";
        Interval[Interval["Hz30"] = 33.333333333333336] = "Hz30";
        Interval[Interval["Sensitive"] = 100] = "Sensitive";
        Interval[Interval["Fast"] = 500] = "Fast";
        Interval[Interval["PerSec"] = 1000] = "PerSec";
        Interval[Interval["Slow"] = 3000] = "Slow";
        Interval[Interval["Logy"] = 5000] = "Logy";
        Interval[Interval["PerMin"] = 60000] = "PerMin";
        Interval[Interval["PerHour"] = 3600000] = "PerHour";
    })(GtkTypes.Interval || (GtkTypes.Interval = {}));
})(GtkTypes || (GtkTypes = {}));
/**
 * Editor Version.
 */
class EditorVersion {
    constructor(main, sub, patch) {
        this.main = main;
        this.sub = sub;
        this.patch = patch;
    }
    /**
     * 版本比较.
     * @desc 将忽略 undefined 字段，且遇到后不再继续比较.
     * @param {EditorVersion} rhs
     * @returns {number}
     *      >0 自身较新.
     *      =0 版本一直.
     *      <0 自身较旧.
     */
    compare(rhs) {
        let cmp = this.main - rhs.main;
        if (cmp > 0)
            return cmp;
        if (this.sub == undefined || rhs.sub == undefined)
            return 0;
        cmp = this.sub - rhs.sub;
        if (cmp > 0)
            return cmp;
        if (this.patch == undefined || rhs.patch == undefined)
            return 0;
        cmp = this.patch - rhs.patch;
        return cmp;
    }
}
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
//#region Delegate
/**
 * Delegate. 委托.
 * @desc provide some useful delegate.
 * @desc ---
 * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
 * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
 * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
 * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
 * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
 * @author LviatYi
 * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
 * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
 */
var Delegate;
(function (Delegate_1) {
    class DelegateInfo {
        constructor(callback, hitPoint, thisArg) {
            this.callback = callback;
            this.hitPoint = hitPoint;
            this.thisArg = thisArg;
        }
        equal(callback, thisArg) {
            return this.callback === callback &&
                this.thisArg === thisArg;
        }
    }
    class SimpleDelegateInfo extends DelegateInfo {
        constructor(callback, hitPoint, thisArg) {
            super(callback, hitPoint, thisArg);
        }
    }
    class ConditionDelegateInfo extends DelegateInfo {
        constructor(callback, hitPoint, thisArg) {
            super(callback, hitPoint, thisArg);
        }
    }
    class Delegate {
        constructor() {
            this._callbackInfo = [];
            this._clearable = true;
        }
        /**
         * try to get the index of an existing delegate.
         * @param func
         * @param thisArg
         * @return index func index. -1 not exist.
         * @protected
         */
        getIndex(func, thisArg) {
            return this._callbackInfo.findIndex(item => {
                return item.equal(func, thisArg);
            });
        }
        /**
         * remove Func by index.
         * @param index
         * @protected
         */
        removeByIndex(index) {
            Gtk.removeByIndex(this._callbackInfo, index);
        }
        /**
         * remove all delegate.
         */
        clear() {
            if (this._clearable)
                this._callbackInfo.length = 0;
            else
                mw.console.warn("GToolkit.Delegate", "Protected delegate can't be cleared.");
        }
        /**
         * whether remove all delegate is enable.
         */
        get clearable() {
            return this._clearable;
        }
        /**
         * set clearable to false.
         */
        setProtected() {
            this._clearable = false;
            return this;
        }
    }
    /**
     * Simple Delegate.
     * 简单委托.
     *
     * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
     * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
     * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
     * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
     * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
     * @author LviatYi
     * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
     * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
     */
    class SimpleDelegate extends Delegate {
        add(func, alive = -1, repeatable = false, thisArg) {
            if (!repeatable && this.getIndex(func) !== -1) {
                return false;
            }
            this._callbackInfo.push(new SimpleDelegateInfo(func, alive, thisArg));
        }
        once(func, thisArg) {
            return this.add(func, 1, false, thisArg);
        }
        only(func, thisArg) {
            this.clear();
            return this.add(func, undefined, false, thisArg);
        }
        invoke(...param) {
            for (let i = this._callbackInfo.length - 1; i >= 0; --i) {
                const callbackInfo = this._callbackInfo[i];
                try {
                    if (callbackInfo.hitPoint !== 0) {
                        callbackInfo.callback.call(callbackInfo.thisArg, ...param);
                    }
                    if (callbackInfo.hitPoint > 0)
                        --callbackInfo.hitPoint;
                    if (callbackInfo.hitPoint === 0)
                        this.removeByIndex(i);
                }
                catch (e) {
                    mw.console.error(e);
                    mw.console.error(e.stack);
                }
            }
        }
        remove(func, thisArg) {
            const index = this.getIndex(func, thisArg);
            if (index !== -1) {
                this.removeByIndex(index);
                return true;
            }
            return false;
        }
    }
    Delegate_1.SimpleDelegate = SimpleDelegate;
    /**
     * Condition Delegate
     * 条件委托.
     *
     * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
     * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
     * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
     * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
     * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
     * @author LviatYi
     * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
     * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
     */
    class ConditionDelegate extends Delegate {
        add(func, alive = -1, repeatable = false, thisArg) {
            if (!repeatable && this.getIndex(func, thisArg) !== -1) {
                return false;
            }
            this._callbackInfo.push(new ConditionDelegateInfo(func, alive, thisArg));
        }
        once(func, thisArg) {
            return this.add(func, 1, false, thisArg);
        }
        only(func, thisArg) {
            this.clear();
            return this.add(func, 1, false, thisArg);
        }
        invoke(...param) {
            for (let i = this._callbackInfo.length - 1; i >= 0; --i) {
                const callbackInfo = this._callbackInfo[i];
                let ret;
                if (callbackInfo.hitPoint !== 0) {
                    try {
                        ret = callbackInfo.callback.call(callbackInfo.thisArg, ...param);
                    }
                    catch (e) {
                        ret = false;
                        mw.console.error(e.stack);
                    }
                }
                if (callbackInfo.hitPoint > 0 && ret) {
                    --callbackInfo.hitPoint;
                }
                if (callbackInfo.hitPoint === 0) {
                    this.removeByIndex(i);
                }
            }
        }
        remove(func, thisArg) {
            const index = this.getIndex(func, thisArg);
            if (index !== -1) {
                this.removeByIndex(index);
                return true;
            }
            return false;
        }
    }
    Delegate_1.ConditionDelegate = ConditionDelegate;
})(Delegate || (Delegate = {}));
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
//#region Singleton
/**
 * Singleton factory.
 * To create a Singleton, extends Singleton<YourClass>().
 * @example
 * class UserDefineSingleton extends Singleton<UserDefineSingleton>() {
 *      public name: string;
 *
 *      public someSubMethod(): void {
 *          mw.console.log("someSubMethod in UserDefineSingleton called");
 *      }
 *
 *      protected onConstruct(): void {
 *          this.name = "user define singleton";
 *      }
 *  }
 * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
 * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
 * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
 * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
 * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
 * @author LviatYi
 * @constructor
 * @beta
 */
function Singleton() {
    var _a;
    return _a = class {
            /**
             * we don't recommend to use it.
             * if you want to do something when constructing, override onConstructor.
             * @protected
             */
            constructor() {
                this.createTime = new Date();
            }
            static getInstance() {
                if (!this["_instance"]) {
                    this["_instance"] = new this();
                    this["_instance"].onConstruct();
                }
                return this._instance;
            }
            /**
             * override when need extend constructor.
             */
            onConstruct() {
            }
        },
        _a._instance = undefined,
        _a;
}
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
//#region RandomGenerator
/**
 * Random Generator.
 * generate a number array and convert to supported types.
 */
class RandomGenerator {
    constructor() {
        this._result = [];
    }
    toVector3(fill = 0) {
        return new mw.Vector(this._result[0] ?? fill, this._result[1] ?? fill, this._result[2] ?? fill);
    }
    toVector2(fill = 0) {
        return new mw.Vector2(this._result[0] ?? fill, this._result[1] ?? fill);
    }
    toRotation(fill = 0) {
        return new mw.Rotation(this._result[0] ?? fill, this._result[1] ?? fill, this._result[2] ?? fill);
    }
    from(value) {
        this._result = value;
        return this;
    }
    /**
     * generate random array.
     * @param {number | number[]} length length or scale.
     * @param {() => number} randomFunc random function.
     *      - default Math.random
     * @return {this}
     */
    random(length, randomFunc = Math.random) {
        const isLength = typeof length === "number";
        this._result = new Array(isLength ? length : length.length);
        for (let i = 0; i < this._result.length; i++) {
            this._result[i] = randomFunc() * (isLength ? 1 : length[i]);
        }
        return this;
    }
    /**
     * generate random point on unit circle.
     * @return {this}
     */
    randomCircle() {
        let r = Math.random() * Math.PI * 2;
        this._result = [Math.cos(r), Math.sin(r)];
        return this;
    }
    /**
     * handle result by index.
     * @param {(value: number, index: number) => number} handler
     * @return {this}
     */
    handle(handler) {
        for (let i = 0; i < this._result.length; i++) {
            this._result[i] = handler(this._result[i], i);
        }
        return this;
    }
}
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
//#region Switcher
/**
 * advance switch.
 * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
 * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
 * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
 * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
 * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
 * @author LviatYi
 * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
 * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
 */
class Switcher {
    constructor() {
        this._cases = [];
        this._callbacks = [];
        this._default = null;
    }
    /**
     * build judge case.
     * @param callback
     * @param values
     *  when value is null or undefined, it will be ignored.
     */
    case(callback, ...values) {
        this._cases.push(values);
        this._callbacks.push(callback);
        return this;
    }
    /**
     * build judge default case.
     * @param callback
     */
    default(callback) {
        this._default = callback;
        return this;
    }
    /**
     * judge values.
     * @param values
     */
    judge(...values) {
        for (let i = 0; i < this._cases.length; i++) {
            let result = true;
            for (let j = 0; j < values.length; j++) {
                const pole = this._cases[i][j];
                if (pole === null || pole === undefined) {
                    continue;
                }
                result = values[j] === pole;
                if (!result)
                    break;
            }
            if (result) {
                this?._callbacks[i]?.();
                return;
            }
        }
        this?._default();
    }
}
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
//#region Regulator
/**
 * 分帧器.
 * @desc 为某个行为设定频率上限.
 * @desc ---
 * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
 * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
 * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
 * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
 * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
 * @author minjia.zhang
 * @author LviatYi
 * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
 * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
 */
class Regulator {
    /**
     * 尝试申请 下一次.
     */
    request() {
        const now = Date.now();
        const threshold = now - this.updateInterval;
        while (this._lastUpdates.length >= this.hitPoint) {
            if (this._lastUpdates[0] < threshold) {
                this._lastUpdates.shift();
            }
            else {
                break;
            }
        }
        if (this._lastUpdates.length < this.hitPoint) {
            this._lastUpdates.push(now);
            return true;
        }
        return false;
    }
    /**
     * @param updateInterval 更新间隔. ms
     * @param hitPoint 时段内次数.
     */
    constructor(updateInterval = 1e3, hitPoint = 1) {
        this._lastUpdates = [];
        /**
         * 生命值.
         * @desc 阶段时间内的可用次数.
         * @type {number}
         */
        this.hitPoint = 1;
        this.updateInterval = updateInterval;
        this.hitPoint = hitPoint;
    }
    /**
     * 频率. 每秒 ready 次数.
     */
    frequency(val) {
        this.updateInterval = 1000 / val;
        return this;
    }
    /**
     * 间隔.
     * @param val
     */
    interval(val) {
        this.updateInterval = val;
        return this;
    }
    /**
     * 获取只读的更新时间列表.
     */
    getRecord() {
        return this._lastUpdates;
    }
}
/**
 * 对象池.
 * @desc 执行自动垃圾回收.
 * @desc 可回收对象需实现 {@link IRecyclable} 接口.
 * @desc ---
 * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
 * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
 * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
 * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
 * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
 * @author LviatYi
 * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
 * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
 */
class ObjectPool {
    get autoHalvingInterval() {
        return this._autoHalvingInterval;
    }
    /**
     * 自动减半时间间隔. ms.
     *      - 0 [不推荐] 不开启自动回收.
     *      - 5 * 60e3. 5 min. 默认的.
     */
    set autoHalvingInterval(value) {
        if (value === this._autoHalvingInterval) {
            return;
        }
        this._autoHalvingInterval = value;
        if (this._autoHalvingTimer) {
            clearInterval(this._autoHalvingTimer);
            this._autoHalvingTimer = null;
        }
        if (value !== 0) {
            this._autoHalvingTimer = mw.setInterval(() => this.autoRecycle(), value);
        }
    }
    getNew() {
        return this._itemConstructor ?
            new this._itemConstructor() :
            this?._itemGenerator() ?? null;
    }
    //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
    constructor(option) {
        this._pool = [];
        this._tempPool = [];
        this._lastAutoRecycleTime = 0;
        //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
        //#region Event
        /**
         * 归还事件.
         * @type {Delegate.SimpleDelegate<T>}
         */
        this.onPush = new Delegate.SimpleDelegate();
        /**
         * 借出事件.
         * @type {Delegate.SimpleDelegate<T>}
         */
        this.onPop = new Delegate.SimpleDelegate();
        /**
         * 垃圾回收事件.
         * @type {Delegate.SimpleDelegate<T[]>}
         */
        this.onRecycle = new Delegate.SimpleDelegate();
        /**
         * 清除事件.
         * @type {Delegate.SimpleDelegate<T[]>}
         */
        this.onClear = new Delegate.SimpleDelegate();
        this._itemConstructor = option?.construct;
        this._itemGenerator = option?.generator;
        if (!this._itemConstructor && !this._itemGenerator) {
            mw.console.log("GToolkit.ObjectPool", `you must provide a constructor or a generator.`);
            return;
        }
        this.autoHalvingInterval = option?.autoHalvingInterval ?? 5 * 60e3;
        this._floor = option?.floor ?? 0;
        if (option?.instantly) {
            for (let i = 0; i < this._floor; i++) {
                this.push(this.getNew());
            }
        }
    }
    //#region Controller
    /**
     * 使池回收一个对象.
     * @param {T} rub
     */
    push(...rub) {
        try {
            rub.forEach(r => r.makeDisable());
            this._pool.push(...rub);
            rub.forEach(r => this.onPush.invoke(...[r]));
        }
        catch (e) {
            mw.console.error("GToolkit.ObjectPool");
            mw.console.error(`error occurs in makeDisable. ${e}`);
            mw.console.error(e.stack);
        }
    }
    /**
     * 从池中取出一个对象 并赋初值..
     * @param {any} params
     */
    pop(...params) {
        this._lastAutoRecycleTime = Date.now();
        let need;
        if (this._tempPool.length > 0)
            need = this._tempPool.pop();
        else
            need = this._pool.pop();
        if (!need)
            need = this.getNew();
        if (!need) {
            mw.console.warn("GToolkit.ObjectPool", `item couldn't be generated.`);
            return null;
        }
        this.onPop.invoke(...[need]);
        try {
            need.makeEnable(...params);
        }
        catch (e) {
            mw.console.error("GToolkit.ObjectPool");
            mw.console.error(`error occurs in makeEnable. ${e}`);
            mw.console.error(e.stack);
        }
        return need;
    }
    /**
     * 临时回收一个对象.
     * @desc 临时回收的对象直到 {@link finishTemp} 后才调用 {@link makeDisable}.
     * @desc 减少一次 {@link makeDisable} 调用
     * @param {T} rub
     */
    tempPush(...rub) {
        this._tempPool.push(...rub);
    }
    /**
     * 结束临时回收.
     * @desc 立即回收所有临时回收对象
     */
    finishTemp() {
        this.push(...this._tempPool);
        this._tempPool.length = 0;
    }
    /**
     * 立即执行自动垃圾回收策略.
     */
    doRecycle() {
        if (this._tempPool.length > 0)
            this.finishTemp();
        this.autoRecycle();
    }
    /**
     * 清空池.
     */
    clear() {
        if (this._tempPool.length > 0)
            this.finishTemp();
        this.onClear.invoke(this._pool);
        this._pool.forEach(item => {
            try {
                item?.makeDestroy();
            }
            catch (e) {
                mw.console.error("GToolkit.ObjectPool", `error occurs in makeDestroy.\n${e.stack}`);
            }
        });
        this._pool = [];
    }
    //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
    autoRecycle() {
        if (this._pool.length <= this._floor)
            return;
        const newLength = Math.max(Math.floor(this._pool.length / 2), this._floor);
        const recycle = this._pool.splice(newLength);
        this.onRecycle.invoke(recycle);
        recycle.forEach(item => {
            try {
                item?.makeDestroy();
            }
            catch (e) {
                mw.console.error("GToolkit.ObjectPool", `error occurs in makeDestroy.\n${e.stack}`);
            }
        });
    }
}
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
//#region Hyper Text
/**
 * HyperText 超文本解析器.
 * @desc 将超文本字符串转换为 Dom 树.
 * @desc 提供字符串切片功能.
 * @desc ---
 * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
 * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
 * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
 * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
 * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
 * @author LviatYi
 * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
 * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
 */
class HyperText {
    constructor() {
        this.tag = undefined;
        this.attr = undefined;
        this.content = [];
    }
    get length() {
        if (this._length === undefined) {
            this._length = this
                .content
                .reduce((prev, curr) => prev + curr.length, 0);
        }
        return this._length;
    }
    /**
     * 转换为严格的超文本.
     * @desc 严格超文本将补全未闭合的标签.
     * @param {string} str
     * @return {string | undefined} 当传入的超文本字符串非法时 返回 undefined.
     *      - 当标签发生交错时 无效.
     */
    static toStrictHyperText(str) {
        let tagStack = [];
        this.RegTag.lastIndex = 0;
        while (true) {
            let result = this.RegTag.exec(str);
            if (result) {
                if (!Gtk.isNullOrEmpty(result[1])) {
                    if (tagStack.length > 0 && tagStack[tagStack.length - 1] === result[2]) {
                        tagStack.pop();
                    }
                    else {
                        // Invalid HyperText.
                        // 交错 Tag.
                        return undefined;
                    }
                }
                else {
                    tagStack.push(result[2]);
                }
            }
            else {
                break;
            }
        }
        while (tagStack.length > 0) {
            str += `</${tagStack.pop()}>`;
        }
        return str;
    }
    /**
     * 从超文本字符串构建.
     * @param {string} str
     * @param {string} tag
     * @param {string} attr
     * @param {boolean} strict=true 是否 启用严格检查.
     *      - false 需保证提供了严格有效的超文本字符串.
     * @return {HyperText | undefined} 当传入的超文本字符串非法时 返回 undefined.
     *      - 当标签发生交错时 无效.
     */
    static fromString(str, tag, attr, strict = true) {
        if (strict)
            str = this.toStrictHyperText(str);
        if (!str)
            return undefined;
        let hyperText = new HyperText();
        hyperText.tag = tag;
        hyperText.attr = attr;
        let walked = 0;
        this.RegElement.lastIndex = 0;
        while (walked < str.length) {
            let result = this.RegElement.exec(str);
            let pureLeft = result?.index ?? 0;
            if (pureLeft > walked) {
                hyperText.content.push(str.slice(walked, pureLeft));
            }
            if (result) {
                let lastIndex = this.RegElement.lastIndex;
                hyperText.content.push(HyperText.fromString(str.slice(pureLeft + result[1].length + (result[2]?.length ?? 0) + 2, pureLeft + result[1].length + (result[2]?.length ?? 0) + 2 + result[3].length), result[1], result[2], false));
                this.RegElement.lastIndex = lastIndex;
                walked = result.index + result[0].length;
            }
            else {
                hyperText.content.push(str.slice(walked));
                break;
            }
        }
        return hyperText;
    }
    /**
     * 切片.
     * @param {number} start
     * @param {number} end
     * @return {string}
     */
    slice(start, end) {
        let result = "";
        let walked = 0;
        for (const content of this.content) {
            if (walked >= end)
                break;
            if (walked + content.length <= start) {
                start -= content.length;
                walked += content.length;
                continue;
            }
            result += content.slice(start, end - walked);
            start = Math.max(0, start - content.length);
            walked += Math.min(content.length, end - walked);
        }
        return this.tag ? surroundByTag(result, this.tag, this.attr) : result;
    }
}
HyperText.RegTag = /<\s*(\/?)\s*(u|b|i|s|color|size)\s*(=.*?)?>/g;
HyperText.RegElement = /<\s*(u|b|i|s|color|size)\s*(=.*?)?>(.*?)<\s*\/\1\s*>/g;
/**
 * surround the string with tag.
 * @param {string} tag
 * @param {string} str
 * @param {string} attr
 * @return {string}
 */
function surroundByTag(str, tag, attr) {
    return `<${tag}${attr ?? ""}>${str}</${tag}>`;
}
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
//#region Export
const Gtk = new GToolkit();
//#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄

export { Delegate, EditorVersion, GtkTypes, HyperText, ObjectPool, RandomGenerator, Regulator, Singleton, Switcher, Gtk as default };
//# sourceMappingURL=index.js.map
