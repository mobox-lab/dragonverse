import { ParamInputSizeY } from '../param-base/IGodModParamInput.js';
import Gtk, { Delegate } from 'gtoolkit';
import { Lui, AutoComplete, Property } from 'mw-lynx-ui';
import { GodModPanelSizeX } from '../base/GodModPanelConst.js';
import { GodModParamInputBase } from '../param-base/GodModParamInputBase.js';
import Log4Ts from '../../log4ts/Log4Ts.js';

var Color = Lui.Asset.Color;
let shareInput;
const enumValConcreteMap = new Map();
const enumValConcreteIndexer = new Map();
function getEnumValConcrete(enumObj) {
    return Gtk.tryGet(enumValConcreteMap, enumObj, () => {
        const indexer = new Map();
        const enumValList = [];
        Gtk.enumVals(enumObj)
            .forEach((item) => {
            let key = enumObj[item];
            indexer.set(key, item);
            enumValList.push({
                label: key,
                value: item,
            });
        });
        enumValConcreteIndexer.set(enumObj, indexer);
        return enumValList;
    });
}
/**
 * GodModEnumParamInput.
 *
 * ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟
 * ⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄
 * ⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄
 * ⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄
 * ⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
 * @author LviatYi
 * @font JetBrainsMono Nerd Font Mono https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
 * @fallbackFont Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.41.6/sarasa-gothic-ttf-0.41.6.7z
 * @internal
 */
class GodModEnumParamInput extends GodModParamInputBase {
    //#region Lui Component
    static create() {
        const input = new GodModEnumParamInput();
        if (!shareInput) {
            shareInput = AutoComplete.create({
                label: "enum",
                items: [],
                size: { x: GodModPanelSizeX, y: ParamInputSizeY },
                color: {
                    primary: Color.Blue,
                    secondary: Color.Blue200,
                },
                itemHeight: 40,
                maxCount: 6,
                fontSize: 16,
                fontStyle: mw.UIFontGlyph.Light,
                corner: Property.Corner.Top,
            }).attach(input);
        }
        else {
            shareInput.attach(input);
        }
        Gtk.setUiSize(input.root, GodModPanelSizeX, ParamInputSizeY);
        return input;
    }
    ;
    //#endregion ⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠒⠒⠒⠒⠚⠛⣿⡟⠄⠄⢠⠄⠄⠄⡄⠄⠄⣠⡶⠶⣶⠶⠶⠂⣠⣶⣶⠂⠄⣸⡿⠄⠄⢀⣿⠇⠄⣰⡿⣠⡾⠋⠄⣼⡟⠄⣠⡾⠋⣾⠏⠄⢰⣿⠁⠄⠄⣾⡏⠄⠠⠿⠿⠋⠠⠶⠶⠿⠶⠾⠋⠄⠽⠟⠄⠄⠄⠃⠄⠄⣼⣿⣤⡤⠤⠤⠤⠤⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
    //#region IGodModParamInputParametric
    getParam() {
        return shareInput?.choose?.value;
    }
    setParam(p) {
        const enumObj = this._currentHoldObject;
        const item = enumValConcreteMap
            .get(enumObj)
            ?.find(item => item.value === p);
        if (item !== undefined) {
            shareInput.choose = item;
        }
        else {
            shareInput.choose = undefined;
        }
    }
    setEnumObj(enumObj) {
        this._currentHoldObject = enumObj;
        shareInput
            ?.attach(this)
            ?.reloadItems(getEnumValConcrete(enumObj));
    }
    setValidator(validator) {
        if (validator) {
            Log4Ts.log(GodModEnumParamInput, `Enum don't need any validator.`);
        }
    }
    setCustomLabel(label) {
        if (!label)
            return;
        Log4Ts.warn(GodModEnumParamInput, `custom label not supported when Enum param.`);
    }
    get validated() {
        return { result: true };
    }
    get onCommit() {
        if (!this._onCommit) {
            this._onCommit = new Delegate.SimpleDelegate();
            shareInput.onChoose.add(() => this._onCommit.invoke());
        }
        return this._onCommit;
    }
}

export { GodModEnumParamInput as default };
//# sourceMappingURL=GodModEnumParamInput.js.map
